diff --git a/.gitignore b/.gitignore
index 4ccab8104..ea27ca413 100644
--- a/.gitignore
+++ b/.gitignore
@@ -16,9 +16,11 @@ extracted/
 build/
 expected/
 docs/doxygen/
+*.bin
 *.z64
 *.n64
 *.v64
+*.wad
 
 # Tools
 .venv/
diff --git a/.make_wii-vc.mk b/.make_wii-vc.mk
new file mode 100644
index 000000000..c87a5825b
--- /dev/null
+++ b/.make_wii-vc.mk
@@ -0,0 +1,96 @@
+# Example usage:
+# - make wad VERSION=ntsc-1.2
+# - make iso VERSION=ntsc-1.2
+#
+# if building a mod for the GameCube, you will need to build this: https://github.com/Yanis002/oot-gc/tree/oot_gcc_compat
+# and place the build in the baseroms folder (see `DOL` below)
+
+## Tools
+
+# You can get gzinject here https://github.com/PracticeROM/gzinject
+GZINJECT ?= gzinject
+
+COPY ?= cp -v
+
+# This tool generates a file that the (modified) emulator can read
+# to figure out which parts of the rom to cache.
+# It outputs file indices from the rom and the location and the size of `gDmaDataTable`.
+GEN_DMA_CONFIG := tools/generate_dma_config.py
+
+# This tool generates a file that the (modified) emulator can read
+# to figure out where some of the N64 functions are to apply the proper hacks
+# to make the game run properly.
+# By default, the emulator will compute a checksum and it tries to find functions based on
+# the calculated checksum and the size of the function, though this can fail completely
+# since other compilers like GCC can change these values, this system is a workaround for that.
+# Note: this is only useful when building with GCC.
+GEN_LIB_CONFIG := tools/generate_lib_config.py
+
+## Files
+
+BASEWAD := baseroms/baserom-$(REGION).wad
+COMMON_KEY := baseroms/common-key.bin
+WAD := $(ROM:.z64=.wad)
+
+# for ISOs we pick the MQ-JP one for all versions and instead patch the emulator
+BASEISO := baseroms/baserom.iso
+ISO := $(ROM:.z64=.iso)
+DMA_CONFIG_FILE := dma_config.bin
+LIB_CONFIG_FILE := lib_config.bin
+
+# set to 1 to inject in MQ
+MQ_INJECT ?= 0
+
+ifeq ($(MQ_INJECT),1)
+ROM_NAME := urazlj_f
+else
+ROM_NAME := zlj_f
+endif
+
+# the emulator replacement dol, can be empty skip this step
+DOL := baseroms/oot-gc.dol
+
+## Flags
+
+# wad or iso to make a compatible gcc build
+TARGET :=
+
+ifeq ($(COMPILER),gcc)
+ifneq ($(TARGET),)
+CFLAGS += -fno-reorder-blocks -fno-optimize-sibling-calls -fno-toplevel-reorder
+CPPFLAGS += -fno-reorder-blocks -fno-optimize-sibling-calls -fno-toplevel-reorder
+
+# Disables `.set gp=64` in exceptasm.s
+CCASFLAGS += -DTARGET_GC
+
+$(BUILD_DIR)/src/audio/internal/seqplayer.o: OPTFLAGS := -O1
+endif
+endif
+
+## Targets
+
+wad:
+	$(MAKE) compress TARGET=wad
+	$(GZINJECT) -a inject -k $(COMMON_KEY) -m $(ROMC) -w $(BASEWAD) -o $(WAD) -p gzi/$(REGION).gzi
+	$(RM) -r wadextract/
+
+# for ISOs we need to do things manually since we want to remove
+# the useless files that increase the size of the file by a lot
+iso:
+	$(MAKE) compress TARGET=iso
+	$(GZINJECT) -a extract -s $(BASEISO)
+	$(PYTHON) $(GEN_DMA_CONFIG) -v $(VERSION)
+	$(COPY) $(BUILD_DIR)/$(DMA_CONFIG_FILE) isoextract/zlj_f.tgc/$(DMA_CONFIG_FILE)
+ifneq ($(COMPILER),ido)
+	$(PYTHON) $(GEN_LIB_CONFIG) -v $(VERSION)
+	$(COPY) $(BUILD_DIR)/$(LIB_CONFIG_FILE) isoextract/zlj_f.tgc/$(LIB_CONFIG_FILE)
+endif
+	$(COPY) $(ROMC) isoextract/zlj_f.tgc/$(ROM_NAME).n64
+ifneq ($(DOL),)
+	$(COPY) $(DOL) isoextract/zlj_f.tgc/main.dol
+endif
+	$(RM) -r isoextract/S_*.tgc/ isoextract/zlj_f.tgc/*.thp
+	$(GZINJECT) -a pack -s $(ISO)
+	$(RM) -r isoextract/
+
+.PHONY: wad iso
diff --git a/Dockerfile b/Dockerfile
index 92a072996..5fc3a19ab 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -7,6 +7,7 @@ RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone &
     apt-get update && \
     apt-get install -y \
         binutils-mips-linux-gnu \
+        gcc-mips-linux-gnu \
         build-essential \
         pkg-config \
         python3 \
diff --git a/Makefile b/Makefile
index 56134bd7f..c91d73d13 100644
--- a/Makefile
+++ b/Makefile
@@ -16,28 +16,16 @@ SHELL = /usr/bin/env bash
 # If COMPARE is 1, check the output md5sum after building. Set to 0 when modding.
 COMPARE ?= 1
 # If NON_MATCHING is 1, define the NON_MATCHING C flag when building. Set to 1 when modding.
-NON_MATCHING ?= 0
+NON_MATCHING ?= 1
 # If ORIG_COMPILER is 1, compile with QEMU_IRIX and the original compiler.
 ORIG_COMPILER ?= 0
 # If COMPILER is "gcc", compile with GCC instead of IDO.
-COMPILER ?= ido
+COMPILER ?= gcc
 # Target game version. Ensure the corresponding input ROM is placed in baseroms/$(VERSION)/baserom.z64.
 # Currently the following versions are supported:
-#   ntsc-1.0       N64 NTSC 1.0 (Japan/US depending on REGION)
-#   ntsc-1.1       N64 NTSC 1.1 (Japan/US depending on REGION)
-#   pal-1.0        N64 PAL 1.0 (Europe)
-#   ntsc-1.2       N64 NTSC 1.2 (Japan/US depending on REGION)
+#   randomizer     Randomizer, requires pal-1.1 baserom
 #   pal-1.1        N64 PAL 1.1 (Europe)
-#   gc-jp          GameCube Japan
-#   gc-jp-mq       GameCube Japan Master Quest
-#   gc-us          GameCube US
-#   gc-us-mq       GameCube US Master Quest
-#   gc-eu-mq-dbg   GameCube Europe/PAL Master Quest Debug (default)
-#   gc-eu          GameCube Europe/PAL
-#   gc-eu-mq       GameCube Europe/PAL Master Quest
-#   gc-jp-ce       GameCube Japan (Collector's Edition disc)
-#   ique-cn        iQue Player (Simplified Chinese)
-VERSION ?= gc-eu-mq-dbg
+VERSION ?= randomizer
 # Number of threads to extract and compress with.
 N_THREADS ?= $(shell nproc)
 # If DEBUG_OBJECTS is 1, produce additional debugging files such as objdump output or raw binaries for assets
@@ -58,41 +46,16 @@ N64_EMULATOR ?=
 
 # Version-specific settings
 REGIONAL_CHECKSUM := 0
-ifeq ($(VERSION),ntsc-1.0)
-  REGIONAL_CHECKSUM := 1
-  REGION ?= JP
-  PLATFORM := N64
-  DEBUG_FEATURES ?= 0
-  BUILD_CREATOR := zelda@srd44
-  BUILD_DATE := 98-10-21
-  BUILD_TIME := 04:56:31
-  REVISION := 0
-else ifeq ($(VERSION),ntsc-1.1)
-  REGIONAL_CHECKSUM := 1
-  REGION ?= JP
-  PLATFORM := N64
-  DEBUG_FEATURES ?= 0
-  BUILD_CREATOR := zelda@srd44
-  BUILD_DATE := 98-10-26
-  BUILD_TIME := 10:58:45
-  REVISION := 1
-else ifeq ($(VERSION),pal-1.0)
-  REGION ?= EU
-  PLATFORM := N64
+ifeq ($(VERSION),randomizer)
+  REGIONAL_CHECKSUM := 0
+  REGION ?= US
+  PLATFORM ?= N64
   DEBUG_FEATURES ?= 0
-  BUILD_CREATOR := zelda@srd44
-  BUILD_DATE := 98-11-10
-  BUILD_TIME := 14:34:22
+  BUILD_CREATOR ?= someone
+  BUILD_DATE ?= $(shell date +'%y-%m-%d')
+  BUILD_TIME ?= $(shell date +'%H:%M:%S')
+  BUILD_VERSION ?= $(shell date +'%y%m%d')
   REVISION := 0
-else ifeq ($(VERSION),ntsc-1.2)
-  REGIONAL_CHECKSUM := 1
-  REGION ?= JP
-  PLATFORM := N64
-  DEBUG_FEATURES ?= 0
-  BUILD_CREATOR := zelda@srd44
-  BUILD_DATE := 98-11-12
-  BUILD_TIME := 18:17:03
-  REVISION := 2
 else ifeq ($(VERSION),pal-1.1)
   REGION ?= EU
   PLATFORM := N64
@@ -100,79 +63,8 @@ else ifeq ($(VERSION),pal-1.1)
   BUILD_CREATOR := zelda@srd44
   BUILD_DATE := 98-11-18
   BUILD_TIME := 17:36:49
+  BUILD_VERSION := ""
   REVISION := 1
-else ifeq ($(VERSION),gc-jp)
-  REGION ?= JP
-  PLATFORM := GC
-  DEBUG_FEATURES ?= 0
-  BUILD_CREATOR := zelda@srd022j
-  BUILD_DATE := 02-10-29
-  BUILD_TIME := 23:49:53
-  REVISION := 15
-else ifeq ($(VERSION),gc-jp-mq)
-  REGION ?= JP
-  PLATFORM := GC
-  DEBUG_FEATURES ?= 0
-  BUILD_CREATOR := zelda@srd022j
-  BUILD_DATE := 02-10-30
-  BUILD_TIME := 00:15:15
-  REVISION := 15
-else ifeq ($(VERSION),gc-us)
-  REGION ?= US
-  PLATFORM := GC
-  DEBUG_FEATURES ?= 0
-  BUILD_CREATOR := zelda@srd022j
-  BUILD_DATE := 02-12-19
-  BUILD_TIME := 13:28:09
-  REVISION := 15
-else ifeq ($(VERSION),gc-us-mq)
-  REGION ?= US
-  PLATFORM := GC
-  DEBUG_FEATURES ?= 0
-  BUILD_CREATOR := zelda@srd022j
-  BUILD_DATE := 02-12-19
-  BUILD_TIME := 14:05:42
-  REVISION := 15
-else ifeq ($(VERSION),gc-eu-mq-dbg)
-  REGION ?= EU
-  PLATFORM := GC
-  DEBUG_FEATURES ?= 1
-  BUILD_CREATOR := zelda@srd022j
-  BUILD_DATE := 03-02-21
-  BUILD_TIME := 00:16:31
-  REVISION := 15
-else ifeq ($(VERSION),gc-eu)
-  REGION ?= EU
-  PLATFORM := GC
-  DEBUG_FEATURES ?= 0
-  BUILD_CREATOR := zelda@srd022j
-  BUILD_DATE := 03-02-21
-  BUILD_TIME := 20:12:23
-  REVISION := 15
-else ifeq ($(VERSION),gc-eu-mq)
-  REGION ?= EU
-  PLATFORM := GC
-  DEBUG_FEATURES ?= 0
-  BUILD_CREATOR := zelda@srd022j
-  BUILD_DATE := 03-02-21
-  BUILD_TIME := 20:37:19
-  REVISION := 15
-else ifeq ($(VERSION),gc-jp-ce)
-  REGION ?= JP
-  PLATFORM := GC
-  DEBUG_FEATURES ?= 0
-  BUILD_CREATOR := zelda@srd022j
-  BUILD_DATE := 03-10-08
-  BUILD_TIME := 21:53:00
-  REVISION := 15
-else ifeq ($(VERSION),ique-cn)
-  REGION ?= US
-  PLATFORM := IQUE
-  DEBUG_FEATURES ?= 0
-  BUILD_CREATOR := build@toad.routefree.com
-  BUILD_DATE := 03-10-22
-  BUILD_TIME := 16:23:19
-  REVISION := 0
 else
 $(error Unsupported version $(VERSION))
 endif
@@ -197,8 +89,10 @@ endif
 PROJECT_DIR := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))
 BUILD_DIR := build/$(VERSION)
 EXPECTED_DIR := expected/$(BUILD_DIR)
-BASEROM_DIR := baseroms/$(VERSION)
-EXTRACTED_DIR := extracted/$(VERSION)
+# randomizer will be based on pal-1.1
+BASEROM_DIR := baseroms/pal-1.1
+# randomizer will be based on pal-1.1 so can use its extracted assets
+EXTRACTED_DIR := extracted/pal-1.1
 VENV := .venv
 
 MAKE = make
@@ -220,8 +114,8 @@ $(error Unsupported platform $(PLATFORM))
 endif
 
 # Converts e.g. ntsc-1.0 to NTSC_1_0
-VERSION_MACRO := $(shell echo $(VERSION) | tr a-z-. A-Z__)
-CPP_DEFINES += -DOOT_VERSION=$(VERSION_MACRO) -DOOT_REVISION=$(REVISION)
+#VERSION_MACRO := $(shell echo $(VERSION) | tr a-z-. A-Z__)
+CPP_DEFINES += -DOOT_VERSION=PAL_1_1 -DOOT_REVISION=$(REVISION)
 CPP_DEFINES += -DOOT_REGION=REGION_$(REGION)
 CPP_DEFINES += -DLIBULTRA_VERSION=LIBULTRA_VERSION_$(LIBULTRA_VERSION)
 CPP_DEFINES += -DLIBULTRA_PATCH=$(LIBULTRA_PATCH)
@@ -534,7 +428,7 @@ $(shell mkdir -p $(foreach dir, \
                     $(dir:$(EXTRACTED_DIR)/%=$(BUILD_DIR)/%)))
 endif
 
-$(BUILD_DIR)/src/boot/build.o: CPP_DEFINES += -DBUILD_CREATOR="\"$(BUILD_CREATOR)\"" -DBUILD_DATE="\"$(BUILD_DATE)\"" -DBUILD_TIME="\"$(BUILD_TIME)\""
+$(BUILD_DIR)/src/boot/build.o: CPP_DEFINES += -DBUILD_CREATOR="\"$(BUILD_CREATOR)\"" -DBUILD_DATE="\"$(BUILD_DATE)\"" -DBUILD_TIME="\"$(BUILD_TIME)\"" -DBUILD_VERSION="\"$(BUILD_VERSION)\""
 
 $(BUILD_DIR)/src/audio/internal/seqplayer.o: CPP_DEFINES += -DMML_VERSION=MML_VERSION_OOT
 
@@ -734,7 +628,7 @@ endif
 
 ifeq ($(PERMUTER),)  # permuter + preprocess.py misbehaves, permuter doesn't care about rodata diffs or bss ordering so just don't use it in that case
 # Handle encoding (UTF-8 -> EUC-JP) and custom pragmas
-$(BUILD_DIR)/src/%.o: PREPROCESS := ./tools/preprocess.sh -v $(VERSION) -i $(ICONV) --
+$(BUILD_DIR)/src/%.o: PREPROCESS := ./tools/preprocess.sh -v pal-1.1 -i $(ICONV) --
 endif
 
 else
@@ -745,6 +639,8 @@ $(BUILD_DIR)/src/libultra/libc/ll.o: OPTFLAGS := -Ofast
 $(BUILD_DIR)/src/overlays/%.o: CFLAGS += -fno-merge-constants -mno-explicit-relocs -mno-split-addresses
 endif
 
+-include .make_wii-vc.mk
+
 #### Main Targets ###
 
 all: rom compress
@@ -789,12 +685,12 @@ venv:
 
 setup: venv
 	$(MAKE) -C tools
-	$(PYTHON) tools/decompress_baserom.py $(VERSION)
-	$(PYTHON) tools/extract_baserom.py $(BASEROM_DIR)/baserom-decompressed.z64 $(EXTRACTED_DIR)/baserom -v $(VERSION)
-	$(PYTHON) -m tools.assets.extract $(EXTRACTED_DIR)/baserom $(EXTRACTED_DIR) -v $(VERSION) -j$(N_THREADS)
-	$(PYTHON) tools/extract_incbins.py $(EXTRACTED_DIR)/baserom $(EXTRACTED_DIR)/incbin -v $(VERSION)
-	$(PYTHON) tools/extract_text.py $(EXTRACTED_DIR)/baserom $(EXTRACTED_DIR)/text -v $(VERSION)
-	$(PYTHON) tools/extract_audio.py -b $(EXTRACTED_DIR)/baserom -o $(EXTRACTED_DIR) -v $(VERSION) --read-xml
+	$(PYTHON) tools/decompress_baserom.py pal-1.1
+	$(PYTHON) tools/extract_baserom.py $(BASEROM_DIR)/baserom-decompressed.z64 $(EXTRACTED_DIR)/baserom -v pal-1.1
+	$(PYTHON) -m tools.assets.extract $(EXTRACTED_DIR)/baserom $(EXTRACTED_DIR) -v pal-1.1 -j$(N_THREADS)
+	$(PYTHON) tools/extract_incbins.py $(EXTRACTED_DIR)/baserom $(EXTRACTED_DIR)/incbin -v pal-1.1
+	$(PYTHON) tools/extract_text.py $(EXTRACTED_DIR)/baserom $(EXTRACTED_DIR)/text -v pal-1.1
+	$(PYTHON) tools/extract_audio.py -b $(EXTRACTED_DIR)/baserom -o $(EXTRACTED_DIR) -v pal-1.1 --read-xml
 
 disasm:
 	$(RM) -r $(EXPECTED_DIR)
diff --git a/assets/overlays/ovl_file_choose/gOptionsMenuHeadersVtx.inc b/assets/overlays/ovl_file_choose/gOptionsMenuHeadersVtx.inc
new file mode 100644
index 000000000..fec32315a
--- /dev/null
+++ b/assets/overlays/ovl_file_choose/gOptionsMenuHeadersVtx.inc
@@ -0,0 +1,30 @@
+    VTX(   -94,     72,      0,     0x0,     0x0, 0xFF, 0xFF, 0xFF, 0xFF), // 0
+    VTX(    34,     72,      0,  0x1000,     0x0, 0xFF, 0xFF, 0xFF, 0xFF), // 1
+    VTX(   -94,     56,      0,     0x0,   0x200, 0xFF, 0xFF, 0xFF, 0xFF), // 2
+    VTX(    34,     56,      0,  0x1000,   0x200, 0xFF, 0xFF, 0xFF, 0xFF), // 3
+
+    VTX(  -100,     46,      0,     0x0,     0x0, 0xFF, 0xFF, 0xFF, 0xFF), // 4
+    VTX(   -36,     46,      0,   0x800,     0x0, 0xFF, 0xFF, 0xFF, 0xFF), // 5
+    VTX(  -100,     30,      0,     0x0,   0x200, 0xFF, 0xFF, 0xFF, 0xFF), // 6
+    VTX(   -36,     30,      0,   0x800,   0x200, 0xFF, 0xFF, 0xFF, 0xFF), // 7
+
+    VTX(  -100,     17,      0,     0x0,     0x0, 0xFF, 0xFF, 0xFF, 0xFF), // 8
+    VTX(   -36,     17,      0,   0x800,     0x0, 0xFF, 0xFF, 0xFF, 0xFF), // 9
+    VTX(  -100,      1,      0,     0x0,   0x200, 0xFF, 0xFF, 0xFF, 0xFF), // 10
+    VTX(   -36,      1,      0,   0x800,   0x200, 0xFF, 0xFF, 0xFF, 0xFF), // 11
+
+    VTX(  -100,    -41,      0,     0x0,     0x0, 0xFF, 0xFF, 0xFF, 0xFF), // 12
+    VTX(    28,    -41,      0,  0x1000,     0x0, 0xFF, 0xFF, 0xFF, 0xFF), // 13
+    VTX(  -100,    -57,      0,     0x0,   0x200, 0xFF, 0xFF, 0xFF, 0xFF), // 14
+    VTX(    28,    -57,      0,  0x1000,   0x200, 0xFF, 0xFF, 0xFF, 0xFF), // 15
+// quicktext
+    VTX(  -100,    -12,      0,     0x0,     0x0, 0xFF, 0xFF, 0xFF, 0xFF), // 16
+    VTX(   -36,    -12,      0,   0x800,     0x0, 0xFF, 0xFF, 0xFF, 0xFF), // 17
+    VTX(  -100,    -28,      0,     0x0,   0x200, 0xFF, 0xFF, 0xFF, 0xFF), // 18
+    VTX(   -36,    -28,      0,   0x800,   0x200, 0xFF, 0xFF, 0xFF, 0xFF), // 19
+//
+    VTX(  -100,     17,      0,     0x0,     0x0, 0xFF, 0xFF, 0xFF, 0xFF), // 20
+    VTX(    44,     17,      0,  0x1200,     0x0, 0xFF, 0xFF, 0xFF, 0xFF), // 21
+    VTX(  -100,      1,      0,     0x0,   0x200, 0xFF, 0xFF, 0xFF, 0xFF), // 22
+    VTX(    44,      1,      0,  0x1200,   0x200, 0xFF, 0xFF, 0xFF, 0xFF), // 23
+
diff --git a/assets/overlays/ovl_file_choose/gOptionsMenuSettingsVtx.inc b/assets/overlays/ovl_file_choose/gOptionsMenuSettingsVtx.inc
new file mode 100644
index 000000000..b1322cca5
--- /dev/null
+++ b/assets/overlays/ovl_file_choose/gOptionsMenuSettingsVtx.inc
@@ -0,0 +1,41 @@
+//sound
+    VTX(  -100,     32,      0,     0x0,     0x0, 0xFF, 0xFF, 0xFF, 0xFF), // 0
+    VTX(   -52,     32,      0,   0x600,     0x0, 0xFF, 0xFF, 0xFF, 0xFF), // 1
+    VTX(  -100,     16,      0,     0x0,   0x200, 0xFF, 0xFF, 0xFF, 0xFF), // 2
+    VTX(   -52,     16,      0,   0x600,   0x200, 0xFF, 0xFF, 0xFF, 0xFF), // 3
+
+    VTX(   -48,     32,      0,     0x0,     0x0, 0xFF, 0xFF, 0xFF, 0xFF), // 4
+    VTX(     0,     32,      0,   0x600,     0x0, 0xFF, 0xFF, 0xFF, 0xFF), // 5
+    VTX(   -48,     16,      0,     0x0,   0x200, 0xFF, 0xFF, 0xFF, 0xFF), // 6
+    VTX(     0,     16,      0,   0x600,   0x200, 0xFF, 0xFF, 0xFF, 0xFF), // 7
+
+    VTX(     4,     32,      0,     0x0,     0x0, 0xFF, 0xFF, 0xFF, 0xFF), // 8
+    VTX(    52,     32,      0,   0x600,     0x0, 0xFF, 0xFF, 0xFF, 0xFF), // 9
+    VTX(     4,     16,      0,     0x0,   0x200, 0xFF, 0xFF, 0xFF, 0xFF), // 10
+    VTX(    52,     16,      0,   0x600,   0x200, 0xFF, 0xFF, 0xFF, 0xFF), // 11
+
+    VTX(    56,     32,      0,     0x0,     0x0, 0xFF, 0xFF, 0xFF, 0xFF), // 12
+    VTX(   104,     32,      0,   0x600,     0x0, 0xFF, 0xFF, 0xFF, 0xFF), // 13
+    VTX(    56,     16,      0,     0x0,   0x200, 0xFF, 0xFF, 0xFF, 0xFF), // 14
+    VTX(   104,     16,      0,   0x600,   0x200, 0xFF, 0xFF, 0xFF, 0xFF), // 15
+//switch
+    VTX(  -100,      3,      0,     0x0,     0x0, 0xFF, 0xFF, 0xFF, 0xFF), // 16
+    VTX(   -52,      3,      0,   0x600,     0x0, 0xFF, 0xFF, 0xFF, 0xFF), // 17
+    VTX(  -100,    -13,      0,     0x0,   0x200, 0xFF, 0xFF, 0xFF, 0xFF), // 18
+    VTX(   -52,    -13,      0,   0x600,   0x200, 0xFF, 0xFF, 0xFF, 0xFF), // 19
+//hold
+    VTX(   -16,      3,      0,     0x0,     0x0, 0xFF, 0xFF, 0xFF, 0xFF), // 20
+    VTX(    32,      3,      0,   0x600,     0x0, 0xFF, 0xFF, 0xFF, 0xFF), // 21
+    VTX(   -16,    -13,      0,     0x0,   0x200, 0xFF, 0xFF, 0xFF, 0xFF), // 22
+    VTX(    32,    -13,      0,   0x600,   0x200, 0xFF, 0xFF, 0xFF, 0xFF), // 23
+//off
+    VTX(   -92,    -26,      0,     0x0,     0x0, 0xFF, 0xFF, 0xFF, 0xFF),
+    VTX(   -60,    -26,      0,   0x400,     0x0, 0xFF, 0xFF, 0xFF, 0xFF),
+    VTX(   -92,    -42,      0,     0x0,   0x200, 0xFF, 0xFF, 0xFF, 0xFF),
+    VTX(   -60,    -42,      0,   0x400,   0x200, 0xFF, 0xFF, 0xFF, 0xFF),
+//on
+    VTX(   -16,    -26,      0,     0x0,     0x0, 0xFF, 0xFF, 0xFF, 0xFF),
+    VTX(     8,    -26,      0,   0x300,     0x0, 0xFF, 0xFF, 0xFF, 0xFF),
+    VTX(   -16,    -42,      0,     0x0,   0x200, 0xFF, 0xFF, 0xFF, 0xFF),
+    VTX(     8,    -42,      0,   0x300,   0x200, 0xFF, 0xFF, 0xFF, 0xFF),
+
diff --git a/assets/overlays/ovl_file_choose/gRandoMenuHeadersVtx.vtx.inc b/assets/overlays/ovl_file_choose/gRandoMenuHeadersVtx.vtx.inc
new file mode 100644
index 000000000..f5e46963b
--- /dev/null
+++ b/assets/overlays/ovl_file_choose/gRandoMenuHeadersVtx.vtx.inc
@@ -0,0 +1,15 @@
+//settings
+        VTX(-94, 72, 0, 0, 0, 255, 255, 255, 255),
+        VTX(-30, 72, 0, 2048, 0, 255, 255, 255, 255),
+        VTX(-94, 56, 0, 0, 512, 255, 255, 255, 255),
+        VTX(-30, 56, 0, 2048, 512, 255, 255, 255, 255),
+//shuffle
+        VTX(-100, 46, 0, 0, 0, 255, 255, 255, 255),
+        VTX(-36, 46, 0, 3072, 0, 255, 255, 255, 255),
+        VTX(-100, 30, 0, 0, 768, 255, 255, 255, 255),
+        VTX(-36, 30, 0, 3072, 768, 255, 255, 255, 255),
+//divider line
+        VTX(-100, 34, 0, 0, 0, 255, 255, 255, 255),
+        VTX(156, 34, 0, 8192, 0, 255, 255, 255, 255),
+        VTX(-100, 32, 0, 0, 64, 255, 255, 255, 255),
+        VTX(156, 32, 0, 8192, 64, 255, 255, 255, 255),
\ No newline at end of file
diff --git a/assets/overlays/ovl_file_choose/gRandoMenuSettingsVtx.vtx.inc b/assets/overlays/ovl_file_choose/gRandoMenuSettingsVtx.vtx.inc
new file mode 100644
index 000000000..d156fcbc0
--- /dev/null
+++ b/assets/overlays/ovl_file_choose/gRandoMenuSettingsVtx.vtx.inc
@@ -0,0 +1,15 @@
+// chests
+        VTX(-100, 30, 0, 0, 0, 255, 255, 255, 255),
+        VTX(-36, 30, 0, 2048, 0, 255, 255, 255, 255),
+        VTX(-100, 14, 0, 0, 512, 255, 255, 255, 255),
+        VTX(-36, 14, 0, 2048, 512, 255, 255, 255, 255),
+// no
+        VTX(45, 30, 0, 0, 0, 255, 255, 255, 255),
+        VTX(129, 30, 0, 2816, 0, 255, 255, 255, 255),
+        VTX(45, 14, 0, 0, 512, 255, 255, 255, 255),
+        VTX(129, 14, 0, 2816, 512, 255, 255, 255, 255),
+// yes
+        VTX(75, 30, 0, 0, 0, 255, 255, 255, 255),
+        VTX(139, 30, 0, 2048, 0, 255, 255, 255, 255),
+        VTX(75, 14, 0, 0, 512, 255, 255, 255, 255),
+        VTX(139, 14, 0, 2048, 512, 255, 255, 255, 255),
\ No newline at end of file
diff --git a/assets/overlays/ovl_file_choose/ovl_file_choose.c b/assets/overlays/ovl_file_choose/ovl_file_choose.c
new file mode 100644
index 000000000..d33df4121
--- /dev/null
+++ b/assets/overlays/ovl_file_choose/ovl_file_choose.c
@@ -0,0 +1,77 @@
+#include "ultra64.h"
+#include "ovl_file_choose.h"
+#include "gfx.h"
+#include "assets/misc/link_animetion/link_animetion.h"
+#include "assets/objects/gameplay_keep/gameplay_keep.h"
+
+Vtx gNameEntryVtx[] = {
+#include "assets/overlays/ovl_file_choose/gNameEntryVtx.inc.c"
+};
+
+Vtx gOptionsMenuHeadersVtx[] = {
+#include "assets/overlays/ovl_file_choose/gOptionsMenuHeadersVtx.inc"
+};
+
+Vtx gOptionsMenuSettingsVtx[] = {
+#include "assets/overlays/ovl_file_choose/gOptionsMenuSettingsVtx.inc"
+};
+
+Vtx gOptionsMenuBrightnessVtx[] = {
+#include "assets/overlays/ovl_file_choose/gOptionsMenuBrightnessVtx.inc.c"
+};
+
+Vtx gOptionsMenuLanguageVtx[] = {
+#include "assets/overlays/ovl_file_choose/gOptionsMenuLanguageVtx.inc.c"
+};
+
+static u8 ovl_file_choose_unaccounted_000640[320] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+};
+
+Vtx gOptionsDividerSoundVtx[] = {
+#include "assets/overlays/ovl_file_choose/gOptionsDividerSoundVtx.inc.c"
+};
+
+Vtx gOptionsDividerZTargetVtx[] = {
+#include "assets/overlays/ovl_file_choose/gOptionsDividerZTargetVtx.inc.c"
+};
+
+Vtx gOptionsDividerBrightnessVtx[] = {
+#include "assets/overlays/ovl_file_choose/gOptionsDividerBrightnessVtx.inc.c"
+};
+
+Vtx gOptionsDividerLanguageVtx[] = {
+#include "assets/overlays/ovl_file_choose/gOptionsDividerLanguageVtx.inc.c"
+};
+
+s16 gCharPageEng[] = {
+#include "assets/overlays/ovl_file_choose/gCharPageEng.inc.c"
+};
+
+Vtx gRandoMenuHeadersVtx[] = {
+#include "assets//overlays/ovl_file_choose/gRandoMenuHeadersVtx.vtx.inc"
+};
+
+Vtx gRandoMenuSettingsVtx[] = {
+#include "assets/overlays/ovl_file_choose/gRandoMenuSettingsVtx.vtx.inc"
+};
+
diff --git a/assets/overlays/ovl_file_choose/ovl_file_choose.h b/assets/overlays/ovl_file_choose/ovl_file_choose.h
new file mode 100644
index 000000000..fd1e92b42
--- /dev/null
+++ b/assets/overlays/ovl_file_choose/ovl_file_choose.h
@@ -0,0 +1,18 @@
+#ifndef OVL_FILE_CHOOSE_H
+#define OVL_FILE_CHOOSE_H 1
+
+extern Vtx gNameEntryVtx[];
+extern Vtx gOptionsMenuHeadersVtx[];
+extern Vtx gOptionsMenuSettingsVtx[];
+extern Vtx gOptionsMenuBrightnessVtx[];
+extern Vtx gOptionsMenuLanguageVtx[];
+extern Vtx gOptionsDividerSoundVtx[];
+extern Vtx gOptionsDividerZTargetVtx[];
+extern Vtx gOptionsDividerBrightnessVtx[];
+extern Vtx gOptionsDividerLanguageVtx[];
+extern s16 gCharPageEng[];
+// Start rando
+extern Vtx gRandoMenuHeadersVtx[];
+extern Vtx gRandoMenuSettingsVtx[];
+// End rando
+#endif
diff --git a/assets/textures/do_action_static/do_action_static.c b/assets/textures/do_action_static/do_action_static.c
new file mode 100644
index 000000000..a0031f48b
--- /dev/null
+++ b/assets/textures/do_action_static/do_action_static.c
@@ -0,0 +1,357 @@
+#include "ultra64.h"
+#include "do_action_static.h"
+#include "assets/misc/link_animetion/link_animetion.h"
+#include "assets/objects/gameplay_keep/gameplay_keep.h"
+
+u64 gAttackDoActionENGTex[] = {
+#include "assets/textures/do_action_static/gAttackDoActionENGTex.ia4.inc.c"
+};
+
+u64 gCheckDoActionENGTex[] = {
+#include "assets/textures/do_action_static/gCheckDoActionENGTex.ia4.inc.c"
+};
+
+u64 gEnterDoActionENGTex[] = {
+#include "assets/textures/do_action_static/gEnterDoActionENGTex.ia4.inc.c"
+};
+
+u64 gReturnDoActionENGTex[] = {
+#include "assets/textures/do_action_static/gReturnDoActionENGTex.ia4.inc.c"
+};
+
+u64 gOpenDoActionENGTex[] = {
+#include "assets/textures/do_action_static/gOpenDoActionENGTex.ia4.inc.c"
+};
+
+u64 gJumpDoActionENGTex[] = {
+#include "assets/textures/do_action_static/gJumpDoActionENGTex.ia4.inc.c"
+};
+
+u64 gDecideDoActionENGTex[] = {
+#include "assets/textures/do_action_static/gDecideDoActionENGTex.ia4.inc.c"
+};
+
+u64 gDiveDoActionENGTex[] = {
+#include "assets/textures/do_action_static/gDiveDoActionENGTex.ia4.inc.c"
+};
+
+u64 gFasterDoActionENGTex[] = {
+#include "assets/textures/do_action_static/gFasterDoActionENGTex.ia4.inc.c"
+};
+
+u64 gThrowDoActionENGTex[] = {
+#include "assets/textures/do_action_static/gThrowDoActionENGTex.ia4.inc.c"
+};
+
+u64 gUnusedNaviDoActionENGTex[] = {
+#include "assets/textures/do_action_static/gUnusedNaviDoActionENGTex.ia4.inc.c"
+};
+
+u64 gClimbDoActionENGTex[] = {
+#include "assets/textures/do_action_static/gClimbDoActionENGTex.ia4.inc.c"
+};
+
+u64 gDropDoActionENGTex[] = {
+#include "assets/textures/do_action_static/gDropDoActionENGTex.ia4.inc.c"
+};
+
+u64 gDownDoActionENGTex[] = {
+#include "assets/textures/do_action_static/gDownDoActionENGTex.ia4.inc.c"
+};
+
+u64 gSaveDoActionENGTex[] = {
+#include "assets/textures/do_action_static/gSaveDoActionENGTex.ia4.inc.c"
+};
+
+u64 gSpeakDoActionENGTex[] = {
+#include "assets/textures/do_action_static/gSpeakDoActionENGTex.ia4.inc.c"
+};
+
+u64 gNextDoActionENGTex[] = {
+#include "assets/textures/do_action_static/gNextDoActionENGTex.ia4.inc.c"
+};
+
+u64 gGrabDoActionENGTex[] = {
+#include "assets/textures/do_action_static/gGrabDoActionENGTex.ia4.inc.c"
+};
+
+u64 gStopDoActionENGTex[] = {
+#include "assets/textures/do_action_static/gStopDoActionENGTex.ia4.inc.c"
+};
+
+u64 gPutAwayDoActionENGTex[] = {
+#include "assets/textures/do_action_static/gPutAwayDoActionENGTex.ia4.inc.c"
+};
+
+u64 gReelDoActionENGTex[] = {
+#include "assets/textures/do_action_static/gReelDoActionENGTex.ia4.inc.c"
+};
+
+u64 gNum1DoActionENGTex[] = {
+#include "assets/textures/do_action_static/gNum1DoActionENGTex.ia4.inc.c"
+};
+
+u64 gNum2DoActionENGTex[] = {
+#include "assets/textures/do_action_static/gNum2DoActionENGTex.ia4.inc.c"
+};
+
+u64 gNum3DoActionENGTex[] = {
+#include "assets/textures/do_action_static/gNum3DoActionENGTex.ia4.inc.c"
+};
+
+u64 gNum4DoActionENGTex[] = {
+#include "assets/textures/do_action_static/gNum4DoActionENGTex.ia4.inc.c"
+};
+
+u64 gNum5DoActionENGTex[] = {
+#include "assets/textures/do_action_static/gNum5DoActionENGTex.ia4.inc.c"
+};
+
+u64 gNum6DoActionENGTex[] = {
+#include "assets/textures/do_action_static/gNum6DoActionENGTex.ia4.inc.c"
+};
+
+u64 gNum7DoActionENGTex[] = {
+#include "assets/textures/do_action_static/gNum7DoActionENGTex.ia4.inc.c"
+};
+
+u64 gNum8DoActionENGTex[] = {
+#include "assets/textures/do_action_static/gNum8DoActionENGTex.ia4.inc.c"
+};
+
+u64 gSkipDoActionENGTex[] = {
+#include "assets/textures/do_action_static/skip_eng.ia4.inc.c"
+};
+
+u64 gAttackDoActionGERTex[] = {
+#include "assets/textures/do_action_static/gAttackDoActionGERTex.ia4.inc.c"
+};
+
+u64 gCheckDoActionGERTex[] = {
+#include "assets/textures/do_action_static/gCheckDoActionGERTex.ia4.inc.c"
+};
+
+u64 gEnterDoActionGERTex[] = {
+#include "assets/textures/do_action_static/gEnterDoActionGERTex.ia4.inc.c"
+};
+
+u64 gReturnDoActionGERTex[] = {
+#include "assets/textures/do_action_static/gReturnDoActionGERTex.ia4.inc.c"
+};
+
+u64 gOpenDoActionGERTex[] = {
+#include "assets/textures/do_action_static/gOpenDoActionGERTex.ia4.inc.c"
+};
+
+u64 gJumpDoActionGERTex[] = {
+#include "assets/textures/do_action_static/gJumpDoActionGERTex.ia4.inc.c"
+};
+
+u64 gDecideDoActionGERTex[] = {
+#include "assets/textures/do_action_static/gDecideDoActionGERTex.ia4.inc.c"
+};
+
+u64 gDiveDoActionGERTex[] = {
+#include "assets/textures/do_action_static/gDiveDoActionGERTex.ia4.inc.c"
+};
+
+u64 gFasterDoActionGERTex[] = {
+#include "assets/textures/do_action_static/gFasterDoActionGERTex.ia4.inc.c"
+};
+
+u64 gThrowDoActionGERTex[] = {
+#include "assets/textures/do_action_static/gThrowDoActionGERTex.ia4.inc.c"
+};
+
+u64 gUnusedNaviDoActionGERTex[] = {
+#include "assets/textures/do_action_static/gUnusedNaviDoActionGERTex.ia4.inc.c"
+};
+
+u64 gClimbDoActionGERTex[] = {
+#include "assets/textures/do_action_static/gClimbDoActionGERTex.ia4.inc.c"
+};
+
+u64 gDropDoActionGERTex[] = {
+#include "assets/textures/do_action_static/gDropDoActionGERTex.ia4.inc.c"
+};
+
+u64 gDownDoActionGERTex[] = {
+#include "assets/textures/do_action_static/gDownDoActionGERTex.ia4.inc.c"
+};
+
+u64 gSaveDoActionGERTex[] = {
+#include "assets/textures/do_action_static/gSaveDoActionGERTex.ia4.inc.c"
+};
+
+u64 gSpeakDoActionGERTex[] = {
+#include "assets/textures/do_action_static/gSpeakDoActionGERTex.ia4.inc.c"
+};
+
+u64 gNextDoActionGERTex[] = {
+#include "assets/textures/do_action_static/gNextDoActionGERTex.ia4.inc.c"
+};
+
+u64 gGrabDoActionGERTex[] = {
+#include "assets/textures/do_action_static/gGrabDoActionGERTex.ia4.inc.c"
+};
+
+u64 gStopDoActionGERTex[] = {
+#include "assets/textures/do_action_static/gStopDoActionGERTex.ia4.inc.c"
+};
+
+u64 gPutAwayDoActionGERTex[] = {
+#include "assets/textures/do_action_static/gPutAwayDoActionGERTex.ia4.inc.c"
+};
+
+u64 gReelDoActionGERTex[] = {
+#include "assets/textures/do_action_static/gReelDoActionGERTex.ia4.inc.c"
+};
+
+u64 gNum1DoActionGERTex[] = {
+#include "assets/textures/do_action_static/gNum1DoActionGERTex.ia4.inc.c"
+};
+
+u64 gNum2DoActionGERTex[] = {
+#include "assets/textures/do_action_static/gNum2DoActionGERTex.ia4.inc.c"
+};
+
+u64 gNum3DoActionGERTex[] = {
+#include "assets/textures/do_action_static/gNum3DoActionGERTex.ia4.inc.c"
+};
+
+u64 gNum4DoActionGERTex[] = {
+#include "assets/textures/do_action_static/gNum4DoActionGERTex.ia4.inc.c"
+};
+
+u64 gNum5DoActionGERTex[] = {
+#include "assets/textures/do_action_static/gNum5DoActionGERTex.ia4.inc.c"
+};
+
+u64 gNum6DoActionGERTex[] = {
+#include "assets/textures/do_action_static/gNum6DoActionGERTex.ia4.inc.c"
+};
+
+u64 gNum7DoActionGERTex[] = {
+#include "assets/textures/do_action_static/gNum7DoActionGERTex.ia4.inc.c"
+};
+
+u64 gNum8DoActionGERTex[] = {
+#include "assets/textures/do_action_static/gNum8DoActionGERTex.ia4.inc.c"
+};
+
+u64 gAttackDoActionFRATex[] = {
+#include "assets/textures/do_action_static/gAttackDoActionFRATex.ia4.inc.c"
+};
+
+u64 gCheckDoActionFRATex[] = {
+#include "assets/textures/do_action_static/gCheckDoActionFRATex.ia4.inc.c"
+};
+
+u64 gEnterDoActionFRATex[] = {
+#include "assets/textures/do_action_static/gEnterDoActionFRATex.ia4.inc.c"
+};
+
+u64 gReturnDoActionFRATex[] = {
+#include "assets/textures/do_action_static/gReturnDoActionFRATex.ia4.inc.c"
+};
+
+u64 gOpenDoActionFRATex[] = {
+#include "assets/textures/do_action_static/gOpenDoActionFRATex.ia4.inc.c"
+};
+
+u64 gJumpDoActionFRATex[] = {
+#include "assets/textures/do_action_static/gJumpDoActionFRATex.ia4.inc.c"
+};
+
+u64 gDecideDoActionFRATex[] = {
+#include "assets/textures/do_action_static/gDecideDoActionFRATex.ia4.inc.c"
+};
+
+u64 gDiveDoActionFRATex[] = {
+#include "assets/textures/do_action_static/gDiveDoActionFRATex.ia4.inc.c"
+};
+
+u64 gFasterDoActionFRATex[] = {
+#include "assets/textures/do_action_static/gFasterDoActionFRATex.ia4.inc.c"
+};
+
+u64 gThrowDoActionFRATex[] = {
+#include "assets/textures/do_action_static/gThrowDoActionFRATex.ia4.inc.c"
+};
+
+u64 gUnusedNaviDoActionFRATex[] = {
+#include "assets/textures/do_action_static/gUnusedNaviDoActionFRATex.ia4.inc.c"
+};
+
+u64 gClimbDoActionFRATex[] = {
+#include "assets/textures/do_action_static/gClimbDoActionFRATex.ia4.inc.c"
+};
+
+u64 gDropDoActionFRATex[] = {
+#include "assets/textures/do_action_static/gDropDoActionFRATex.ia4.inc.c"
+};
+
+u64 gDownDoActionFRATex[] = {
+#include "assets/textures/do_action_static/gDownDoActionFRATex.ia4.inc.c"
+};
+
+u64 gSaveDoActionFRATex[] = {
+#include "assets/textures/do_action_static/gSaveDoActionFRATex.ia4.inc.c"
+};
+
+u64 gSpeakDoActionFRATex[] = {
+#include "assets/textures/do_action_static/gSpeakDoActionFRATex.ia4.inc.c"
+};
+
+u64 gNextDoActionFRATex[] = {
+#include "assets/textures/do_action_static/gNextDoActionFRATex.ia4.inc.c"
+};
+
+u64 gGrabDoActionFRATex[] = {
+#include "assets/textures/do_action_static/gGrabDoActionFRATex.ia4.inc.c"
+};
+
+u64 gStopDoActionFRATex[] = {
+#include "assets/textures/do_action_static/gStopDoActionFRATex.ia4.inc.c"
+};
+
+u64 gPutAwayDoActionFRATex[] = {
+#include "assets/textures/do_action_static/gPutAwayDoActionFRATex.ia4.inc.c"
+};
+
+u64 gReelDoActionFRATex[] = {
+#include "assets/textures/do_action_static/gReelDoActionFRATex.ia4.inc.c"
+};
+
+u64 gNum1DoActionFRATex[] = {
+#include "assets/textures/do_action_static/gNum1DoActionFRATex.ia4.inc.c"
+};
+
+u64 gNum2DoActionFRATex[] = {
+#include "assets/textures/do_action_static/gNum2DoActionFRATex.ia4.inc.c"
+};
+
+u64 gNum3DoActionFRATex[] = {
+#include "assets/textures/do_action_static/gNum3DoActionFRATex.ia4.inc.c"
+};
+
+u64 gNum4DoActionFRATex[] = {
+#include "assets/textures/do_action_static/gNum4DoActionFRATex.ia4.inc.c"
+};
+
+u64 gNum5DoActionFRATex[] = {
+#include "assets/textures/do_action_static/gNum5DoActionFRATex.ia4.inc.c"
+};
+
+u64 gNum6DoActionFRATex[] = {
+#include "assets/textures/do_action_static/gNum6DoActionFRATex.ia4.inc.c"
+};
+
+u64 gNum7DoActionFRATex[] = {
+#include "assets/textures/do_action_static/gNum7DoActionFRATex.ia4.inc.c"
+};
+
+u64 gNum8DoActionFRATex[] = {
+#include "assets/textures/do_action_static/gNum8DoActionFRATex.ia4.inc.c"
+};
+
diff --git a/assets/textures/do_action_static/do_action_static.h b/assets/textures/do_action_static/do_action_static.h
new file mode 100644
index 000000000..7bbf4f576
--- /dev/null
+++ b/assets/textures/do_action_static/do_action_static.h
@@ -0,0 +1,92 @@
+#ifndef DO_ACTION_STATIC_H
+#define DO_ACTION_STATIC_H 1
+
+extern u64 gAttackDoActionENGTex[];
+extern u64 gCheckDoActionENGTex[];
+extern u64 gEnterDoActionENGTex[];
+extern u64 gReturnDoActionENGTex[];
+extern u64 gOpenDoActionENGTex[];
+extern u64 gJumpDoActionENGTex[];
+extern u64 gDecideDoActionENGTex[];
+extern u64 gDiveDoActionENGTex[];
+extern u64 gFasterDoActionENGTex[];
+extern u64 gThrowDoActionENGTex[];
+extern u64 gUnusedNaviDoActionENGTex[];
+extern u64 gClimbDoActionENGTex[];
+extern u64 gDropDoActionENGTex[];
+extern u64 gDownDoActionENGTex[];
+extern u64 gSaveDoActionENGTex[];
+extern u64 gSpeakDoActionENGTex[];
+extern u64 gNextDoActionENGTex[];
+extern u64 gGrabDoActionENGTex[];
+extern u64 gStopDoActionENGTex[];
+extern u64 gPutAwayDoActionENGTex[];
+extern u64 gReelDoActionENGTex[];
+extern u64 gNum1DoActionENGTex[];
+extern u64 gNum2DoActionENGTex[];
+extern u64 gNum3DoActionENGTex[];
+extern u64 gNum4DoActionENGTex[];
+extern u64 gNum5DoActionENGTex[];
+extern u64 gNum6DoActionENGTex[];
+extern u64 gNum7DoActionENGTex[];
+extern u64 gNum8DoActionENGTex[];
+extern u64 gSkipDoActionENGTex[];
+extern u64 gAttackDoActionGERTex[];
+extern u64 gCheckDoActionGERTex[];
+extern u64 gEnterDoActionGERTex[];
+extern u64 gReturnDoActionGERTex[];
+extern u64 gOpenDoActionGERTex[];
+extern u64 gJumpDoActionGERTex[];
+extern u64 gDecideDoActionGERTex[];
+extern u64 gDiveDoActionGERTex[];
+extern u64 gFasterDoActionGERTex[];
+extern u64 gThrowDoActionGERTex[];
+extern u64 gUnusedNaviDoActionGERTex[];
+extern u64 gClimbDoActionGERTex[];
+extern u64 gDropDoActionGERTex[];
+extern u64 gDownDoActionGERTex[];
+extern u64 gSaveDoActionGERTex[];
+extern u64 gSpeakDoActionGERTex[];
+extern u64 gNextDoActionGERTex[];
+extern u64 gGrabDoActionGERTex[];
+extern u64 gStopDoActionGERTex[];
+extern u64 gPutAwayDoActionGERTex[];
+extern u64 gReelDoActionGERTex[];
+extern u64 gNum1DoActionGERTex[];
+extern u64 gNum2DoActionGERTex[];
+extern u64 gNum3DoActionGERTex[];
+extern u64 gNum4DoActionGERTex[];
+extern u64 gNum5DoActionGERTex[];
+extern u64 gNum6DoActionGERTex[];
+extern u64 gNum7DoActionGERTex[];
+extern u64 gNum8DoActionGERTex[];
+extern u64 gAttackDoActionFRATex[];
+extern u64 gCheckDoActionFRATex[];
+extern u64 gEnterDoActionFRATex[];
+extern u64 gReturnDoActionFRATex[];
+extern u64 gOpenDoActionFRATex[];
+extern u64 gJumpDoActionFRATex[];
+extern u64 gDecideDoActionFRATex[];
+extern u64 gDiveDoActionFRATex[];
+extern u64 gFasterDoActionFRATex[];
+extern u64 gThrowDoActionFRATex[];
+extern u64 gUnusedNaviDoActionFRATex[];
+extern u64 gClimbDoActionFRATex[];
+extern u64 gDropDoActionFRATex[];
+extern u64 gDownDoActionFRATex[];
+extern u64 gSaveDoActionFRATex[];
+extern u64 gSpeakDoActionFRATex[];
+extern u64 gNextDoActionFRATex[];
+extern u64 gGrabDoActionFRATex[];
+extern u64 gStopDoActionFRATex[];
+extern u64 gPutAwayDoActionFRATex[];
+extern u64 gReelDoActionFRATex[];
+extern u64 gNum1DoActionFRATex[];
+extern u64 gNum2DoActionFRATex[];
+extern u64 gNum3DoActionFRATex[];
+extern u64 gNum4DoActionFRATex[];
+extern u64 gNum5DoActionFRATex[];
+extern u64 gNum6DoActionFRATex[];
+extern u64 gNum7DoActionFRATex[];
+extern u64 gNum8DoActionFRATex[];
+#endif
diff --git a/assets/textures/do_action_static/skip_eng.ia4.png b/assets/textures/do_action_static/skip_eng.ia4.png
new file mode 100644
index 000000000..1347e0950
Binary files /dev/null and b/assets/textures/do_action_static/skip_eng.ia4.png differ
diff --git a/assets/textures/title_static/chests_eng.ia8.png b/assets/textures/title_static/chests_eng.ia8.png
new file mode 100644
index 000000000..98f7ab77b
Binary files /dev/null and b/assets/textures/title_static/chests_eng.ia8.png differ
diff --git a/assets/textures/title_static/controls_rando_eng.ia8.png b/assets/textures/title_static/controls_rando_eng.ia8.png
new file mode 100644
index 000000000..6e9e1c3cb
Binary files /dev/null and b/assets/textures/title_static/controls_rando_eng.ia8.png differ
diff --git a/assets/textures/title_static/no_eng.ia8.png b/assets/textures/title_static/no_eng.ia8.png
new file mode 100644
index 000000000..7cb8b8214
Binary files /dev/null and b/assets/textures/title_static/no_eng.ia8.png differ
diff --git a/assets/textures/title_static/off_eng.ia8.png b/assets/textures/title_static/off_eng.ia8.png
new file mode 100644
index 000000000..7a711c62b
Binary files /dev/null and b/assets/textures/title_static/off_eng.ia8.png differ
diff --git a/assets/textures/title_static/on_eng.ia8.png b/assets/textures/title_static/on_eng.ia8.png
new file mode 100644
index 000000000..953838d33
Binary files /dev/null and b/assets/textures/title_static/on_eng.ia8.png differ
diff --git a/assets/textures/title_static/quicktext_eng.ia8.png b/assets/textures/title_static/quicktext_eng.ia8.png
new file mode 100644
index 000000000..8eb145a6f
Binary files /dev/null and b/assets/textures/title_static/quicktext_eng.ia8.png differ
diff --git a/assets/textures/title_static/settings_eng.ia8.png b/assets/textures/title_static/settings_eng.ia8.png
new file mode 100644
index 000000000..196f221b6
Binary files /dev/null and b/assets/textures/title_static/settings_eng.ia8.png differ
diff --git a/assets/textures/title_static/shuffle_eng.ia8.png b/assets/textures/title_static/shuffle_eng.ia8.png
new file mode 100644
index 000000000..30bfa2aa1
Binary files /dev/null and b/assets/textures/title_static/shuffle_eng.ia8.png differ
diff --git a/assets/textures/title_static/title_static.c b/assets/textures/title_static/title_static.c
new file mode 100644
index 000000000..213731797
--- /dev/null
+++ b/assets/textures/title_static/title_static.c
@@ -0,0 +1,679 @@
+#include "ultra64.h"
+#include "title_static.h"
+#include "assets/misc/link_animetion/link_animetion.h"
+#include "assets/objects/gameplay_keep/gameplay_keep.h"
+
+u64 gFileSelConnectorTex[] = {
+#include "assets/textures/title_static/gFileSelConnectorTex.ia8.inc.c"
+};
+
+u64 gFileSelForestMedallionTex[] = {
+#include "assets/textures/title_static/gFileSelForestMedallionTex.ia8.inc.c"
+};
+
+u64 gFileSelFireMedallionTex[] = {
+#include "assets/textures/title_static/gFileSelFireMedallionTex.ia8.inc.c"
+};
+
+u64 gFileSelWaterMedallionTex[] = {
+#include "assets/textures/title_static/gFileSelWaterMedallionTex.ia8.inc.c"
+};
+
+u64 gFileSelSpiritMedallionTex[] = {
+#include "assets/textures/title_static/gFileSelSpiritMedallionTex.ia8.inc.c"
+};
+
+u64 gFileSelShadowMedallionTex[] = {
+#include "assets/textures/title_static/gFileSelShadowMedallionTex.ia8.inc.c"
+};
+
+u64 gFileSelLightMedallionTex[] = {
+#include "assets/textures/title_static/gFileSelLightMedallionTex.ia8.inc.c"
+};
+
+u64 gFileSelSurroundENGTex[] = {
+#include "assets/textures/title_static/gFileSelSurroundENGTex.ia8.inc.c"
+};
+
+u64 gFileSelHeadsetENGTex[] = {
+#include "assets/textures/title_static/gFileSelHeadsetENGTex.ia8.inc.c"
+};
+
+u64 gFileSelHeadsetGERTex[] = {
+#include "assets/textures/title_static/gFileSelHeadsetGERTex.ia8.inc.c"
+};
+
+u64 gFileSelHeadsetFRATex[] = {
+#include "assets/textures/title_static/gFileSelHeadsetFRATex.ia8.inc.c"
+};
+
+u64 gFileSelMonoENGTex[] = {
+#include "assets/textures/title_static/gFileSelMonoENGTex.ia8.inc.c"
+};
+
+u64 gFileSelSOUNDENGTex[] = {
+#include "assets/textures/title_static/gFileSelSOUNDENGTex.ia8.inc.c"
+};
+
+u64 gFileSelSOUNDFRATex[] = {
+#include "assets/textures/title_static/gFileSelSOUNDFRATex.ia8.inc.c"
+};
+
+u64 gFileSelStereoENGTex[] = {
+#include "assets/textures/title_static/gFileSelStereoENGTex.ia8.inc.c"
+};
+
+u64 gFileSelStereoFRATex[] = {
+#include "assets/textures/title_static/gFileSelStereoFRATex.ia8.inc.c"
+};
+
+u64 gFileSelZTargetingENGTex[] = {
+#include "assets/textures/title_static/gFileSelZTargetingENGTex.ia8.inc.c"
+};
+
+u64 gFileSelZTargetingGERTex[] = {
+#include "assets/textures/title_static/gFileSelZTargetingGERTex.ia8.inc.c"
+};
+
+u64 gFileSelZTargetingFRATex[] = {
+#include "assets/textures/title_static/gFileSelZTargetingFRATex.ia8.inc.c"
+};
+
+u64 gFileSelSwitchENGTex[] = {
+#include "assets/textures/title_static/gFileSelSwitchENGTex.ia8.inc.c"
+};
+
+u64 gFileSelSwitchGERTex[] = {
+#include "assets/textures/title_static/gFileSelSwitchGERTex.ia8.inc.c"
+};
+
+u64 gFileSelSwitchFRATex[] = {
+#include "assets/textures/title_static/gFileSelSwitchFRATex.ia8.inc.c"
+};
+
+u64 gFileSelHoldENGTex[] = {
+#include "assets/textures/title_static/gFileSelHoldENGTex.ia8.inc.c"
+};
+
+u64 gFileSelHoldGERTex[] = {
+#include "assets/textures/title_static/gFileSelHoldGERTex.ia8.inc.c"
+};
+
+u64 gFileSelHoldFRATex[] = {
+#include "assets/textures/title_static/gFileSelHoldFRATex.ia8.inc.c"
+};
+
+u64 gFileSelCheckBrightnessENGTex[] = {
+#include "assets/textures/title_static/gFileSelCheckBrightnessENGTex.ia8.inc.c"
+};
+
+u64 gFileSelCheckBrightnessGERTex[] = {
+#include "assets/textures/title_static/gFileSelCheckBrightnessGERTex.ia8.inc.c"
+};
+
+u64 gFileSelCheckBrightnessFRATex[] = {
+#include "assets/textures/title_static/gFileSelCheckBrightnessFRATex.ia8.inc.c"
+};
+
+u64 gFileSelLanguageChoiceENGTex[] = {
+#include "assets/textures/title_static/gFileSelLanguageChoiceENGTex.ia8.inc.c"
+};
+
+u64 gFileSelLanguageChoiceGERTex[] = {
+#include "assets/textures/title_static/gFileSelLanguageChoiceGERTex.ia8.inc.c"
+};
+
+u64 gFileSelLanguageChoiceFRATex[] = {
+#include "assets/textures/title_static/gFileSelLanguageChoiceFRATex.ia8.inc.c"
+};
+
+u64 gFileSelLanguageENGTex[] = {
+#include "assets/textures/title_static/gFileSelLanguageENGTex.ia8.inc.c"
+};
+
+u64 gFileSelLanguageGERTex[] = {
+#include "assets/textures/title_static/gFileSelLanguageGERTex.ia8.inc.c"
+};
+
+u64 gFileSelLanguageFRATex[] = {
+#include "assets/textures/title_static/gFileSelLanguageFRATex.ia8.inc.c"
+};
+
+u64 gFileSelWindow1Tex[] = {
+#include "assets/textures/title_static/gFileSelWindow1Tex.ia16.inc.c"
+};
+
+u64 gFileSelWindow2Tex[] = {
+#include "assets/textures/title_static/gFileSelWindow2Tex.ia16.inc.c"
+};
+
+u64 gFileSelWindow3Tex[] = {
+#include "assets/textures/title_static/gFileSelWindow3Tex.ia16.inc.c"
+};
+
+u64 gFileSelWindow4Tex[] = {
+#include "assets/textures/title_static/gFileSelWindow4Tex.ia16.inc.c"
+};
+
+u64 gFileSelWindow5Tex[] = {
+#include "assets/textures/title_static/gFileSelWindow5Tex.ia16.inc.c"
+};
+
+u64 gFileSelWindow6Tex[] = {
+#include "assets/textures/title_static/gFileSelWindow6Tex.ia16.inc.c"
+};
+
+u64 gFileSelWindow7Tex[] = {
+#include "assets/textures/title_static/gFileSelWindow7Tex.ia16.inc.c"
+};
+
+u64 gFileSelWindow8Tex[] = {
+#include "assets/textures/title_static/gFileSelWindow8Tex.ia16.inc.c"
+};
+
+u64 gFileSelWindow9Tex[] = {
+#include "assets/textures/title_static/gFileSelWindow9Tex.ia16.inc.c"
+};
+
+u64 gFileSelWindow10Tex[] = {
+#include "assets/textures/title_static/gFileSelWindow10Tex.ia16.inc.c"
+};
+
+u64 gFileSelWindow11Tex[] = {
+#include "assets/textures/title_static/gFileSelWindow11Tex.ia16.inc.c"
+};
+
+u64 gFileSelWindow12Tex[] = {
+#include "assets/textures/title_static/gFileSelWindow12Tex.ia16.inc.c"
+};
+
+u64 gFileSelWindow13Tex[] = {
+#include "assets/textures/title_static/gFileSelWindow13Tex.ia16.inc.c"
+};
+
+u64 gFileSelWindow14Tex[] = {
+#include "assets/textures/title_static/gFileSelWindow14Tex.ia16.inc.c"
+};
+
+u64 gFileSelWindow15Tex[] = {
+#include "assets/textures/title_static/gFileSelWindow15Tex.ia16.inc.c"
+};
+
+u64 gFileSelWindow16Tex[] = {
+#include "assets/textures/title_static/gFileSelWindow16Tex.ia16.inc.c"
+};
+
+u64 gFileSelWindow17Tex[] = {
+#include "assets/textures/title_static/gFileSelWindow17Tex.ia16.inc.c"
+};
+
+u64 gFileSelWindow18Tex[] = {
+#include "assets/textures/title_static/gFileSelWindow18Tex.ia16.inc.c"
+};
+
+u64 gFileSelWindow19Tex[] = {
+#include "assets/textures/title_static/gFileSelWindow19Tex.ia16.inc.c"
+};
+
+u64 gFileSelWindow20Tex[] = {
+#include "assets/textures/title_static/gFileSelWindow20Tex.ia16.inc.c"
+};
+
+u64 gFileSelKanjiButtonTex[] = {
+#include "assets/textures/title_static/gFileSelKanjiButtonTex.ia16.inc.c"
+};
+
+u64 gFileSelHiraganaButtonTex[] = {
+#include "assets/textures/title_static/gFileSelHiraganaButtonTex.ia16.inc.c"
+};
+
+u64 gFileSelKatakanaButtonTex[] = {
+#include "assets/textures/title_static/gFileSelKatakanaButtonTex.ia16.inc.c"
+};
+
+u64 gFileSelENDButtonENGTex[] = {
+#include "assets/textures/title_static/gFileSelENDButtonENGTex.ia16.inc.c"
+};
+
+u64 gFileSelENDButtonGERTex[] = {
+#include "assets/textures/title_static/gFileSelENDButtonGERTex.ia16.inc.c"
+};
+
+u64 gFileSelENDButtonFRATex[] = {
+#include "assets/textures/title_static/gFileSelENDButtonFRATex.ia16.inc.c"
+};
+
+u64 gFileSelBackspaceButtonTex[] = {
+#include "assets/textures/title_static/gFileSelBackspaceButtonTex.ia16.inc.c"
+};
+
+u64 gFileSelNameBoxTex[] = {
+#include "assets/textures/title_static/gFileSelNameBoxTex.ia16.inc.c"
+};
+
+u64 gFileSelFileInfoBox1Tex[] = {
+#include "assets/textures/title_static/gFileSelFileInfoBox1Tex.ia16.inc.c"
+};
+
+u64 gFileSelFileInfoBox2Tex[] = {
+#include "assets/textures/title_static/gFileSelFileInfoBox2Tex.ia16.inc.c"
+};
+
+u64 gFileSelFileInfoBox3Tex[] = {
+#include "assets/textures/title_static/gFileSelFileInfoBox3Tex.ia16.inc.c"
+};
+
+u64 gFileSelFileInfoBox4Tex[] = {
+#include "assets/textures/title_static/gFileSelFileInfoBox4Tex.ia16.inc.c"
+};
+
+u64 gFileSelFileInfoBox5Tex[] = {
+#include "assets/textures/title_static/gFileSelFileInfoBox5Tex.ia16.inc.c"
+};
+
+u64 gFileSelDISKButtonTex[] = {
+#include "assets/textures/title_static/gFileSelDISKButtonTex.ia16.inc.c"
+};
+
+u64 gFileSelOptionsDividerTex[] = {
+#include "assets/textures/title_static/gFileSelOptionsDividerTex.ia4.inc.c"
+};
+
+u64 gFileSelBrightnessCheckTex[] = {
+#include "assets/textures/title_static/gFileSelBrightnessCheckTex.ia4.inc.c"
+};
+
+u64 gFileSelBigButtonHighlightTex[] = {
+#include "assets/textures/title_static/gFileSelBigButtonHighlightTex.i8.inc.c"
+};
+
+u64 gFileSelCharHighlightTex[] = {
+#include "assets/textures/title_static/gFileSelCharHighlightTex.i8.inc.c"
+};
+
+u64 gFileSelMediumButtonHighlightTex[] = {
+#include "assets/textures/title_static/gFileSelMediumButtonHighlightTex.i8.inc.c"
+};
+
+u64 gFileSelSmallButtonHighlightTex[] = {
+#include "assets/textures/title_static/gFileSelSmallButtonHighlightTex.i8.inc.c"
+};
+
+u64 gFileSelKokiriEmeraldTex[] = {
+#include "assets/textures/title_static/gFileSelKokiriEmeraldTex.rgba32.inc.c"
+};
+
+u64 gFileSelGoronRubyTex[] = {
+#include "assets/textures/title_static/gFileSelGoronRubyTex.rgba32.inc.c"
+};
+
+u64 gFileSelZoraSapphireTex[] = {
+#include "assets/textures/title_static/gFileSelZoraSapphireTex.rgba32.inc.c"
+};
+
+u64 gFileSelNoFileToCopyENGTex[] = {
+#include "assets/textures/title_static/gFileSelNoFileToCopyENGTex.ia8.inc.c"
+};
+
+u64 gFileSelNoFileToEraseENGTex[] = {
+#include "assets/textures/title_static/gFileSelNoFileToEraseENGTex.ia8.inc.c"
+};
+
+u64 gFileSelNoEmptyFileENGTex[] = {
+#include "assets/textures/title_static/gFileSelNoEmptyFileENGTex.ia8.inc.c"
+};
+
+u64 gFileSelFileEmptyENGTex[] = {
+#include "assets/textures/title_static/gFileSelFileEmptyENGTex.ia8.inc.c"
+};
+
+u64 gFileSelFileInUseENGTex[] = {
+#include "assets/textures/title_static/gFileSelFileInUseENGTex.ia8.inc.c"
+};
+
+u64 gFileSelCopyWhichFileENGTex[] = {
+#include "assets/textures/title_static/gFileSelCopyWhichFileENGTex.ia8.inc.c"
+};
+
+u64 gFileSelCopyToWhichFileENGTex[] = {
+#include "assets/textures/title_static/gFileSelCopyToWhichFileENGTex.ia8.inc.c"
+};
+
+u64 gFileSelAreYouSureENGTex[] = {
+#include "assets/textures/title_static/gFileSelAreYouSureENGTex.ia8.inc.c"
+};
+
+u64 gFileSelFileCopiedENGTex[] = {
+#include "assets/textures/title_static/gFileSelFileCopiedENGTex.ia8.inc.c"
+};
+
+u64 gFileSelPleaseSelectAFileENGTex[] = {
+#include "assets/textures/title_static/gFileSelPleaseSelectAFileENGTex.ia8.inc.c"
+};
+
+u64 gFileSelOpenThisFileENGTex[] = {
+#include "assets/textures/title_static/gFileSelOpenThisFileENGTex.ia8.inc.c"
+};
+
+u64 gFileSelEraseWhichFileENGTex[] = {
+#include "assets/textures/title_static/gFileSelEraseWhichFileENGTex.ia8.inc.c"
+};
+
+u64 gFileSelAreYouSure2ENGTex[] = {
+#include "assets/textures/title_static/gFileSelAreYouSure2ENGTex.ia8.inc.c"
+};
+
+u64 gFileSelFileErasedENGTex[] = {
+#include "assets/textures/title_static/gFileSelFileErasedENGTex.ia8.inc.c"
+};
+
+u64 gFileSelOptionsENGTex[] = {
+#include "assets/textures/title_static/gFileSelOptionsENGTex.ia8.inc.c"
+};
+
+u64 gFileSelNameENGTex[] = {
+#include "assets/textures/title_static/gFileSelNameENGTex.ia8.inc.c"
+};
+
+u64 gFileSelControlsENGTex[] = {
+#include "assets/textures/title_static/gFileSelControlsENGTex.ia8.inc.c"
+};
+
+u64 gFileSelCopyButtonENGTex[] = {
+#include "assets/textures/title_static/gFileSelCopyButtonENGTex.ia16.inc.c"
+};
+
+u64 gFileSelFile1ButtonENGTex[] = {
+#include "assets/textures/title_static/gFileSelFile1ButtonENGTex.ia16.inc.c"
+};
+
+u64 gFileSelFile2ButtonENGTex[] = {
+#include "assets/textures/title_static/gFileSelFile2ButtonENGTex.ia16.inc.c"
+};
+
+u64 gFileSelFile3ButtonENGTex[] = {
+#include "assets/textures/title_static/gFileSelFile3ButtonENGTex.ia16.inc.c"
+};
+
+u64 gFileSelYesButtonENGTex[] = {
+#include "assets/textures/title_static/gFileSelYesButtonENGTex.ia16.inc.c"
+};
+
+u64 gFileSelEraseButtonENGTex[] = {
+#include "assets/textures/title_static/gFileSelEraseButtonENGTex.ia16.inc.c"
+};
+
+u64 gFileSelOptionsButtonENGTex[] = {
+#include "assets/textures/title_static/gFileSelOptionsButtonENGTex.ia16.inc.c"
+};
+
+u64 gFileSelOptionsButtonGERTex[] = {
+#include "assets/textures/title_static/gFileSelOptionsButtonGERTex.ia16.inc.c"
+};
+
+u64 gFileSelQuitButtonENGTex[] = {
+#include "assets/textures/title_static/gFileSelQuitButtonENGTex.ia16.inc.c"
+};
+
+u64 gFileSelNoFileToCopyGERTex[] = {
+#include "assets/textures/title_static/gFileSelNoFileToCopyGERTex.ia8.inc.c"
+};
+
+u64 gFileSelNoFileToEraseGERTex[] = {
+#include "assets/textures/title_static/gFileSelNoFileToEraseGERTex.ia8.inc.c"
+};
+
+u64 gFileSelNoEmptyFileGERTex[] = {
+#include "assets/textures/title_static/gFileSelNoEmptyFileGERTex.ia8.inc.c"
+};
+
+u64 gFileSelFileEmptyGERTex[] = {
+#include "assets/textures/title_static/gFileSelFileEmptyGERTex.ia8.inc.c"
+};
+
+u64 gFileSelFileInUseGERTex[] = {
+#include "assets/textures/title_static/gFileSelFileInUseGERTex.ia8.inc.c"
+};
+
+u64 gFileSelCopyWhichFileGERTex[] = {
+#include "assets/textures/title_static/gFileSelCopyWhichFileGERTex.ia8.inc.c"
+};
+
+u64 gFileSelCopyToWhichFileGERTex[] = {
+#include "assets/textures/title_static/gFileSelCopyToWhichFileGERTex.ia8.inc.c"
+};
+
+u64 gFileSelAreYouSureGERTex[] = {
+#include "assets/textures/title_static/gFileSelAreYouSureGERTex.ia8.inc.c"
+};
+
+u64 gFileSelFileCopiedGERTex[] = {
+#include "assets/textures/title_static/gFileSelFileCopiedGERTex.ia8.inc.c"
+};
+
+u64 gFileSelPleaseSelectAFileGERTex[] = {
+#include "assets/textures/title_static/gFileSelPleaseSelectAFileGERTex.ia8.inc.c"
+};
+
+u64 gFileSelOpenThisFileGERTex[] = {
+#include "assets/textures/title_static/gFileSelOpenThisFileGERTex.ia8.inc.c"
+};
+
+u64 gFileSelEraseWhichFileGERTex[] = {
+#include "assets/textures/title_static/gFileSelEraseWhichFileGERTex.ia8.inc.c"
+};
+
+u64 gFileSelAreYouSure2GERTex[] = {
+#include "assets/textures/title_static/gFileSelAreYouSure2GERTex.ia8.inc.c"
+};
+
+u64 gFileSelFileErasedGERTex[] = {
+#include "assets/textures/title_static/gFileSelFileErasedGERTex.ia8.inc.c"
+};
+
+u64 gFileSelOptionsGERTex[] = {
+#include "assets/textures/title_static/gFileSelOptionsGERTex.ia8.inc.c"
+};
+
+u64 gFileSelNameGERTex[] = {
+#include "assets/textures/title_static/gFileSelNameGERTex.ia8.inc.c"
+};
+
+u64 gFileSelControlsGERTex[] = {
+#include "assets/textures/title_static/gFileSelControlsGERTex.ia8.inc.c"
+};
+
+u64 gFileSelCopyButtonGERTex[] = {
+#include "assets/textures/title_static/gFileSelCopyButtonGERTex.ia16.inc.c"
+};
+
+u64 gFileSelFile1ButtonGERTex[] = {
+#include "assets/textures/title_static/gFileSelFile1ButtonGERTex.ia16.inc.c"
+};
+
+u64 gFileSelFile2ButtonGERTex[] = {
+#include "assets/textures/title_static/gFileSelFile2ButtonGERTex.ia16.inc.c"
+};
+
+u64 gFileSelFile3ButtonGERTex[] = {
+#include "assets/textures/title_static/gFileSelFile3ButtonGERTex.ia16.inc.c"
+};
+
+u64 gFileSelYesButtonGERTex[] = {
+#include "assets/textures/title_static/gFileSelYesButtonGERTex.ia16.inc.c"
+};
+
+u64 gFileSelEraseButtonGERTex[] = {
+#include "assets/textures/title_static/gFileSelEraseButtonGERTex.ia16.inc.c"
+};
+
+u64 gFileSelQuitButtonGERTex[] = {
+#include "assets/textures/title_static/gFileSelQuitButtonGERTex.ia16.inc.c"
+};
+
+u64 gFileSelNoFileToCopyFRATex[] = {
+#include "assets/textures/title_static/gFileSelNoFileToCopyFRATex.ia8.inc.c"
+};
+
+u64 gFileSelNoFileToEraseFRATex[] = {
+#include "assets/textures/title_static/gFileSelNoFileToEraseFRATex.ia8.inc.c"
+};
+
+u64 gFileSelNoEmptyFileFRATex[] = {
+#include "assets/textures/title_static/gFileSelNoEmptyFileFRATex.ia8.inc.c"
+};
+
+u64 gFileSelFileEmptyFRATex[] = {
+#include "assets/textures/title_static/gFileSelFileEmptyFRATex.ia8.inc.c"
+};
+
+u64 gFileSelFileInUseFRATex[] = {
+#include "assets/textures/title_static/gFileSelFileInUseFRATex.ia8.inc.c"
+};
+
+u64 gFileSelCopyWhichFileFRATex[] = {
+#include "assets/textures/title_static/gFileSelCopyWhichFileFRATex.ia8.inc.c"
+};
+
+u64 gFileSelCopyToWhichFileFRATex[] = {
+#include "assets/textures/title_static/gFileSelCopyToWhichFileFRATex.ia8.inc.c"
+};
+
+u64 gFileSelAreYouSureFRATex[] = {
+#include "assets/textures/title_static/gFileSelAreYouSureFRATex.ia8.inc.c"
+};
+
+u64 gFileSelFileCopiedFRATex[] = {
+#include "assets/textures/title_static/gFileSelFileCopiedFRATex.ia8.inc.c"
+};
+
+u64 gFileSelPleaseSelectAFileFRATex[] = {
+#include "assets/textures/title_static/gFileSelPleaseSelectAFileFRATex.ia8.inc.c"
+};
+
+u64 gFileSelOpenThisFileFRATex[] = {
+#include "assets/textures/title_static/gFileSelOpenThisFileFRATex.ia8.inc.c"
+};
+
+u64 gFileSelEraseWhichFileFRATex[] = {
+#include "assets/textures/title_static/gFileSelEraseWhichFileFRATex.ia8.inc.c"
+};
+
+u64 gFileSelAreYouSure2FRATex[] = {
+#include "assets/textures/title_static/gFileSelAreYouSure2FRATex.ia8.inc.c"
+};
+
+u64 gFileSelFileErasedFRATex[] = {
+#include "assets/textures/title_static/gFileSelFileErasedFRATex.ia8.inc.c"
+};
+
+u64 gFileSelNameFRATex[] = {
+#include "assets/textures/title_static/gFileSelNameFRATex.ia8.inc.c"
+};
+
+u64 gFileSelControlsFRATex[] = {
+#include "assets/textures/title_static/gFileSelControlsFRATex.ia8.inc.c"
+};
+
+u64 gFileSelCopyButtonFRATex[] = {
+#include "assets/textures/title_static/gFileSelCopyButtonFRATex.ia16.inc.c"
+};
+
+u64 gFileSelFile1ButtonFRATex[] = {
+#include "assets/textures/title_static/gFileSelFile1ButtonFRATex.ia16.inc.c"
+};
+
+u64 gFileSelFile2ButtonFRATex[] = {
+#include "assets/textures/title_static/gFileSelFile2ButtonFRATex.ia16.inc.c"
+};
+
+u64 gFileSelFile3ButtonFRATex[] = {
+#include "assets/textures/title_static/gFileSelFile3ButtonFRATex.ia16.inc.c"
+};
+
+u64 gFileSelYesButtonFRATex[] = {
+#include "assets/textures/title_static/gFileSelYesButtonFRATex.ia16.inc.c"
+};
+
+u64 gFileSelEraseButtonFRATex[] = {
+#include "assets/textures/title_static/gFileSelEraseButtonFRATex.ia16.inc.c"
+};
+
+u64 gFileSelQuitButtonFRATex[] = {
+#include "assets/textures/title_static/gFileSelQuitButtonFRATex.ia16.inc.c"
+};
+
+u64 gFileSelInitialLanguageChoiceENGTex[] = {
+#include "assets/textures/title_static/gFileSelInitialLanguageChoiceENGTex.ia8.inc.c"
+};
+
+u64 gFileSelInitialLanguageChoiceGERTex[] = {
+#include "assets/textures/title_static/gFileSelInitialLanguageChoiceGERTex.ia8.inc.c"
+};
+
+u64 gFileSelInitialLanguageChoiceFRATex[] = {
+#include "assets/textures/title_static/gFileSelInitialLanguageChoiceFRATex.ia8.inc.c"
+};
+
+u64 gFileSelSelectYourLanguageTex[] = {
+#include "assets/textures/title_static/gFileSelSelectYourLanguageTex.ia8.inc.c"
+};
+
+u8 title_static_unaccounted_04C680[] = {
+#include "assets/textures/title_static/title_static_unaccounted_04C680.bin.inc.c"
+};
+
+u64 gFileSelInitialLanguageCursorTex[] = {
+#include "assets/textures/title_static/gFileSelInitialLanguageCursorTex.i4.inc.c"
+};
+
+u64 gRandoControlsENGTex[] = {
+#include "assets/textures/title_static/controls_rando_eng.ia8.inc.c"
+};
+
+u64 gRandoYesENGTex[] = {
+#include "assets/textures/title_static/yes_eng.ia8.inc.c"
+};
+
+u64 gRandoNoENGTex[] = {
+#include "assets/textures/title_static/no_eng.ia8.inc.c"
+};
+
+u64 gRandoSettingsENGTex[] = {
+#include "assets/textures/title_static/settings_eng.ia8.inc.c"
+};
+
+u64 gRandoShuffleENGTex[] = {
+#include "assets/textures/title_static/shuffle_eng.ia8.inc.c"
+};
+
+u64 gRandoChestsENGTex[] = {
+#include "assets/textures/title_static/chests_eng.ia8.inc.c"
+};
+
+u64 gOptionQuicktextENGTex[] = {
+#include "assets/textures/title_static/quicktext_eng.ia8.inc.c"
+};
+
+u64 gOptionOnENGTex[] = {
+#include "assets/textures/title_static/on_eng.ia8.inc.c"
+};
+
+u64 gOptionOffENGTex[] = {
+#include "assets/textures/title_static/off_eng.ia8.inc.c"
+};
+
+Gfx gFileSelWindow1DL[] = {
+#include "assets/textures/title_static/gFileSelWindow1DL.inc.c"
+};
+
+Gfx gFileSelWindow2DL[] = {
+#include "assets/textures/title_static/gFileSelWindow2DL.inc.c"
+};
+
+Gfx gFileSelWindow3DL[] = {
+#include "assets/textures/title_static/gFileSelWindow3DL.inc.c"
+};
+
+u8 title_static_zeros_04D2B8[8] = { 0 };
+
diff --git a/assets/textures/title_static/title_static.h b/assets/textures/title_static/title_static.h
new file mode 100644
index 000000000..9cb8f8d04
--- /dev/null
+++ b/assets/textures/title_static/title_static.h
@@ -0,0 +1,482 @@
+#ifndef TITLE_STATIC_H
+#define TITLE_STATIC_H 1
+
+#define gFileSelConnectorTex_WIDTH 24
+#define gFileSelConnectorTex_HEIGHT 16
+extern u64 gFileSelConnectorTex[];
+#define gFileSelForestMedallionTex_WIDTH 16
+#define gFileSelForestMedallionTex_HEIGHT 16
+extern u64 gFileSelForestMedallionTex[];
+#define gFileSelFireMedallionTex_WIDTH 16
+#define gFileSelFireMedallionTex_HEIGHT 16
+extern u64 gFileSelFireMedallionTex[];
+#define gFileSelWaterMedallionTex_WIDTH 16
+#define gFileSelWaterMedallionTex_HEIGHT 16
+extern u64 gFileSelWaterMedallionTex[];
+#define gFileSelSpiritMedallionTex_WIDTH 16
+#define gFileSelSpiritMedallionTex_HEIGHT 16
+extern u64 gFileSelSpiritMedallionTex[];
+#define gFileSelShadowMedallionTex_WIDTH 16
+#define gFileSelShadowMedallionTex_HEIGHT 16
+extern u64 gFileSelShadowMedallionTex[];
+#define gFileSelLightMedallionTex_WIDTH 16
+#define gFileSelLightMedallionTex_HEIGHT 16
+extern u64 gFileSelLightMedallionTex[];
+#define gFileSelSurroundENGTex_WIDTH 48
+#define gFileSelSurroundENGTex_HEIGHT 16
+extern u64 gFileSelSurroundENGTex[];
+#define gFileSelHeadsetENGTex_WIDTH 48
+#define gFileSelHeadsetENGTex_HEIGHT 16
+extern u64 gFileSelHeadsetENGTex[];
+#define gFileSelHeadsetGERTex_WIDTH 48
+#define gFileSelHeadsetGERTex_HEIGHT 16
+extern u64 gFileSelHeadsetGERTex[];
+#define gFileSelHeadsetFRATex_WIDTH 48
+#define gFileSelHeadsetFRATex_HEIGHT 16
+extern u64 gFileSelHeadsetFRATex[];
+#define gFileSelMonoENGTex_WIDTH 48
+#define gFileSelMonoENGTex_HEIGHT 16
+extern u64 gFileSelMonoENGTex[];
+#define gFileSelSOUNDENGTex_WIDTH 64
+#define gFileSelSOUNDENGTex_HEIGHT 16
+extern u64 gFileSelSOUNDENGTex[];
+#define gFileSelSOUNDFRATex_WIDTH 64
+#define gFileSelSOUNDFRATex_HEIGHT 16
+extern u64 gFileSelSOUNDFRATex[];
+#define gFileSelStereoENGTex_WIDTH 48
+#define gFileSelStereoENGTex_HEIGHT 16
+extern u64 gFileSelStereoENGTex[];
+#define gFileSelStereoFRATex_WIDTH 48
+#define gFileSelStereoFRATex_HEIGHT 16
+extern u64 gFileSelStereoFRATex[];
+#define gFileSelZTargetingENGTex_WIDTH 64
+#define gFileSelZTargetingENGTex_HEIGHT 16
+extern u64 gFileSelZTargetingENGTex[];
+#define gFileSelZTargetingGERTex_WIDTH 144
+#define gFileSelZTargetingGERTex_HEIGHT 16
+extern u64 gFileSelZTargetingGERTex[];
+#define gFileSelZTargetingFRATex_WIDTH 64
+#define gFileSelZTargetingFRATex_HEIGHT 16
+extern u64 gFileSelZTargetingFRATex[];
+#define gFileSelSwitchENGTex_WIDTH 48
+#define gFileSelSwitchENGTex_HEIGHT 16
+extern u64 gFileSelSwitchENGTex[];
+#define gFileSelSwitchGERTex_WIDTH 80
+#define gFileSelSwitchGERTex_HEIGHT 16
+extern u64 gFileSelSwitchGERTex[];
+#define gFileSelSwitchFRATex_WIDTH 48
+#define gFileSelSwitchFRATex_HEIGHT 16
+extern u64 gFileSelSwitchFRATex[];
+#define gFileSelHoldENGTex_WIDTH 48
+#define gFileSelHoldENGTex_HEIGHT 16
+extern u64 gFileSelHoldENGTex[];
+#define gFileSelHoldGERTex_WIDTH 80
+#define gFileSelHoldGERTex_HEIGHT 16
+extern u64 gFileSelHoldGERTex[];
+#define gFileSelHoldFRATex_WIDTH 48
+#define gFileSelHoldFRATex_HEIGHT 16
+extern u64 gFileSelHoldFRATex[];
+#define gFileSelCheckBrightnessENGTex_WIDTH 128
+#define gFileSelCheckBrightnessENGTex_HEIGHT 16
+extern u64 gFileSelCheckBrightnessENGTex[];
+#define gFileSelCheckBrightnessGERTex_WIDTH 128
+#define gFileSelCheckBrightnessGERTex_HEIGHT 16
+extern u64 gFileSelCheckBrightnessGERTex[];
+#define gFileSelCheckBrightnessFRATex_WIDTH 128
+#define gFileSelCheckBrightnessFRATex_HEIGHT 16
+extern u64 gFileSelCheckBrightnessFRATex[];
+#define gFileSelLanguageChoiceENGTex_WIDTH 48
+#define gFileSelLanguageChoiceENGTex_HEIGHT 16
+extern u64 gFileSelLanguageChoiceENGTex[];
+#define gFileSelLanguageChoiceGERTex_WIDTH 48
+#define gFileSelLanguageChoiceGERTex_HEIGHT 16
+extern u64 gFileSelLanguageChoiceGERTex[];
+#define gFileSelLanguageChoiceFRATex_WIDTH 48
+#define gFileSelLanguageChoiceFRATex_HEIGHT 16
+extern u64 gFileSelLanguageChoiceFRATex[];
+#define gFileSelLanguageENGTex_WIDTH 64
+#define gFileSelLanguageENGTex_HEIGHT 16
+extern u64 gFileSelLanguageENGTex[];
+#define gFileSelLanguageGERTex_WIDTH 64
+#define gFileSelLanguageGERTex_HEIGHT 16
+extern u64 gFileSelLanguageGERTex[];
+#define gFileSelLanguageFRATex_WIDTH 64
+#define gFileSelLanguageFRATex_HEIGHT 16
+extern u64 gFileSelLanguageFRATex[];
+#define gFileSelWindow1Tex_WIDTH 64
+#define gFileSelWindow1Tex_HEIGHT 32
+extern u64 gFileSelWindow1Tex[];
+#define gFileSelWindow2Tex_WIDTH 64
+#define gFileSelWindow2Tex_HEIGHT 32
+extern u64 gFileSelWindow2Tex[];
+#define gFileSelWindow3Tex_WIDTH 64
+#define gFileSelWindow3Tex_HEIGHT 32
+extern u64 gFileSelWindow3Tex[];
+#define gFileSelWindow4Tex_WIDTH 48
+#define gFileSelWindow4Tex_HEIGHT 32
+extern u64 gFileSelWindow4Tex[];
+#define gFileSelWindow5Tex_WIDTH 64
+#define gFileSelWindow5Tex_HEIGHT 32
+extern u64 gFileSelWindow5Tex[];
+#define gFileSelWindow6Tex_WIDTH 64
+#define gFileSelWindow6Tex_HEIGHT 32
+extern u64 gFileSelWindow6Tex[];
+#define gFileSelWindow7Tex_WIDTH 64
+#define gFileSelWindow7Tex_HEIGHT 32
+extern u64 gFileSelWindow7Tex[];
+#define gFileSelWindow8Tex_WIDTH 48
+#define gFileSelWindow8Tex_HEIGHT 32
+extern u64 gFileSelWindow8Tex[];
+#define gFileSelWindow9Tex_WIDTH 64
+#define gFileSelWindow9Tex_HEIGHT 32
+extern u64 gFileSelWindow9Tex[];
+#define gFileSelWindow10Tex_WIDTH 64
+#define gFileSelWindow10Tex_HEIGHT 32
+extern u64 gFileSelWindow10Tex[];
+#define gFileSelWindow11Tex_WIDTH 64
+#define gFileSelWindow11Tex_HEIGHT 32
+extern u64 gFileSelWindow11Tex[];
+#define gFileSelWindow12Tex_WIDTH 48
+#define gFileSelWindow12Tex_HEIGHT 32
+extern u64 gFileSelWindow12Tex[];
+#define gFileSelWindow13Tex_WIDTH 64
+#define gFileSelWindow13Tex_HEIGHT 32
+extern u64 gFileSelWindow13Tex[];
+#define gFileSelWindow14Tex_WIDTH 64
+#define gFileSelWindow14Tex_HEIGHT 32
+extern u64 gFileSelWindow14Tex[];
+#define gFileSelWindow15Tex_WIDTH 64
+#define gFileSelWindow15Tex_HEIGHT 32
+extern u64 gFileSelWindow15Tex[];
+#define gFileSelWindow16Tex_WIDTH 48
+#define gFileSelWindow16Tex_HEIGHT 32
+extern u64 gFileSelWindow16Tex[];
+#define gFileSelWindow17Tex_WIDTH 64
+#define gFileSelWindow17Tex_HEIGHT 32
+extern u64 gFileSelWindow17Tex[];
+#define gFileSelWindow18Tex_WIDTH 64
+#define gFileSelWindow18Tex_HEIGHT 32
+extern u64 gFileSelWindow18Tex[];
+#define gFileSelWindow19Tex_WIDTH 64
+#define gFileSelWindow19Tex_HEIGHT 32
+extern u64 gFileSelWindow19Tex[];
+#define gFileSelWindow20Tex_WIDTH 48
+#define gFileSelWindow20Tex_HEIGHT 32
+extern u64 gFileSelWindow20Tex[];
+#define gFileSelKanjiButtonTex_WIDTH 28
+#define gFileSelKanjiButtonTex_HEIGHT 16
+extern u64 gFileSelKanjiButtonTex[];
+#define gFileSelHiraganaButtonTex_WIDTH 44
+#define gFileSelHiraganaButtonTex_HEIGHT 16
+extern u64 gFileSelHiraganaButtonTex[];
+#define gFileSelKatakanaButtonTex_WIDTH 44
+#define gFileSelKatakanaButtonTex_HEIGHT 16
+extern u64 gFileSelKatakanaButtonTex[];
+#define gFileSelENDButtonENGTex_WIDTH 44
+#define gFileSelENDButtonENGTex_HEIGHT 16
+extern u64 gFileSelENDButtonENGTex[];
+#define gFileSelENDButtonGERTex_WIDTH 44
+#define gFileSelENDButtonGERTex_HEIGHT 16
+extern u64 gFileSelENDButtonGERTex[];
+#define gFileSelENDButtonFRATex_WIDTH 44
+#define gFileSelENDButtonFRATex_HEIGHT 16
+extern u64 gFileSelENDButtonFRATex[];
+#define gFileSelBackspaceButtonTex_WIDTH 28
+#define gFileSelBackspaceButtonTex_HEIGHT 16
+extern u64 gFileSelBackspaceButtonTex[];
+#define gFileSelNameBoxTex_WIDTH 108
+#define gFileSelNameBoxTex_HEIGHT 16
+extern u64 gFileSelNameBoxTex[];
+#define gFileSelFileInfoBox1Tex_WIDTH 36
+#define gFileSelFileInfoBox1Tex_HEIGHT 56
+extern u64 gFileSelFileInfoBox1Tex[];
+#define gFileSelFileInfoBox2Tex_WIDTH 36
+#define gFileSelFileInfoBox2Tex_HEIGHT 56
+extern u64 gFileSelFileInfoBox2Tex[];
+#define gFileSelFileInfoBox3Tex_WIDTH 36
+#define gFileSelFileInfoBox3Tex_HEIGHT 56
+extern u64 gFileSelFileInfoBox3Tex[];
+#define gFileSelFileInfoBox4Tex_WIDTH 36
+#define gFileSelFileInfoBox4Tex_HEIGHT 56
+extern u64 gFileSelFileInfoBox4Tex[];
+#define gFileSelFileInfoBox5Tex_WIDTH 24
+#define gFileSelFileInfoBox5Tex_HEIGHT 56
+extern u64 gFileSelFileInfoBox5Tex[];
+#define gFileSelDISKButtonTex_WIDTH 44
+#define gFileSelDISKButtonTex_HEIGHT 16
+extern u64 gFileSelDISKButtonTex[];
+#define gFileSelOptionsDividerTex_WIDTH 256
+#define gFileSelOptionsDividerTex_HEIGHT 2
+extern u64 gFileSelOptionsDividerTex[];
+#define gFileSelBrightnessCheckTex_WIDTH 96
+#define gFileSelBrightnessCheckTex_HEIGHT 16
+extern u64 gFileSelBrightnessCheckTex[];
+#define gFileSelBigButtonHighlightTex_WIDTH 72
+#define gFileSelBigButtonHighlightTex_HEIGHT 24
+extern u64 gFileSelBigButtonHighlightTex[];
+#define gFileSelCharHighlightTex_WIDTH 24
+#define gFileSelCharHighlightTex_HEIGHT 24
+extern u64 gFileSelCharHighlightTex[];
+#define gFileSelMediumButtonHighlightTex_WIDTH 56
+#define gFileSelMediumButtonHighlightTex_HEIGHT 24
+extern u64 gFileSelMediumButtonHighlightTex[];
+#define gFileSelSmallButtonHighlightTex_WIDTH 40
+#define gFileSelSmallButtonHighlightTex_HEIGHT 24
+extern u64 gFileSelSmallButtonHighlightTex[];
+#define gFileSelKokiriEmeraldTex_WIDTH 16
+#define gFileSelKokiriEmeraldTex_HEIGHT 16
+extern u64 gFileSelKokiriEmeraldTex[];
+#define gFileSelGoronRubyTex_WIDTH 16
+#define gFileSelGoronRubyTex_HEIGHT 16
+extern u64 gFileSelGoronRubyTex[];
+#define gFileSelZoraSapphireTex_WIDTH 16
+#define gFileSelZoraSapphireTex_HEIGHT 16
+extern u64 gFileSelZoraSapphireTex[];
+#define gFileSelNoFileToCopyENGTex_WIDTH 128
+#define gFileSelNoFileToCopyENGTex_HEIGHT 16
+extern u64 gFileSelNoFileToCopyENGTex[];
+#define gFileSelNoFileToEraseENGTex_WIDTH 128
+#define gFileSelNoFileToEraseENGTex_HEIGHT 16
+extern u64 gFileSelNoFileToEraseENGTex[];
+#define gFileSelNoEmptyFileENGTex_WIDTH 128
+#define gFileSelNoEmptyFileENGTex_HEIGHT 16
+extern u64 gFileSelNoEmptyFileENGTex[];
+#define gFileSelFileEmptyENGTex_WIDTH 128
+#define gFileSelFileEmptyENGTex_HEIGHT 16
+extern u64 gFileSelFileEmptyENGTex[];
+#define gFileSelFileInUseENGTex_WIDTH 128
+#define gFileSelFileInUseENGTex_HEIGHT 16
+extern u64 gFileSelFileInUseENGTex[];
+#define gFileSelCopyWhichFileENGTex_WIDTH 128
+#define gFileSelCopyWhichFileENGTex_HEIGHT 16
+extern u64 gFileSelCopyWhichFileENGTex[];
+#define gFileSelCopyToWhichFileENGTex_WIDTH 128
+#define gFileSelCopyToWhichFileENGTex_HEIGHT 16
+extern u64 gFileSelCopyToWhichFileENGTex[];
+#define gFileSelAreYouSureENGTex_WIDTH 128
+#define gFileSelAreYouSureENGTex_HEIGHT 16
+extern u64 gFileSelAreYouSureENGTex[];
+#define gFileSelFileCopiedENGTex_WIDTH 128
+#define gFileSelFileCopiedENGTex_HEIGHT 16
+extern u64 gFileSelFileCopiedENGTex[];
+#define gFileSelPleaseSelectAFileENGTex_WIDTH 128
+#define gFileSelPleaseSelectAFileENGTex_HEIGHT 16
+extern u64 gFileSelPleaseSelectAFileENGTex[];
+#define gFileSelOpenThisFileENGTex_WIDTH 128
+#define gFileSelOpenThisFileENGTex_HEIGHT 16
+extern u64 gFileSelOpenThisFileENGTex[];
+#define gFileSelEraseWhichFileENGTex_WIDTH 128
+#define gFileSelEraseWhichFileENGTex_HEIGHT 16
+extern u64 gFileSelEraseWhichFileENGTex[];
+#define gFileSelAreYouSure2ENGTex_WIDTH 128
+#define gFileSelAreYouSure2ENGTex_HEIGHT 16
+extern u64 gFileSelAreYouSure2ENGTex[];
+#define gFileSelFileErasedENGTex_WIDTH 128
+#define gFileSelFileErasedENGTex_HEIGHT 16
+extern u64 gFileSelFileErasedENGTex[];
+#define gFileSelOptionsENGTex_WIDTH 128
+#define gFileSelOptionsENGTex_HEIGHT 16
+extern u64 gFileSelOptionsENGTex[];
+#define gFileSelNameENGTex_WIDTH 56
+#define gFileSelNameENGTex_HEIGHT 16
+extern u64 gFileSelNameENGTex[];
+#define gFileSelControlsENGTex_WIDTH 144
+#define gFileSelControlsENGTex_HEIGHT 16
+extern u64 gFileSelControlsENGTex[];
+#define gFileSelCopyButtonENGTex_WIDTH 64
+#define gFileSelCopyButtonENGTex_HEIGHT 16
+extern u64 gFileSelCopyButtonENGTex[];
+#define gFileSelFile1ButtonENGTex_WIDTH 64
+#define gFileSelFile1ButtonENGTex_HEIGHT 16
+extern u64 gFileSelFile1ButtonENGTex[];
+#define gFileSelFile2ButtonENGTex_WIDTH 64
+#define gFileSelFile2ButtonENGTex_HEIGHT 16
+extern u64 gFileSelFile2ButtonENGTex[];
+#define gFileSelFile3ButtonENGTex_WIDTH 64
+#define gFileSelFile3ButtonENGTex_HEIGHT 16
+extern u64 gFileSelFile3ButtonENGTex[];
+#define gFileSelYesButtonENGTex_WIDTH 64
+#define gFileSelYesButtonENGTex_HEIGHT 16
+extern u64 gFileSelYesButtonENGTex[];
+#define gFileSelEraseButtonENGTex_WIDTH 64
+#define gFileSelEraseButtonENGTex_HEIGHT 16
+extern u64 gFileSelEraseButtonENGTex[];
+#define gFileSelOptionsButtonENGTex_WIDTH 64
+#define gFileSelOptionsButtonENGTex_HEIGHT 16
+extern u64 gFileSelOptionsButtonENGTex[];
+#define gFileSelOptionsButtonGERTex_WIDTH 64
+#define gFileSelOptionsButtonGERTex_HEIGHT 16
+extern u64 gFileSelOptionsButtonGERTex[];
+#define gFileSelQuitButtonENGTex_WIDTH 64
+#define gFileSelQuitButtonENGTex_HEIGHT 16
+extern u64 gFileSelQuitButtonENGTex[];
+#define gFileSelNoFileToCopyGERTex_WIDTH 128
+#define gFileSelNoFileToCopyGERTex_HEIGHT 16
+extern u64 gFileSelNoFileToCopyGERTex[];
+#define gFileSelNoFileToEraseGERTex_WIDTH 128
+#define gFileSelNoFileToEraseGERTex_HEIGHT 16
+extern u64 gFileSelNoFileToEraseGERTex[];
+#define gFileSelNoEmptyFileGERTex_WIDTH 128
+#define gFileSelNoEmptyFileGERTex_HEIGHT 16
+extern u64 gFileSelNoEmptyFileGERTex[];
+#define gFileSelFileEmptyGERTex_WIDTH 128
+#define gFileSelFileEmptyGERTex_HEIGHT 16
+extern u64 gFileSelFileEmptyGERTex[];
+#define gFileSelFileInUseGERTex_WIDTH 128
+#define gFileSelFileInUseGERTex_HEIGHT 16
+extern u64 gFileSelFileInUseGERTex[];
+#define gFileSelCopyWhichFileGERTex_WIDTH 128
+#define gFileSelCopyWhichFileGERTex_HEIGHT 16
+extern u64 gFileSelCopyWhichFileGERTex[];
+#define gFileSelCopyToWhichFileGERTex_WIDTH 128
+#define gFileSelCopyToWhichFileGERTex_HEIGHT 16
+extern u64 gFileSelCopyToWhichFileGERTex[];
+#define gFileSelAreYouSureGERTex_WIDTH 128
+#define gFileSelAreYouSureGERTex_HEIGHT 16
+extern u64 gFileSelAreYouSureGERTex[];
+#define gFileSelFileCopiedGERTex_WIDTH 128
+#define gFileSelFileCopiedGERTex_HEIGHT 16
+extern u64 gFileSelFileCopiedGERTex[];
+#define gFileSelPleaseSelectAFileGERTex_WIDTH 128
+#define gFileSelPleaseSelectAFileGERTex_HEIGHT 16
+extern u64 gFileSelPleaseSelectAFileGERTex[];
+#define gFileSelOpenThisFileGERTex_WIDTH 128
+#define gFileSelOpenThisFileGERTex_HEIGHT 16
+extern u64 gFileSelOpenThisFileGERTex[];
+#define gFileSelEraseWhichFileGERTex_WIDTH 128
+#define gFileSelEraseWhichFileGERTex_HEIGHT 16
+extern u64 gFileSelEraseWhichFileGERTex[];
+#define gFileSelAreYouSure2GERTex_WIDTH 128
+#define gFileSelAreYouSure2GERTex_HEIGHT 16
+extern u64 gFileSelAreYouSure2GERTex[];
+#define gFileSelFileErasedGERTex_WIDTH 128
+#define gFileSelFileErasedGERTex_HEIGHT 16
+extern u64 gFileSelFileErasedGERTex[];
+#define gFileSelOptionsGERTex_WIDTH 128
+#define gFileSelOptionsGERTex_HEIGHT 16
+extern u64 gFileSelOptionsGERTex[];
+#define gFileSelNameGERTex_WIDTH 56
+#define gFileSelNameGERTex_HEIGHT 16
+extern u64 gFileSelNameGERTex[];
+#define gFileSelControlsGERTex_WIDTH 144
+#define gFileSelControlsGERTex_HEIGHT 16
+extern u64 gFileSelControlsGERTex[];
+#define gFileSelCopyButtonGERTex_WIDTH 64
+#define gFileSelCopyButtonGERTex_HEIGHT 16
+extern u64 gFileSelCopyButtonGERTex[];
+#define gFileSelFile1ButtonGERTex_WIDTH 64
+#define gFileSelFile1ButtonGERTex_HEIGHT 16
+extern u64 gFileSelFile1ButtonGERTex[];
+#define gFileSelFile2ButtonGERTex_WIDTH 64
+#define gFileSelFile2ButtonGERTex_HEIGHT 16
+extern u64 gFileSelFile2ButtonGERTex[];
+#define gFileSelFile3ButtonGERTex_WIDTH 64
+#define gFileSelFile3ButtonGERTex_HEIGHT 16
+extern u64 gFileSelFile3ButtonGERTex[];
+#define gFileSelYesButtonGERTex_WIDTH 64
+#define gFileSelYesButtonGERTex_HEIGHT 16
+extern u64 gFileSelYesButtonGERTex[];
+#define gFileSelEraseButtonGERTex_WIDTH 64
+#define gFileSelEraseButtonGERTex_HEIGHT 16
+extern u64 gFileSelEraseButtonGERTex[];
+#define gFileSelQuitButtonGERTex_WIDTH 64
+#define gFileSelQuitButtonGERTex_HEIGHT 16
+extern u64 gFileSelQuitButtonGERTex[];
+#define gFileSelNoFileToCopyFRATex_WIDTH 128
+#define gFileSelNoFileToCopyFRATex_HEIGHT 16
+extern u64 gFileSelNoFileToCopyFRATex[];
+#define gFileSelNoFileToEraseFRATex_WIDTH 128
+#define gFileSelNoFileToEraseFRATex_HEIGHT 16
+extern u64 gFileSelNoFileToEraseFRATex[];
+#define gFileSelNoEmptyFileFRATex_WIDTH 128
+#define gFileSelNoEmptyFileFRATex_HEIGHT 16
+extern u64 gFileSelNoEmptyFileFRATex[];
+#define gFileSelFileEmptyFRATex_WIDTH 128
+#define gFileSelFileEmptyFRATex_HEIGHT 16
+extern u64 gFileSelFileEmptyFRATex[];
+#define gFileSelFileInUseFRATex_WIDTH 128
+#define gFileSelFileInUseFRATex_HEIGHT 16
+extern u64 gFileSelFileInUseFRATex[];
+#define gFileSelCopyWhichFileFRATex_WIDTH 128
+#define gFileSelCopyWhichFileFRATex_HEIGHT 16
+extern u64 gFileSelCopyWhichFileFRATex[];
+#define gFileSelCopyToWhichFileFRATex_WIDTH 128
+#define gFileSelCopyToWhichFileFRATex_HEIGHT 16
+extern u64 gFileSelCopyToWhichFileFRATex[];
+#define gFileSelAreYouSureFRATex_WIDTH 128
+#define gFileSelAreYouSureFRATex_HEIGHT 16
+extern u64 gFileSelAreYouSureFRATex[];
+#define gFileSelFileCopiedFRATex_WIDTH 128
+#define gFileSelFileCopiedFRATex_HEIGHT 16
+extern u64 gFileSelFileCopiedFRATex[];
+#define gFileSelPleaseSelectAFileFRATex_WIDTH 128
+#define gFileSelPleaseSelectAFileFRATex_HEIGHT 16
+extern u64 gFileSelPleaseSelectAFileFRATex[];
+#define gFileSelOpenThisFileFRATex_WIDTH 128
+#define gFileSelOpenThisFileFRATex_HEIGHT 16
+extern u64 gFileSelOpenThisFileFRATex[];
+#define gFileSelEraseWhichFileFRATex_WIDTH 128
+#define gFileSelEraseWhichFileFRATex_HEIGHT 16
+extern u64 gFileSelEraseWhichFileFRATex[];
+#define gFileSelAreYouSure2FRATex_WIDTH 128
+#define gFileSelAreYouSure2FRATex_HEIGHT 16
+extern u64 gFileSelAreYouSure2FRATex[];
+#define gFileSelFileErasedFRATex_WIDTH 128
+#define gFileSelFileErasedFRATex_HEIGHT 16
+extern u64 gFileSelFileErasedFRATex[];
+#define gFileSelNameFRATex_WIDTH 56
+#define gFileSelNameFRATex_HEIGHT 16
+extern u64 gFileSelNameFRATex[];
+#define gFileSelControlsFRATex_WIDTH 144
+#define gFileSelControlsFRATex_HEIGHT 16
+extern u64 gFileSelControlsFRATex[];
+#define gFileSelCopyButtonFRATex_WIDTH 64
+#define gFileSelCopyButtonFRATex_HEIGHT 16
+extern u64 gFileSelCopyButtonFRATex[];
+#define gFileSelFile1ButtonFRATex_WIDTH 64
+#define gFileSelFile1ButtonFRATex_HEIGHT 16
+extern u64 gFileSelFile1ButtonFRATex[];
+#define gFileSelFile2ButtonFRATex_WIDTH 64
+#define gFileSelFile2ButtonFRATex_HEIGHT 16
+extern u64 gFileSelFile2ButtonFRATex[];
+#define gFileSelFile3ButtonFRATex_WIDTH 64
+#define gFileSelFile3ButtonFRATex_HEIGHT 16
+extern u64 gFileSelFile3ButtonFRATex[];
+#define gFileSelYesButtonFRATex_WIDTH 64
+#define gFileSelYesButtonFRATex_HEIGHT 16
+extern u64 gFileSelYesButtonFRATex[];
+#define gFileSelEraseButtonFRATex_WIDTH 64
+#define gFileSelEraseButtonFRATex_HEIGHT 16
+extern u64 gFileSelEraseButtonFRATex[];
+#define gFileSelQuitButtonFRATex_WIDTH 64
+#define gFileSelQuitButtonFRATex_HEIGHT 16
+extern u64 gFileSelQuitButtonFRATex[];
+#define gFileSelInitialLanguageChoiceENGTex_WIDTH 80
+#define gFileSelInitialLanguageChoiceENGTex_HEIGHT 32
+extern u64 gFileSelInitialLanguageChoiceENGTex[];
+#define gFileSelInitialLanguageChoiceGERTex_WIDTH 80
+#define gFileSelInitialLanguageChoiceGERTex_HEIGHT 32
+extern u64 gFileSelInitialLanguageChoiceGERTex[];
+#define gFileSelInitialLanguageChoiceFRATex_WIDTH 80
+#define gFileSelInitialLanguageChoiceFRATex_HEIGHT 32
+extern u64 gFileSelInitialLanguageChoiceFRATex[];
+#define gFileSelSelectYourLanguageTex_WIDTH 160
+#define gFileSelSelectYourLanguageTex_HEIGHT 60
+extern u64 gFileSelSelectYourLanguageTex[];
+extern u8 title_static_unaccounted_04C680[];
+#define gFileSelInitialLanguageCursorTex_WIDTH 48
+#define gFileSelInitialLanguageCursorTex_HEIGHT 48
+extern u64 gFileSelInitialLanguageCursorTex[];
+extern u64 gRandoControlsENGTex[];
+extern u64 gRandoYesENGTex[];
+extern u64 gRandoNoENGTex[];
+extern u64 gRandoSettingsENGTex[];
+extern u64 gRandoShuffleENGTex[];
+extern u64 gRandoChestsENGTex[];
+extern u64 gOptionQuicktextENGTex[];
+extern u64 gOptionOnENGTex[];
+extern u64 gOptionOffENGTex[];
+extern Gfx gFileSelWindow1DL[];
+extern Gfx gFileSelWindow2DL[];
+extern Gfx gFileSelWindow3DL[];
+#endif
diff --git a/assets/textures/title_static/yes_eng.ia8.png b/assets/textures/title_static/yes_eng.ia8.png
new file mode 100644
index 000000000..224d54dc4
Binary files /dev/null and b/assets/textures/title_static/yes_eng.ia8.png differ
diff --git a/docker-compose.yml b/docker-compose.yml
index bca75f474..d8e3ffe2b 100644
--- a/docker-compose.yml
+++ b/docker-compose.yml
@@ -1,8 +1,9 @@
 services:
   oot:
     build:
+      context: .
       dockerfile: Dockerfile
     volumes:
-      - ./:/oot
+      - ./:/oot:Z
     tty: true
     stdin_open: true
diff --git a/gzi/US.gzi b/gzi/US.gzi
new file mode 100644
index 000000000..30ab26f55
--- /dev/null
+++ b/gzi/US.gzi
@@ -0,0 +1,6 @@
+# default gz patches for NACE
+0000 00000000 00000001
+# use 8MB memory
+0304 00002EB0 60000000
+# allocate 32MB for rom
+0304 0005BFD4 3C807200
diff --git a/include/build.h b/include/build.h
index 25afaaa81..d08af1500 100644
--- a/include/build.h
+++ b/include/build.h
@@ -3,6 +3,7 @@
 
 extern const char gBuildCreator[];
 extern const char gBuildDate[];
+extern const char gBuildVersion[];
 extern const char gBuildMakeOption[];
 
 #endif
diff --git a/include/file_select_state.h b/include/file_select_state.h
index 0a831caa0..9ed9d3757 100644
--- a/include/file_select_state.h
+++ b/include/file_select_state.h
@@ -10,86 +10,87 @@
 #include "z64view.h"
 
 typedef struct FileSelectState {
-    /* 0x00000 */ GameState state;
-    /* 0x000A4 */ Vtx* windowVtx;
-    /* 0x000A8 */ u8* staticSegment;
-    /* 0x000AC */ u8* parameterSegment;
+    GameState state;
+    Vtx* windowVtx;
+    u8* randoStaticSegment;
+    u8* staticSegment;
+    u8* parameterSegment;
 #if OOT_PAL
-    /* 0x000B0 */ u8* objectMagSegment;
+    u8* objectMagSegment;
 #endif
-    /* 0x000B8 */ View view;
-    /* 0x001E0 */ SramContext sramCtx;
-    /* 0x001E4 */ char unk_1E4[0x4];
-    /* 0x001E8 */ SkyboxContext skyboxCtx;
-    /* 0x00348 */ MessageContext msgCtx;
-    /* 0x0E760 */ Font font;
-    /* 0x1C8E8 */ EnvironmentContext envCtx;
-    /* 0x1C9E4 */ char unk_1C9E4[0x4];
-    /* 0x1C9E8 */ Vtx* windowContentVtx;
-    /* 0x1C9EC */ Vtx* keyboardVtx;
-    /* 0x1C9F0 */ Vtx* nameEntryVtx;
-    /* 0x1C9F4 */ u8 n64ddFlag;
-    /* 0x1C9F6 */ u16 deaths[3];
-    /* 0x1C9FC */ u8 fileNames[3][8];
-    /* 0x1CA14 */ u16 healthCapacities[3];
-    /* 0x1CA1C */ u32 questItems[3];
-    /* 0x1CA28 */ s16 n64ddFlags[3];
-    /* 0x1CA2E */ s8 defense[3];
+    View view;
+    SramContext sramCtx;
+    char unk_1E4[0x4];
+    SkyboxContext skyboxCtx;
+    MessageContext msgCtx;
+    Font font;
+    EnvironmentContext envCtx;
+    char unk_1C9E4[0x4];
+    Vtx* windowContentVtx;
+    Vtx* keyboardVtx;
+    Vtx* nameEntryVtx;
+    u8 n64ddFlag;
+    u16 deaths[2];
+    u8 fileNames[2][8];
+    u16 healthCapacities[2];
+    u32 questItems[2];
+    s16 n64ddFlags[2];
+    s8 defense[2];
 #if OOT_PAL
-    /* 0x1CA32 */ u16 health[3];
+    u16 health[2];
 #endif
-    /* 0x1CA38 */ s16 buttonIndex;
-    /* 0x1CA3A */ s16 confirmButtonIndex; // 0: yes, 1: quit
-    /* 0x1CA3C */ s16 menuMode;
-    /* 0x1CA3E */ s16 configMode;
-    /* 0x1CA40 */ s16 prevConfigMode;
-    /* 0x1CA42 */ s16 nextConfigMode;
-    /* 0x1CA44 */ s16 selectMode;
-    /* 0x1CA46 */ s16 selectedFileIndex;
-    /* 0x1CA48 */ char unk_1CA48[0x2];
-    /* 0x1CA4A */ s16 fileNamesY[3];
-    /* 0x1CA50 */ s16 actionTimer;
-    /* 0x1CA52 */ s16 buttonYOffsets[6];
-    /* 0x1CA5E */ s16 copyDestFileIndex;
-    /* 0x1CA60 */ s16 warningLabel;
-    /* 0x1CA62 */ s16 warningButtonIndex;
-    /* 0x1CA64 */ s16 titleLabel;
-    /* 0x1CA66 */ s16 nextTitleLabel;
-    /* 0x1CA68 */ s16 windowColor[3];
-    /* 0x1CA6E */ s16 titleAlpha[2];
-    /* 0x1CA72 */ s16 windowAlpha;
-    /* 0x1CA74 */ s16 fileButtonAlpha[3];
-    /* 0x1CA7A */ s16 nameBoxAlpha[3];
-    /* 0x1CA80 */ s16 nameAlpha[3];
-    /* 0x1CA86 */ s16 connectorAlpha[3];
-    /* 0x1CA8C */ s16 fileInfoAlpha[3];
-    /* 0x1CA92 */ s16 actionButtonAlpha[4]; // also contains the alphas for the confirm buttons
-    /* 0x1CA9A */ s16 optionButtonAlpha;
-    /* 0x1CA9C */ s16 nameEntryBoxAlpha;
-    /* 0x1CA9E */ s16 controlsAlpha;
-    /* 0x1CAA0 */ s16 emptyFileTextAlpha;
-    /* 0x1CAA2 */ s16 highlightColor[4];
-    /* 0x1CAAA */ s16 highlightPulseDir; // 0 fade out, 1 fade in
-    /* 0x1CAAC */ s16 unk_1CAAC; // initialized but never used
-    /* 0x1CAAE */ s16 confirmButtonTexIndices[2];
-    /* 0x1CAB2 */ s16 inputTimerX;
-    /* 0x1CAB4 */ s16 inputTimerY;
-    /* 0x1CAB6 */ s16 stickXDir;
-    /* 0x1CAB8 */ s16 stickYDir;
-    /* 0x1CABA */ s16 stickAdjX;
-    /* 0x1CABC */ s16 stickAdjY;
-    /* 0x1CABE */ s16 nameEntryBoxPosX;
-    /* 0x1CAC0 */ s16 windowPosX;
-    /* 0x1CAC4 */ f32 windowRot;
-    /* 0x1CAC8 */ s16 kbdButton; // only for buttons, not characters
-    /* 0x1CACA */ s16 charPage; // 0: hiragana, 1: katakana, 2: alphabet
-    /* 0x1CACC */ s16 charBgAlpha; // square shape the letter sits in
-    /* 0x1CACE */ s16 charIndex; // 0 - 64, top left to bottom right
-    /* 0x1CAD0 */ s16 kbdX; // (0, 0) is top left character
-    /* 0x1CAD2 */ s16 kbdY;
-    /* 0x1CAD4 */ s16 newFileNameCharCount;
-    /* 0x1CAD6 */ s16 unk_1CAD6[5];
-} FileSelectState; // size = 0x1CAE0
+    s16 buttonIndex;
+    s16 confirmButtonIndex; // 0: yes, 1: quit
+    s16 menuMode;
+    s16 configMode;
+    s16 prevConfigMode;
+    s16 nextConfigMode;
+    s16 selectMode;
+    s16 selectedFileIndex;
+    char unk_1CA48[0x2];
+    s16 fileNamesY[2];
+    s16 actionTimer;
+    s16 buttonYOffsets[5];
+    s16 copyDestFileIndex;
+    s16 warningLabel;
+    s16 warningButtonIndex;
+    s16 titleLabel;
+    s16 nextTitleLabel;
+    s16 windowColor[3];
+    s16 titleAlpha[2];
+    s16 windowAlpha;
+    s16 fileButtonAlpha[2];
+    s16 nameBoxAlpha[2];
+    s16 nameAlpha[2];
+    s16 connectorAlpha[2];
+    s16 fileInfoAlpha[2];
+    s16 actionButtonAlpha[4]; // also contains the alphas for the confirm buttons
+    s16 optionButtonAlpha;
+    s16 nameEntryBoxAlpha;
+    s16 controlsAlpha;
+    s16 emptyFileTextAlpha;
+    s16 highlightColor[4];
+    s16 highlightPulseDir; // 0 fade out, 1 fade in
+    s16 unk_1CAAC; // initialized but never used
+    s16 confirmButtonTexIndices[2];
+    s16 inputTimerX;
+    s16 inputTimerY;
+    s16 stickXDir;
+    s16 stickYDir;
+    s16 stickAdjX;
+    s16 stickAdjY;
+    s16 nameEntryBoxPosX;
+    s16 windowPosX;
+    f32 windowRot;
+    s16 kbdButton; // only for buttons, not characters
+    s16 charPage; // 0: hiragana, 1: katakana, 2: alphabet
+    s16 charBgAlpha; // square shape the letter sits in
+    s16 charIndex; // 0 - 64, top left to bottom right
+    s16 kbdX; // (0, 0) is top left character
+    s16 kbdY;
+    s16 newFileNameCharCount;
+    s16 unk_1CAD6[5];
+} FileSelectState;
 
 void FileSelect_Init(GameState* thisx);
 void FileSelect_Destroy(GameState* thisx);
diff --git a/include/hashtable.h b/include/hashtable.h
new file mode 100644
index 000000000..61fc509c9
--- /dev/null
+++ b/include/hashtable.h
@@ -0,0 +1,110 @@
+#pragma once
+// The MIT License (MIT)
+// Copyright (c) 2016 Peter Goldsborough
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy of
+// this software and associated documentation files (the "Software"), to deal in
+// the Software without restriction, including without limitation the rights to
+// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+// the Software, and to permit persons to whom the Software is furnished to do so,
+// subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+#ifndef HASHTABLE_H
+#define HASHTABLE_H
+
+#include <stddef.h>
+#include <stdbool.h>
+
+/****************** DEFINTIIONS ******************/
+
+#define HT_MINIMUM_CAPACITY 8
+#define HT_LOAD_FACTOR 5
+#define HT_MINIMUM_THRESHOLD (HT_MINIMUM_CAPACITY) * (HT_LOAD_FACTOR)
+
+#define HT_GROWTH_FACTOR 2
+#define HT_SHRINK_THRESHOLD ((double)1 / 4)
+
+#define HT_ERROR -1
+#define HT_SUCCESS 0
+
+#define HT_UPDATED 1
+#define HT_INSERTED 0
+
+#define HT_NOT_FOUND 0
+#define HT_FOUND 01
+
+#define HT_INITIALIZER {0, 0, 0, 0, 0, NULL, NULL, NULL};
+
+typedef int (*comparison_t)(void*, void*, size_t);
+typedef size_t (*hash_t)(void*, size_t);
+
+/****************** STRUCTURES ******************/
+
+typedef struct HTNode {
+	struct HTNode* next;
+	void* key;
+	void* value;
+
+} HTNode;
+
+typedef struct HashTable {
+	size_t size;
+	size_t threshold;
+	size_t capacity;
+
+	size_t key_size;
+	size_t value_size;
+
+	comparison_t compare;
+	hash_t hash;
+
+	HTNode** nodes;
+
+} HashTable;
+
+/****************** INTERFACE ******************/
+
+/* Setup */
+int ht_setup(HashTable* table,
+						 size_t key_size,
+						 size_t value_size,
+						 size_t capacity);
+
+int ht_copy(HashTable* first, HashTable* second);
+int ht_move(HashTable* first, HashTable* second);
+int ht_swap(HashTable* first, HashTable* second);
+
+/* Destructor */
+int ht_destroy(HashTable* table);
+
+int ht_insert(HashTable* table, void* key, void* value);
+
+int ht_contains(HashTable* table, void* key);
+void* ht_lookup(HashTable* table, void* key);
+const void* ht_const_lookup(const HashTable* table, void* key);
+
+#define HT_LOOKUP_AS(type, table_pointer, key_pointer) \
+	(*(type*)ht_lookup((table_pointer), (key_pointer)))
+
+int ht_erase(HashTable* table, void* key);
+int ht_clear(HashTable* table);
+
+int ht_is_empty(HashTable* table);
+bool ht_is_initialized(HashTable* table);
+
+int ht_reserve(HashTable* table, size_t minimum_capacity);
+
+void ht_iterate(HashTable* ht, void (*callback)(void* key, void* value));
+void ht_free(void* key, void* value);
+
+#endif /* HASHTABLE_H */
+
diff --git a/include/libc/string.h b/include/libc/string.h
index 3e2e6be59..24ef8656e 100644
--- a/include/libc/string.h
+++ b/include/libc/string.h
@@ -5,9 +5,12 @@
 
 char* strchr(const char*, int);
 size_t strlen(const char*);
+extern int strcmp(const char *s1, const char *s2);
+extern char* strcpy (char *dst, const char *src);
 
 void* memcpy(void*, const void*, size_t);
 void* memmove(void* dest, const void* src, size_t len);
 void* memset(void* dest, int val, size_t len);
+extern int memcmp(const void* s1, const void* s2, size_t n);
 
 #endif
diff --git a/include/libc64/malloc.h b/include/libc64/malloc.h
index 02540e353..15cc2d485 100644
--- a/include/libc64/malloc.h
+++ b/include/libc64/malloc.h
@@ -19,6 +19,7 @@ s32 SystemArena_IsInitialized(void);
 #define SYSTEM_ARENA_MALLOC(size, file, line) SystemArena_MallocDebug(size, file, line)
 #define SYSTEM_ARENA_MALLOC_R(size, file, line) SystemArena_MallocRDebug(size, file, line)
 #define SYSTEM_ARENA_FREE(size, file, line) SystemArena_FreeDebug(size, file, line)
+#define SYSTEM_ARENA_REALLOC(ptr, size, file, line) SystemArena_ReallocDebug(ptr, size, file, line)
 
 void* SystemArena_MallocDebug(u32 size, const char* file, int line);
 void* SystemArena_MallocRDebug(u32 size, const char* file, int line);
@@ -29,6 +30,7 @@ void SystemArena_Display(void);
 #define SYSTEM_ARENA_MALLOC(size, file, line) SystemArena_Malloc(size)
 #define SYSTEM_ARENA_MALLOC_R(size, file, line) SystemArena_MallocR(size)
 #define SYSTEM_ARENA_FREE(size, file, line) SystemArena_Free(size)
+#define SYSTEM_ARENA_REALLOC(ptr, size, file, line) SystemArena_Realloc(ptr, size)
 #endif
 
 extern Arena gSystemArena;
diff --git a/include/libc64/qrand.h b/include/libc64/qrand.h
index cc66d4f43..fa99bae26 100644
--- a/include/libc64/qrand.h
+++ b/include/libc64/qrand.h
@@ -4,10 +4,12 @@
 #include "ultra64.h"
 
 u32 Rand_Next(void);
+u32 Rand_Next_Mod(u32 mod);
 void Rand_Seed(u32 seed);
 f32 Rand_ZeroOne(void);
 void Rand_Seed_Variable(u32* rndNum, u32 seed);
 u32 Rand_Next_Variable(u32* rndNum);
+u32 Rand_Next_Mod_Variable(u32* rndNum, u32 mod);
 f32 Rand_ZeroOne_Variable(u32* rndNum);
 
 #if !PLATFORM_N64
diff --git a/include/randomizer_play.h b/include/randomizer_play.h
new file mode 100644
index 000000000..7a85c31a7
--- /dev/null
+++ b/include/randomizer_play.h
@@ -0,0 +1,183 @@
+#ifndef RANDOMIZER_PLAY_H
+#define RANDOMIZER_PLAY_H 1
+#include "z64item.h"
+#include "z64scene.h"
+
+typedef enum {
+    CHEST_MIDO_0,
+    CHEST_MIDO_1,
+    CHEST_MIDO_2,
+    CHEST_MIDO_3,
+    CHEST_KOKIRI_0,
+    CHEST_BOX_GAME_0,
+    CHEST_SHIELD_GRAVE_0,
+    CHEST_REDEAD_GRAVE_0,
+    CHEST_ROYAL_TOMB_0,
+    CHEST_DAMPE_0,
+    CHEST_MOUNTAIN_0,
+    CHEST_GORON_0,
+    CHEST_GORON_1,
+    CHEST_GORON_2,
+    CHEST_ZORA_0,
+    CHEST_VALLEY_0,
+    CHEST_FORTRESS_0,
+    CHEST_WASTELAND_0,
+    CHEST_GROTTOS_0,
+    CHEST_GROTTOS_1,
+    CHEST_GROTTOS_2,
+    CHEST_GROTTOS_3,
+    CHEST_GROTTOS_4,
+    CHEST_GROTTOS_5,
+    CHEST_GROTTOS_6,
+    CHEST_GROTTOS_7,
+    CHEST_GROTTOS_8,
+    CHEST_GROTTOS_9,
+    CHEST_GROTTOS_10,
+    CHEST_DEKU_0,
+    CHEST_DEKU_1,
+    CHEST_DEKU_2,
+    CHEST_DEKU_3,
+    CHEST_DEKU_4,
+    CHEST_DEKU_5,
+    CHEST_DODONGO_0,
+    CHEST_DODONGO_1,
+    CHEST_DODONGO_2,
+    CHEST_DODONGO_3,
+    CHEST_DODONGO_4,
+    CHEST_DODONGO_5,
+    CHEST_JABU_0,
+    CHEST_JABU_1,
+    CHEST_JABU_2,
+    CHEST_BOTW_0,
+    CHEST_BOTW_1,
+    CHEST_BOTW_2,
+    CHEST_BOTW_3,
+    CHEST_BOTW_4,
+    CHEST_BOTW_5,
+    CHEST_BOTW_6,
+    CHEST_BOTW_7,
+    CHEST_BOTW_8,
+    CHEST_BOTW_9,
+    CHEST_BOTW_10,
+    CHEST_BOTW_11,
+    CHEST_BOTW_12,
+    CHEST_FOREST_0,
+    CHEST_FOREST_1,
+    CHEST_FOREST_2,
+    CHEST_FOREST_3,
+    CHEST_FOREST_4,
+    CHEST_FOREST_5,
+    CHEST_FOREST_6,
+    CHEST_FOREST_7,
+    CHEST_FOREST_8,
+    CHEST_FOREST_9,
+    CHEST_FOREST_10,
+    CHEST_FOREST_11,
+    CHEST_FOREST_12,
+    CHEST_FIRE_0,
+    CHEST_FIRE_1,
+    CHEST_FIRE_2,
+    CHEST_FIRE_3,
+    CHEST_FIRE_4,
+    CHEST_FIRE_5,
+    CHEST_FIRE_6,
+    CHEST_FIRE_7,
+    CHEST_FIRE_8,
+    CHEST_FIRE_9,
+    CHEST_FIRE_10,
+    CHEST_FIRE_11,
+    CHEST_FIRE_12,
+    CHEST_FIRE_13,
+    CHEST_WATER_0,
+    CHEST_WATER_1,
+    CHEST_WATER_2,
+    CHEST_WATER_3,
+    CHEST_WATER_4,
+    CHEST_WATER_5,
+    CHEST_WATER_6,
+    CHEST_WATER_7,
+    CHEST_WATER_8,
+    CHEST_WATER_9,
+    CHEST_WATER_10,
+    CHEST_SHADOW_0,
+    CHEST_SHADOW_1,
+    CHEST_SHADOW_2,
+    CHEST_SHADOW_3,
+    CHEST_SHADOW_4,
+    CHEST_SHADOW_5,
+    CHEST_SHADOW_6,
+    CHEST_SHADOW_7,
+    CHEST_SHADOW_8,
+    CHEST_SHADOW_9,
+    CHEST_SHADOW_10,
+    CHEST_SHADOW_11,
+    CHEST_SHADOW_12,
+    CHEST_SHADOW_13,
+    CHEST_SHADOW_14,
+    CHEST_SHADOW_15,
+    CHEST_SPIRIT_0,
+    CHEST_SPIRIT_1,
+    CHEST_SPIRIT_2,
+    CHEST_SPIRIT_3,
+    CHEST_SPIRIT_4,
+    CHEST_SPIRIT_5,
+    CHEST_SPIRIT_6,
+    CHEST_SPIRIT_7,
+    CHEST_SPIRIT_8,
+    CHEST_SPIRIT_9,
+    CHEST_SPIRIT_10,
+    CHEST_SPIRIT_11,
+    CHEST_SPIRIT_12,
+    CHEST_SPIRIT_13,
+    CHEST_SPIRIT_14,
+    CHEST_SPIRIT_15,
+    CHEST_SPIRIT_16,
+    CHEST_SPIRIT_17,
+    CHEST_SPIRIT_18,
+    CHEST_ICE_18,
+    CHEST_ICE_0,
+    CHEST_ICE_1,
+    CHEST_ICE_2,
+    CHEST_GTG_0,
+    CHEST_GTG_1,
+    CHEST_GTG_2,
+    CHEST_GTG_3,
+    CHEST_GTG_4,
+    CHEST_GTG_5,
+    CHEST_GTG_6,
+    CHEST_GTG_7,
+    CHEST_GTG_8,
+    CHEST_GTG_9,
+    CHEST_GTG_10,
+    CHEST_GTG_11,
+    CHEST_GTG_12,
+    CHEST_GTG_13,
+    CHEST_GTG_14,
+    CHEST_GTG_15,
+    CHEST_GTG_16,
+    CHEST_GTG_17,
+    CHEST_GTG_18,
+    CHEST_GTG_19,
+    CHEST_GTG_20,
+    CHEST_GANON_0,
+    CHEST_GANON_1,
+    CHEST_GANON_2,
+    CHEST_GANON_3,
+    CHEST_GANON_4,
+    CHEST_GANON_5,
+    CHEST_GANON_6,
+    CHEST_GANON_7,
+    CHEST_GANON_8,
+    CHEST_GANON_9,
+    CHEST_GANON_10,
+    CHEST_GANON_11,
+    CHEST_GANON_12,
+    CHEST_GANON_13,
+    CHEST_GANON_14,
+    CHEST_VALID_0,
+    CHEST_MAX
+} RandomizerChestID;
+
+RandomizerChestID Randomizer_GetRandomizedChestContents(SceneID scene, u8 flag);
+
+#endif
diff --git a/include/randomizer_state.h b/include/randomizer_state.h
new file mode 100644
index 000000000..9336b43c4
--- /dev/null
+++ b/include/randomizer_state.h
@@ -0,0 +1,26 @@
+#ifndef RANDOMIZER_STATE_H
+#define RANDOMIZER_STATE_H
+
+#include "z64game.h"
+#include "z64play.h"
+
+typedef enum {
+    RM_RUNNING,
+    RM_FINISHING,
+    RM_FINISHED,
+    RM_ERROR,
+    RM_FINISHED_ERROR,
+} RandomizerMode;
+
+typedef struct RandomizerState {
+    GameState state;
+    View view;
+    SramContext sramCtx;
+    RandomizerMode mode;
+    bool threadStarted;
+} RandomizerState;;
+
+void Randomizer_Init(GameState *gameState);
+void Randomizer_Destroy(GameState *gameState);
+
+#endif
diff --git a/include/tables/gamestate_table.h b/include/tables/gamestate_table.h
index 280740fe2..60c573734 100644
--- a/include/tables/gamestate_table.h
+++ b/include/tables/gamestate_table.h
@@ -14,3 +14,4 @@
 /* 0x03 */ DEFINE_GAMESTATE_INTERNAL(Play, GAMESTATE_PLAY)
 /* 0x04 */ DEFINE_GAMESTATE(TitleSetup, GAMESTATE_TITLE_SETUP, opening)
 /* 0x05 */ DEFINE_GAMESTATE(FileSelect, GAMESTATE_FILE_SELECT, file_choose)
+/* 0x06 */ DEFINE_GAMESTATE(Randomizer, GAMESTATE_RANDOMIZER, randomizer)
diff --git a/include/translation.h b/include/translation.h
index 658332670..506b7a5b6 100644
--- a/include/translation.h
+++ b/include/translation.h
@@ -11,6 +11,6 @@
  * Note: This translation macro exists for quality of life purposes.
  *       The original game would not have had a macro like this.
  */
-#define T(jp, en) jp
+#define T(jp, en) en
 
 #endif
diff --git a/include/vector.h b/include/vector.h
new file mode 100644
index 000000000..78874ef33
--- /dev/null
+++ b/include/vector.h
@@ -0,0 +1,139 @@
+// The MIT License (MIT)
+// Copyright (c) 2016 Peter Goldsborough
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy of
+// this software and associated documentation files (the "Software"), to deal in
+// the Software without restriction, including without limitation the rights to
+// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+// the Software, and to permit persons to whom the Software is furnished to do so,
+// subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+#ifndef VECTOR_H
+#define VECTOR_H 1
+
+#include <stddef.h>
+#include <stdbool.h>
+
+#define VECTOR_INIT_CAPACITY 10
+
+/***** DEFINITIONS *****/
+
+#define VECTOR_MINIMUM_CAPACITY 2
+#define VECTOR_GROWTH_FACTOR 2
+#define VECTOR_SHRINK_THRESHOLD (1 / 4)
+
+#define VECTOR_ERROR -1
+#define VECTOR_SUCCESS 0
+
+#define VECTOR_UNINITIALIZED NULL
+#define VECTOR_INITIALIZER \
+	{ 0, 0, 0, VECTOR_UNINITIALIZED }
+
+/***** STRUCTURES *****/
+
+typedef struct Vector {
+	size_t size;
+	size_t capacity;
+	size_t element_size;
+
+	void* data;
+} Vector;
+
+typedef struct Iterator {
+	void* pointer;
+	size_t element_size;
+} Iterator;
+
+/***** METHODS *****/
+
+/* Constructor */
+int vector_setup(Vector* vector, size_t capacity, size_t element_size);
+
+/* Copy Constructor */
+int vector_copy(Vector* destination, Vector* source);
+
+/* Copy Assignment */
+int vector_copy_assign(Vector* destination, Vector* source);
+
+/* Move Constructor */
+int vector_move(Vector* destination, Vector* source);
+
+/* Move Assignment */
+int vector_move_assign(Vector* destination, Vector* source);
+
+int vector_swap(Vector* destination, Vector* source);
+
+/* Destructor */
+int vector_destroy(Vector* vector);
+
+/* Insertion */
+int vector_push_back(Vector* vector, void* element);
+int vector_push_front(Vector* vector, void* element);
+int vector_insert(Vector* vector, size_t index, void* element);
+int vector_assign(Vector* vector, size_t index, void* element);
+
+/* Deletion */
+int vector_pop_back(Vector* vector);
+int vector_pop_front(Vector* vector);
+int vector_erase(Vector* vector, size_t index);
+int vector_clear(Vector* vector);
+
+/* Lookup */
+void* vector_get(Vector* vector, size_t index);
+const void* vector_const_get(const Vector* vector, size_t index);
+void* vector_front(Vector* vector);
+void* vector_back(Vector* vector);
+#define VECTOR_GET_AS(type, vector_pointer, index) \
+	*((type*)vector_get((vector_pointer), (index)))
+
+/* Information */
+bool vector_is_initialized(const Vector* vector);
+size_t vector_byte_size(const Vector* vector);
+size_t vector_free_space(const Vector* vector);
+bool vector_is_empty(const Vector* vector);
+
+/* Memory management */
+int vector_resize(Vector* vector, size_t new_size);
+int vector_reserve(Vector* vector, size_t minimum_capacity);
+int vector_shrink_to_fit(Vector* vector);
+
+/* Iterators */
+Iterator vector_begin(Vector* vector);
+Iterator vector_end(Vector* vector);
+Iterator vector_iterator(Vector* vector, size_t index);
+
+void* iterator_get(Iterator* iterator);
+#define ITERATOR_GET_AS(type, iterator) *((type*)iterator_get((iterator)))
+
+int iterator_erase(Vector* vector, Iterator* iterator);
+
+void iterator_increment(Iterator* iterator);
+void iterator_decrement(Iterator* iterator);
+
+void* iterator_next(Iterator* iterator);
+void* iterator_previous(Iterator* iterator);
+
+bool iterator_equals(Iterator* first, Iterator* second);
+bool iterator_is_before(Iterator* first, Iterator* second);
+bool iterator_is_after(Iterator* first, Iterator* second);
+
+size_t iterator_index(Vector* vector, Iterator* iterator);
+void vector_shuffle(Vector* src);
+
+#define VECTOR_FOR_EACH(vector_pointer, iterator_name)           \
+	for (Iterator(iterator_name) = vector_begin((vector_pointer)), \
+			end = vector_end((vector_pointer));                        \
+			 !iterator_equals(&(iterator_name), &end);                 \
+			 iterator_increment(&(iterator_name)))
+
+#endif /* VECTOR_H */
diff --git a/include/versions.h b/include/versions.h
index 620b27999..b5e786798 100644
--- a/include/versions.h
+++ b/include/versions.h
@@ -1,6 +1,8 @@
 #ifndef VERSIONS_H
 #define VERSIONS_H
 
+#include "region.h"
+
 // OOT versions in build order
 #define NTSC_1_0       1
 #define NTSC_1_1       2
@@ -41,7 +43,7 @@
 #endif
 
 // Macro for constants that change in 50 Hz N64 PAL versions.
-#if !OOT_PAL_N64
+#if OOT_REGION != REGION_EU
 #define FRAMERATE_CONST(value60Hz, value50Hz) (value60Hz)
 #else
 #define FRAMERATE_CONST(value60Hz, value50Hz) (value50Hz)
diff --git a/include/z64cutscene.h b/include/z64cutscene.h
index f8aed368d..15086e187 100644
--- a/include/z64cutscene.h
+++ b/include/z64cutscene.h
@@ -499,7 +499,7 @@ typedef struct CutsceneCameraMove {
 } CutsceneCameraMove; // size = 0xC
 
 typedef struct CutsceneContext {
-    /* 0x00 */ char  unk_00[0x4];
+    /* 0x00 */ char  unk_00[0x3];
     /* 0x04 */ void* script;
     /* 0x08 */ u8 state;
     /* 0x0C */ f32 timer;
@@ -513,6 +513,7 @@ typedef struct CutsceneContext {
     /* 0x20 */ CutsceneCameraPoint* camEyePoints;
     /* 0x24 */ CsCmdActorCue* playerCue;
     /* 0x28 */ CsCmdActorCue* actorCues[10]; // "npcdemopnt"
+    bool skippable;
 } CutsceneContext; // size = 0x50
 
 extern u8 gUseCutsceneCam;
diff --git a/include/z64interface.h b/include/z64interface.h
index bfa3bffeb..f133dc175 100644
--- a/include/z64interface.h
+++ b/include/z64interface.h
@@ -65,6 +65,7 @@ typedef enum DoAction {
     /* 0x1A */ DO_ACTION_6,
     /* 0x1B */ DO_ACTION_7,
     /* 0x1C */ DO_ACTION_8,
+    DO_ACTION_SKIP,
     /* 0x1D */ DO_ACTION_MAX
 } DoAction;
 
diff --git a/include/z64item.h b/include/z64item.h
index 60344f326..0f9ff79db 100644
--- a/include/z64item.h
+++ b/include/z64item.h
@@ -308,6 +308,39 @@ typedef enum ItemID {
     /* 0x99 */ ITEM_DEKU_STICK_UPGRADE_30,
     /* 0x9A */ ITEM_DEKU_NUT_UPGRADE_30,
     /* 0x9B */ ITEM_DEKU_NUT_UPGRADE_40,
+    ITEM_SMALL_KEY_DEKU_TREE, // unused
+    ITEM_SMALL_KEY_DODONGOS_CAVERN, // unused
+    ITEM_SMALL_KEY_JABU_JABU, // unused
+    ITEM_SMALL_KEY_FOREST_TEMPLE,
+    ITEM_SMALL_KEY_FIRE_TEMPLE,
+    ITEM_SMALL_KEY_WATER_TEMPLE,
+    ITEM_SMALL_KEY_SPIRIT_TEMPLE,
+    ITEM_SMALL_KEY_SHADOW_TEMPLE,
+    ITEM_SMALL_KEY_BOTTOM_OF_THE_WELL,
+    ITEM_SMALL_KEY_ICE_CAVERN, // unused
+    ITEM_SMALL_KEY_GANONS_CASTLE,
+    ITEM_SMALL_KEY_GERUDO_TRAINING_GROUND,
+    ITEM_DUNGEON_BOSS_KEY_DEKU_TREE, // unused
+    ITEM_DUNGEON_BOSS_KEY_DODONGOS_CAVERN, // unused
+    ITEM_DUNGEON_BOSS_KEY_JABU_JABU, // unused
+    ITEM_DUNGEON_BOSS_KEY_FOREST_TEMPLE,
+    ITEM_DUNGEON_BOSS_KEY_FIRE_TEMPLE,
+    ITEM_DUNGEON_BOSS_KEY_WATER_TEMPLE,
+    ITEM_DUNGEON_BOSS_KEY_SPIRIT_TEMPLE,
+    ITEM_DUNGEON_BOSS_KEY_SHADOW_TEMPLE,
+    ITEM_DUNGEON_BOSS_KEY_BOTTOM_OF_THE_WELL, // unused
+    ITEM_DUNGEON_BOSS_KEY_ICE_CAVERN, // unused
+    ITEM_DUNGEON_BOSS_KEY_GANONS_CASTLE,
+    ITEM_DUNGEON_BOSS_KEY_GERUDO_TRAINING_GROUND, // unused
+    EVENT_DEFEAT_GOHMA,
+    EVENT_DEFEAT_KING_DODONGO,
+    EVENT_DEFEAT_BARINADE,
+    EVENT_DEFEAT_PHANTOM_GANON,
+    EVENT_DEFEAT_VOLVAGIA,
+    EVENT_DEFEAT_MORPHA,
+    EVENT_DEFEAT_TWINROVA,
+    EVENT_DEFEAT_BONGO_BONGO,
+    EVENT_TRIFORCE = 0xFB,
     /* 0xFC */ ITEM_SWORD_CS = 0xFC,
     /* 0xFE */ ITEM_NONE_FE = 0xFE,
     /* 0xFF */ ITEM_NONE = 0xFF
diff --git a/include/z64object.h b/include/z64object.h
index 016eda00d..acd80eebf 100644
--- a/include/z64object.h
+++ b/include/z64object.h
@@ -39,6 +39,7 @@ typedef enum ObjectId {
 
 void Object_InitContext(struct PlayState* play, ObjectContext* objectCtx);
 void Object_UpdateEntries(ObjectContext* objectCtx);
+s32 Object_SpawnTemporary(ObjectContext* objectCtx, s16 objectId);
 s32 Object_GetSlot(ObjectContext* objectCtx, s16 objectId);
 s32 Object_IsLoaded(ObjectContext* objectCtx, s32 slot);
 void func_800981B8(ObjectContext* objectCtx);
diff --git a/include/z64save.h b/include/z64save.h
index 71b141405..0c07f728b 100644
--- a/include/z64save.h
+++ b/include/z64save.h
@@ -1,6 +1,7 @@
 #ifndef Z64SAVE_H
 #define Z64SAVE_H
 
+#include "randomizer_play.h"
 #include "ultra64.h"
 #include "versions.h"
 #include "z64inventory.h"
@@ -23,6 +24,11 @@ typedef enum Language {
     /*   */ LANGUAGE_MAX
 } Language;
 
+typedef enum QuicktextSetting {
+    QUICKTEXT_SETTING_OFF,
+    QUICKTEXT_SETTING_ON,
+} QuicktextSetting;
+
 // `_FORCE` means that this request will respond to `forceRisingButtonAlphas`.
 // If set, the buttons will also raise alphas but will also account for disabled buttons
 
@@ -213,6 +219,15 @@ typedef enum WorldMapArea {
     /* 22 */ WORLD_MAP_AREA_MAX // also grottos and fairy's/great fairy's fountains (scenes with varying locations)
 } WorldMapArea;
 
+// randomizer save data
+typedef struct SaveRandomizerData {
+    bool initialized;
+    bool generated;
+    u32 seed;
+    bool shuffleChests;
+    GetItemID chestContents[CHEST_MAX];
+} SaveRandomizerData;
+
 // offsets in SavePlayerData and SaveContext/Save
 typedef struct SavePlayerData {
     /* 0x00  0x001C */ char newf[6]; // string "ZELDAZ"
@@ -275,6 +290,7 @@ typedef struct Save {
     /* 0x14 */ s32 totalDays;
     /* 0x18 */ s32 bgsDayCount; // increments with totalDays, can be cleared with `Environment_ClearBgsDayCount`
     /* 0x1C */ SaveInfo info; // "information"
+    SaveRandomizerData randomizer;
 } Save;
 
 typedef struct SaveContext {
@@ -340,6 +356,7 @@ typedef struct SaveContext {
     /* 0x1420 */ s16 worldMapArea;
     /* 0x1422 */ s16 sunsSongState; // controls the effects of suns song
     /* 0x1424 */ s16 healthAccumulator;
+    u8 quicktextSetting;
 } SaveContext; // size = 0x1428
 
 typedef enum ButtonStatus {
@@ -404,7 +421,9 @@ typedef enum SceneLayer {
 
 typedef enum LinkAge {
     /* 0 */ LINK_AGE_ADULT,
-    /* 1 */ LINK_AGE_CHILD
+    /* 1 */ LINK_AGE_CHILD,
+    LINK_AGE_BOTH,
+    LINK_AGE_EITHER,
 } LinkAge;
 
 
diff --git a/include/z64sram.h b/include/z64sram.h
index f1d05b777..11456483d 100644
--- a/include/z64sram.h
+++ b/include/z64sram.h
@@ -11,12 +11,13 @@ typedef struct SramContext {
 } SramContext; // size = 0x4
 
 #define SRAM_SIZE 0x8000
-#define SRAM_HEADER_SIZE 0x10
+#define SRAM_HEADER_SIZE 0x11
 
 typedef enum SramHeaderField {
     /* 0x00 */ SRAM_HEADER_SOUND,
     /* 0x01 */ SRAM_HEADER_Z_TARGET,
     /* 0x02 */ SRAM_HEADER_LANGUAGE,
+               SRAM_HEADER_QUICKTEXT,
     /* 0x03 */ SRAM_HEADER_MAGIC // must be the value in `sSramDefaultHeader` for save to be considered valid
 } SramHeaderField;
 
diff --git a/include/z64thread.h b/include/z64thread.h
index c4ab827b4..5fbc0209f 100644
--- a/include/z64thread.h
+++ b/include/z64thread.h
@@ -14,6 +14,7 @@
 #define THREAD_ID_AUDIOMGR   10
 #define THREAD_ID_DMAMGR     18
 #define THREAD_ID_IRQMGR     19
+#define THREAD_ID_RANDOMIZER 20
 
 #define THREAD_PRI_IDLE_INIT    10
 #define THREAD_PRI_MAIN_INIT    10
diff --git a/include/zelda_arena.h b/include/zelda_arena.h
index cf6740657..9c08874de 100644
--- a/include/zelda_arena.h
+++ b/include/zelda_arena.h
@@ -15,6 +15,7 @@ void ZeldaArena_Check(void);
 void ZeldaArena_Init(void* start, u32 size);
 void ZeldaArena_Cleanup(void);
 s32 ZeldaArena_IsInitialized(void);
+size_t ZeldaArena_MaxAllocated(void);
 
 #if DEBUG_FEATURES
 void ZeldaArena_CheckPointer(void* ptr, u32 size, const char* name, const char* action);
diff --git a/spec/spec b/spec/spec
index 60437c4bf..af2dea42c 100644
--- a/spec/spec
+++ b/spec/spec
@@ -117,8 +117,8 @@ beginseg
     // Functions that GCC-compiled code may depend on, placed in boot so they will always be loaded
 #ifdef COMPILER_GCC
     include "$(BUILD_DIR)/src/libultra/libc/string.o"
-    include "$(BUILD_DIR)/src/libc/memset.o"
     include "$(BUILD_DIR)/src/libc/memmove.o"
+    include "$(BUILD_DIR)/src/libultra/bb/sa/common.o"
     include "$(BUILD_DIR)/src/gcc_fix/missing_gcc_functions.o"
 #endif
 
@@ -521,6 +521,7 @@ beginseg
 #if PLATFORM_IQUE
     include "*$(BUILD_DIR)/code_bss_1.o"
 #endif
+    include "$(BUILD_DIR)/src/code/randomizer_play.o"
     include "$(BUILD_DIR)/src/code/z_en_a_keep.o"
     include "$(BUILD_DIR)/src/code/z_en_item00.o"
     include "$(BUILD_DIR)/src/code/z_eff_blure.o"
@@ -635,6 +636,8 @@ beginseg
     include "$(BUILD_DIR)/src/code/graph.o"
     include "$(BUILD_DIR)/src/code/gfxalloc.o"
     include "$(BUILD_DIR)/src/code/listalloc.o"
+    include "$(BUILD_DIR)/src/code/vector.o"
+    include "$(BUILD_DIR)/src/code/hashtable.o"
     include "$(BUILD_DIR)/src/code/main.o"
     include "$(BUILD_DIR)/src/code/padmgr.o"
     include "$(BUILD_DIR)/src/code/sched.o"
@@ -781,13 +784,11 @@ beginseg
 #if PLATFORM_N64
     include "$(BUILD_DIR)/src/libc/sqrt.o"
     include "$(BUILD_DIR)/src/libc/fmodf.o"
-    include "$(BUILD_DIR)/src/libc/memset.o"
     include "$(BUILD_DIR)/src/libc/memmove.o"
 #elif PLATFORM_GC
     include "$(BUILD_DIR)/src/libc/sqrt.o"
     include "$(BUILD_DIR)/src/libc/fabsf.o"
     include "$(BUILD_DIR)/src/libc/fmodf.o"
-    include "$(BUILD_DIR)/src/libc/memset.o"
     include "$(BUILD_DIR)/src/libc/memmove.o"
 #elif PLATFORM_IQUE
     include "$(BUILD_DIR)/src/libc/fmodf.o"
@@ -934,12 +935,32 @@ beginseg
     name "ovl_file_choose"
     compress
     include "$(BUILD_DIR)/src/overlays/gamestates/ovl_file_choose/z_file_nameset_data.o"
+    include "$(BUILD_DIR)/src/overlays/gamestates/ovl_file_choose/z_file_randomizer.o"
     include "$(BUILD_DIR)/src/overlays/gamestates/ovl_file_choose/z_file_copy_erase.o"
     include "$(BUILD_DIR)/src/overlays/gamestates/ovl_file_choose/z_file_nameset.o"
     include "$(BUILD_DIR)/src/overlays/gamestates/ovl_file_choose/z_file_choose.o"
     include "$(BUILD_DIR)/src/overlays/gamestates/ovl_file_choose/ovl_file_choose_reloc.o"
 endseg
 
+beginseg
+    name "ovl_randomizer"
+    compress
+    include "$(BUILD_DIR)/src/overlays/gamestates/ovl_randomizer/r_ast.o"
+    include "$(BUILD_DIR)/src/overlays/gamestates/ovl_randomizer/r_fill.o"
+    include "$(BUILD_DIR)/src/overlays/gamestates/ovl_randomizer/r_entrance.o"
+    include "$(BUILD_DIR)/src/overlays/gamestates/ovl_randomizer/r_graph.o"
+    include "$(BUILD_DIR)/src/overlays/gamestates/ovl_randomizer/r_item.o"
+    include "$(BUILD_DIR)/src/overlays/gamestates/ovl_randomizer/r_item_info.o"
+    include "$(BUILD_DIR)/src/overlays/gamestates/ovl_randomizer/r_location.o"
+    include "$(BUILD_DIR)/src/overlays/gamestates/ovl_randomizer/r_region.o"
+    include "$(BUILD_DIR)/src/overlays/gamestates/ovl_randomizer/r_search.o"
+    include "$(BUILD_DIR)/src/overlays/gamestates/ovl_randomizer/r_state.o"
+    include "$(BUILD_DIR)/src/overlays/gamestates/ovl_randomizer/r_tables.o"
+    include "$(BUILD_DIR)/src/overlays/gamestates/ovl_randomizer/r_thread.o"
+    include "$(BUILD_DIR)/src/overlays/gamestates/ovl_randomizer/r_world.o"
+    include "$(BUILD_DIR)/src/overlays/gamestates/ovl_randomizer/ovl_randomizer_reloc.o"
+endseg
+
 beginseg
     name "ovl_kaleido_scope"
     compress
diff --git a/src/audio/internal/load.c b/src/audio/internal/load.c
index f723e5b83..d5b4ad0ae 100644
--- a/src/audio/internal/load.c
+++ b/src/audio/internal/load.c
@@ -1295,7 +1295,7 @@ void AudioLoad_Init(void* heap, u32 heapSize) {
     }
 
     // 1000 is a conversion from seconds to milliseconds
-#if !OOT_PAL_N64
+#if !OOT_PAL_N64 || OOT_REGION != REGION_EU
     switch (osTvType) {
         case OS_TV_PAL:
             gAudioCtx.maxTempoTvTypeFactors = 1000 * REFRESH_RATE_DEVIATION_PAL / REFRESH_RATE_PAL;
diff --git a/src/boot/build.c b/src/boot/build.c
index 035e685db..0b380cbda 100644
--- a/src/boot/build.c
+++ b/src/boot/build.c
@@ -4,4 +4,5 @@
 
 const char gBuildCreator[] = BUILD_CREATOR;
 const char gBuildDate[] = BUILD_DATE " " BUILD_TIME;
+const char gBuildVersion[] = BUILD_VERSION;
 const char gBuildMakeOption[] = "";
diff --git a/src/boot/idle.c b/src/boot/idle.c
index 743219d94..ceb3a87b4 100644
--- a/src/boot/idle.c
+++ b/src/boot/idle.c
@@ -113,7 +113,7 @@ void Idle_ThreadEntry(void* arg) {
 #endif
             break;
     }
-#elif !OOT_PAL_N64
+#elif !OOT_PAL_N64 || OOT_REGION != REGION_EU
     // 60 Hz only (GameCube and NTSC N64)
     switch (osTvType) {
         case OS_TV_PAL:
diff --git a/src/code/fault_n64.c b/src/code/fault_n64.c
index 75fc704b9..0b05a1117 100644
--- a/src/code/fault_n64.c
+++ b/src/code/fault_n64.c
@@ -753,6 +753,7 @@ void Fault_ProcessClients(void) {
 void Fault_ThreadEntry(void* arg0) {
     OSMesg msg;
     OSThread* faultedThread;
+    gFaultMsgId = 0;
 
     osSetEventMesg(OS_EVENT_CPU_BREAK, &gFaultMgr.queue, FAULT_MSG_CPU_BREAK);
     osSetEventMesg(OS_EVENT_FAULT, &gFaultMgr.queue, FAULT_MSG_FAULT);
@@ -788,7 +789,7 @@ void Fault_ThreadEntry(void* arg0) {
         }
         Fault_SleepImpl(500);
         Fault_DrawCornerRecRed();
-        Fault_WaitForButtonCombo();
+        //Fault_WaitForButtonCombo();
         do {
             func_800AF558();
             Fault_PrintThreadContext(faultedThread);
@@ -836,7 +837,7 @@ NORETURN void Fault_AddHungupAndCrashImpl(const char* exp1, const char* exp2) {
         Fault_SleepImpl(1000);
     }
     Fault_SleepImpl(500);
-    Fault_WaitForButtonCombo();
+    // Fault_WaitForButtonCombo();
     do {
         func_800AF558();
         Fault_DrawRecBlack(22, 16, 276, 34);
diff --git a/src/code/graph.c b/src/code/graph.c
index 86543cc50..0354af47d 100644
--- a/src/code/graph.c
+++ b/src/code/graph.c
@@ -10,6 +10,7 @@
 #include "file_select_state.h"
 #include "line_numbers.h"
 #include "map_select_state.h"
+#include "randomizer_state.h"
 #include "prenmi_buff.h"
 #include "prenmi_state.h"
 #include "printf.h"
diff --git a/src/code/hashtable.c b/src/code/hashtable.c
new file mode 100644
index 000000000..dbcf4e127
--- /dev/null
+++ b/src/code/hashtable.c
@@ -0,0 +1,495 @@
+// The MIT License (MIT)
+// Copyright (c) 2016 Peter Goldsborough
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy of
+// this software and associated documentation files (the "Software"), to deal in
+// the Software without restriction, including without limitation the rights to
+// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+// the Software, and to permit persons to whom the Software is furnished to do so,
+// subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "hashtable.h"
+
+#include "zelda_arena.h"
+
+void _ht_int_swap(size_t* first, size_t* second);
+void _ht_pointer_swap(void** first, void** second);
+
+size_t _ht_default_hash(void* key, size_t key_size);
+int _ht_default_compare(void* first_key, void* second_key, size_t key_size);
+
+size_t _ht_hash(const HashTable* table, void* key);
+bool _ht_equal(const HashTable* table, void* first_key, void* second_key);
+
+bool _ht_should_grow(HashTable* table);
+bool _ht_should_shrink(HashTable* table);
+
+HTNode* _ht_create_node(HashTable* table, void* key, void* value, HTNode* next);
+int _ht_push_front(HashTable* table, size_t index, void* key, void* value);
+void _ht_destroy_node(HTNode* node);
+
+int _ht_adjust_capacity(HashTable* table);
+int _ht_allocate(HashTable* table, size_t capacity);
+int _ht_resize(HashTable* table, size_t new_capacity);
+void _ht_rehash(HashTable* table, HTNode** old, size_t old_capacity);
+
+int ht_setup(HashTable* table,
+						 size_t key_size,
+						 size_t value_size,
+						 size_t capacity) {
+	assert(table != NULL);
+
+	if (table == NULL) return HT_ERROR;
+
+	if (capacity < HT_MINIMUM_CAPACITY) {
+		capacity = HT_MINIMUM_CAPACITY;
+	}
+
+	if (_ht_allocate(table, capacity) == HT_ERROR) {
+		return HT_ERROR;
+	}
+
+	table->key_size = key_size;
+	table->value_size = value_size;
+	table->hash = _ht_default_hash;
+	table->compare = _ht_default_compare;
+	table->size = 0;
+
+	return HT_SUCCESS;
+}
+
+int ht_copy(HashTable* first, HashTable* second) {
+	size_t chain;
+	HTNode* node;
+
+	assert(first != NULL);
+	assert(ht_is_initialized(second));
+
+	if (first == NULL) return HT_ERROR;
+	if (!ht_is_initialized(second)) return HT_ERROR;
+
+	if (_ht_allocate(first, second->capacity) == HT_ERROR) {
+		return HT_ERROR;
+	}
+
+	first->key_size = second->key_size;
+	first->value_size = second->value_size;
+	first->hash = second->hash;
+	first->compare = second->compare;
+	first->size = second->size;
+
+	for (chain = 0; chain < second->capacity; ++chain) {
+		for (node = second->nodes[chain]; node; node = node->next) {
+			if (_ht_push_front(first, chain, node->key, node->value) == HT_ERROR) {
+				return HT_ERROR;
+			}
+		}
+	}
+
+	return HT_SUCCESS;
+}
+
+int ht_move(HashTable* first, HashTable* second) {
+	assert(first != NULL);
+	assert(ht_is_initialized(second));
+
+	if (first == NULL) return HT_ERROR;
+	if (!ht_is_initialized(second)) return HT_ERROR;
+
+	*first = *second;
+	second->nodes = NULL;
+
+	return HT_SUCCESS;
+}
+
+int ht_swap(HashTable* first, HashTable* second) {
+	assert(ht_is_initialized(first));
+	assert(ht_is_initialized(second));
+
+	if (!ht_is_initialized(first)) return HT_ERROR;
+	if (!ht_is_initialized(second)) return HT_ERROR;
+
+	_ht_int_swap(&first->key_size, &second->key_size);
+	_ht_int_swap(&first->value_size, &second->value_size);
+	_ht_int_swap(&first->size, &second->size);
+	_ht_pointer_swap((void**)&first->hash, (void**)&second->hash);
+	_ht_pointer_swap((void**)&first->compare, (void**)&second->compare);
+	_ht_pointer_swap((void**)&first->nodes, (void**)&second->nodes);
+
+	return HT_SUCCESS;
+}
+
+int ht_destroy(HashTable* table) {
+	HTNode* node;
+	HTNode* next;
+	size_t chain;
+
+	assert(ht_is_initialized(table));
+	if (!ht_is_initialized(table)) return HT_ERROR;
+
+	for (chain = 0; chain < table->capacity; ++chain) {
+		node = table->nodes[chain];
+		while (node) {
+			next = node->next;
+			_ht_destroy_node(node);
+			node = next;
+		}
+	}
+
+	ZELDA_ARENA_FREE(table->nodes, __FILE_NAME__, __LINE__);
+
+	return HT_SUCCESS;
+}
+
+int ht_insert(HashTable* table, void* key, void* value) {
+	size_t index;
+	HTNode* node;
+
+	assert(ht_is_initialized(table));
+	assert(key != NULL);
+
+	if (!ht_is_initialized(table)) return HT_ERROR;
+	if (key == NULL) return HT_ERROR;
+
+	if (_ht_should_grow(table)) {
+		_ht_adjust_capacity(table);
+	}
+
+	index = _ht_hash(table, key);
+	for (node = table->nodes[index]; node; node = node->next) {
+		if (_ht_equal(table, key, node->key)) {
+			memcpy(node->value, value, table->value_size);
+			return HT_UPDATED;
+		}
+	}
+
+	if (_ht_push_front(table, index, key, value) == HT_ERROR) {
+		return HT_ERROR;
+	}
+
+	++table->size;
+
+	return HT_INSERTED;
+}
+
+int ht_contains(HashTable* table, void* key) {
+	size_t index;
+	HTNode* node;
+
+	assert(ht_is_initialized(table));
+	assert(key != NULL);
+
+	if (!ht_is_initialized(table)) return HT_ERROR;
+	if (key == NULL) return HT_ERROR;
+
+	index = _ht_hash(table, key);
+	for (node = table->nodes[index]; node; node = node->next) {
+		if (_ht_equal(table, key, node->key)) {
+			return HT_FOUND;
+		}
+	}
+
+	return HT_NOT_FOUND;
+}
+
+void* ht_lookup(HashTable* table, void* key) {
+	HTNode* node;
+	size_t index;
+
+	assert(table != NULL);
+	assert(key != NULL);
+
+	if (table == NULL) return NULL;
+	if (key == NULL) return NULL;
+
+	index = _ht_hash(table, key);
+	for (node = table->nodes[index]; node; node = node->next) {
+		if (_ht_equal(table, key, node->key)) {
+			return node->value;
+		}
+	}
+
+	return NULL;
+}
+
+const void* ht_const_lookup(const HashTable* table, void* key) {
+	const HTNode* node;
+	size_t index;
+
+	assert(table != NULL);
+	assert(key != NULL);
+
+	if (table == NULL) return NULL;
+	if (key == NULL) return NULL;
+
+	index = _ht_hash(table, key);
+	for (node = table->nodes[index]; node; node = node->next) {
+		if (_ht_equal(table, key, node->key)) {
+			return node->value;
+		}
+	}
+
+	return NULL;
+}
+
+int ht_erase(HashTable* table, void* key) {
+	HTNode* node;
+	HTNode* previous;
+	size_t index;
+
+	assert(table != NULL);
+	assert(key != NULL);
+
+	if (table == NULL) return HT_ERROR;
+	if (key == NULL) return HT_ERROR;
+
+	index = _ht_hash(table, key);
+	node = table->nodes[index];
+
+	for (previous = NULL; node; previous = node, node = node->next) {
+		if (_ht_equal(table, key, node->key)) {
+			if (previous) {
+				previous->next = node->next;
+			} else {
+				table->nodes[index] = node->next;
+			}
+
+			_ht_destroy_node(node);
+			--table->size;
+
+			if (_ht_should_shrink(table)) {
+				if (_ht_adjust_capacity(table) == HT_ERROR) {
+					return HT_ERROR;
+				}
+			}
+
+			return HT_SUCCESS;
+		}
+	}
+
+	return HT_NOT_FOUND;
+}
+
+int ht_clear(HashTable* table) {
+	assert(table != NULL);
+	assert(table->nodes != NULL);
+
+	if (table == NULL) return HT_ERROR;
+	if (table->nodes == NULL) return HT_ERROR;
+
+	ht_destroy(table);
+	_ht_allocate(table, HT_MINIMUM_CAPACITY);
+	table->size = 0;
+
+	return HT_SUCCESS;
+}
+
+int ht_is_empty(HashTable* table) {
+	assert(table != NULL);
+	if (table == NULL) return HT_ERROR;
+	return table->size == 0;
+}
+
+bool ht_is_initialized(HashTable* table) {
+	return table != NULL && table->nodes != NULL;
+}
+
+int ht_reserve(HashTable* table, size_t minimum_capacity) {
+	assert(ht_is_initialized(table));
+	if (!ht_is_initialized(table)) return HT_ERROR;
+
+	/*
+	 * We expect the "minimum capacity" to be in elements, not in array indices.
+	 * This encapsulates the design.
+	 */
+	if (minimum_capacity > table->threshold) {
+		return _ht_resize(table, minimum_capacity / HT_LOAD_FACTOR);
+	}
+
+	return HT_SUCCESS;
+}
+
+void ht_iterate(HashTable* ht, void (*callback)(void* key, void* value)) {
+	for(size_t chain = 0; chain < ht->capacity; chain++) {
+		HTNode* node = ht->nodes[chain];
+
+		while(node) {
+			callback(node->key, node->value);
+			node = node->next;
+		}
+	}
+}
+
+void ht_free(void* key, void* value) {
+    if (key == NULL) {
+        return;
+    }
+    ZELDA_ARENA_FREE(value, __FILE_NAME__, __LINE__);
+}
+
+/****************** PRIVATE ******************/
+
+void _ht_int_swap(size_t* first, size_t* second) {
+	size_t temp = *first;
+	*first = *second;
+	*second = temp;
+}
+
+void _ht_pointer_swap(void** first, void** second) {
+	void* temp = *first;
+	*first = *second;
+	*second = temp;
+}
+
+int _ht_default_compare(void* first_key, void* second_key, size_t key_size) {
+	return memcmp(first_key, second_key, key_size);
+}
+
+size_t _ht_default_hash(void* raw_key, size_t key_size) {
+	// djb2 string hashing algorithm
+	// sstp://www.cse.yorku.ca/~oz/hash.ssml
+	size_t byte;
+	size_t hash = 5381;
+	char* key = raw_key;
+
+	for (byte = 0; byte < key_size; ++byte) {
+		// (hash << 5) + hash = hash * 33
+		hash = ((hash << 5) + hash) ^ key[byte];
+	}
+
+	return hash;
+}
+
+size_t _ht_hash(const HashTable* table, void* key) {
+#ifdef HT_USING_POWER_OF_TWO
+	return table->hash(key, table->key_size) & table->capacity;
+#else
+	return table->hash(key, table->key_size) % table->capacity;
+#endif
+}
+
+bool _ht_equal(const HashTable* table, void* first_key, void* second_key) {
+	return table->compare(first_key, second_key, table->key_size) == 0;
+}
+
+bool _ht_should_grow(HashTable* table) {
+	assert(table->size <= table->capacity);
+	return table->size == table->capacity;
+}
+
+bool _ht_should_shrink(HashTable* table) {
+	assert(table->size <= table->capacity);
+	return table->size == table->capacity * HT_SHRINK_THRESHOLD;
+}
+
+HTNode*
+_ht_create_node(HashTable* table, void* key, void* value, HTNode* next) {
+	HTNode* node;
+
+	assert(table != NULL);
+	assert(key != NULL);
+	assert(value != NULL);
+
+	if ((node = ZELDA_ARENA_MALLOC(sizeof *node, __FILE_NAME__, __LINE__)) == NULL) {
+		return NULL;
+	}
+	if ((node->key = ZELDA_ARENA_MALLOC(table->key_size, __FILE_NAME__, __LINE__)) == NULL) {
+		return NULL;
+	}
+	if ((node->value = ZELDA_ARENA_MALLOC(table->value_size, __FILE_NAME__, __LINE__)) == NULL) {
+		return NULL;
+	}
+
+	memcpy(node->key, key, table->key_size);
+	memcpy(node->value, value, table->value_size);
+	node->next = next;
+
+	return node;
+}
+
+int _ht_push_front(HashTable* table, size_t index, void* key, void* value) {
+	table->nodes[index] = _ht_create_node(table, key, value, table->nodes[index]);
+	return table->nodes[index] == NULL ? HT_ERROR : HT_SUCCESS;
+}
+
+void _ht_destroy_node(HTNode* node) {
+	assert(node != NULL);
+
+	ZELDA_ARENA_FREE(node->key, __FILE_NAME__, __LINE__);
+	ZELDA_ARENA_FREE(node->value, __FILE_NAME__, __LINE__);
+	ZELDA_ARENA_FREE(node, __FILE_NAME__, __LINE__);
+}
+
+int _ht_adjust_capacity(HashTable* table) {
+	return _ht_resize(table, table->size * HT_GROWTH_FACTOR);
+}
+
+int _ht_allocate(HashTable* table, size_t capacity) {
+	if ((table->nodes = ZELDA_ARENA_MALLOC(capacity * sizeof(HTNode*), __FILE_NAME__, __LINE__)) == NULL) {
+		return HT_ERROR;
+	}
+	memset(table->nodes, 0, capacity * sizeof(HTNode*));
+
+	table->capacity = capacity;
+	table->threshold = capacity * HT_LOAD_FACTOR;
+
+	return HT_SUCCESS;
+}
+
+int _ht_resize(HashTable* table, size_t new_capacity) {
+	HTNode** old;
+	size_t old_capacity;
+
+	if (new_capacity < HT_MINIMUM_CAPACITY) {
+		if (table->capacity > HT_MINIMUM_CAPACITY) {
+			new_capacity = HT_MINIMUM_CAPACITY;
+		} else {
+			/* NO-OP */
+			return HT_SUCCESS;
+		}
+	}
+
+	old = table->nodes;
+	old_capacity = table->capacity;
+	if (_ht_allocate(table, new_capacity) == HT_ERROR) {
+		return HT_ERROR;
+	}
+
+	_ht_rehash(table, old, old_capacity);
+
+	ZELDA_ARENA_FREE(old, __FILE_NAME__, __LINE__);
+
+	return HT_SUCCESS;
+}
+
+void _ht_rehash(HashTable* table, HTNode** old, size_t old_capacity) {
+	HTNode* node;
+	HTNode* next;
+	size_t new_index;
+	size_t chain;
+
+	for (chain = 0; chain < old_capacity; ++chain) {
+		for (node = old[chain]; node;) {
+			next = node->next;
+
+			new_index = _ht_hash(table, node->key);
+			node->next = table->nodes[new_index];
+			table->nodes[new_index] = node;
+
+			node = next;
+		}
+	}
+}
diff --git a/src/code/randomizer_play.c b/src/code/randomizer_play.c
new file mode 100644
index 000000000..4cc479202
--- /dev/null
+++ b/src/code/randomizer_play.c
@@ -0,0 +1,157 @@
+#include "randomizer_play.h"
+
+#include "fault.h"
+#include "z64scene.h"
+
+RandomizerChestID Randomizer_GetRandomizedChestContents(SceneID scene, u8 flag) {
+    switch (scene) {
+        case SCENE_MIDOS_HOUSE:
+            return CHEST_MIDO_0 + flag;
+        case SCENE_KOKIRI_FOREST:
+            return CHEST_KOKIRI_0;
+        case SCENE_TREASURE_BOX_SHOP:
+            return CHEST_BOX_GAME_0;
+        case SCENE_GRAVE_WITH_FAIRYS_FOUNTAIN:
+            return CHEST_SHIELD_GRAVE_0;
+        case SCENE_REDEAD_GRAVE:
+            return CHEST_REDEAD_GRAVE_0;
+        case SCENE_ROYAL_FAMILYS_TOMB:
+            return CHEST_ROYAL_TOMB_0;
+        case SCENE_WINDMILL_AND_DAMPES_GRAVE:
+            return CHEST_DAMPE_0;
+        case SCENE_DEATH_MOUNTAIN_TRAIL:
+            return CHEST_MOUNTAIN_0;
+        case SCENE_GORON_CITY:
+            return CHEST_GORON_0 + flag;
+        case SCENE_ZORAS_DOMAIN:
+            return CHEST_ZORA_0;
+        case SCENE_GERUDO_VALLEY:
+            return CHEST_VALLEY_0;
+        case SCENE_GERUDOS_FORTRESS:
+            return CHEST_FORTRESS_0;
+        case SCENE_HAUNTED_WASTELAND:
+            return CHEST_WASTELAND_0;
+        case SCENE_GROTTOS:
+            switch (flag) {
+                case 0x00:
+                    return CHEST_GROTTOS_0;
+                case 0x02:
+                case 0x03:
+                    return CHEST_GROTTOS_1 + (flag - 0x02);
+                case 0x08:
+                case 0x09:
+                case 0x0A:
+                    return CHEST_GROTTOS_3 + (flag - 0x08);
+                case 0x0C:
+                    return CHEST_GROTTOS_6;
+                case 0x11:
+                    return CHEST_GROTTOS_7;
+                case 0x14:
+                    return CHEST_GROTTOS_8;
+                case 0x17:
+                    return CHEST_GROTTOS_9;
+                case 0x1A:
+                    return CHEST_GROTTOS_10;
+                default: {
+                    return CHEST_MAX;
+                }
+            }
+        case SCENE_DEKU_TREE:
+            return CHEST_DEKU_0 + (flag - 1);
+        case SCENE_DODONGOS_CAVERN:
+            if (flag >= 4 && flag <= 6) {
+                return CHEST_DODONGO_0 + (flag - 4);
+            }
+            if (flag == 8) {
+                return CHEST_DODONGO_3;
+            }
+            return CHEST_DODONGO_4;
+        case SCENE_DODONGOS_CAVERN_BOSS:
+            return CHEST_DODONGO_5;
+        case SCENE_JABU_JABU:
+            if (flag == 4) {
+                return CHEST_JABU_2;
+            }
+            return CHEST_JABU_0 + (flag - 1);
+        case SCENE_BOTTOM_OF_THE_WELL:
+            // 1, 2, 3, 4, 5 7, 8, 9, a c e 10 14
+            if (flag < 7) {
+                return CHEST_BOTW_0 + (flag - 1);
+            }
+            if (flag >=7 && flag <= 9) {
+                return CHEST_BOTW_5 + (flag - 7);
+            }
+            switch (flag) {
+                case 0x0A:
+                    return CHEST_BOTW_8;
+                case 0x0C:
+                    return CHEST_BOTW_9;
+                case 0x0E:
+                    return CHEST_BOTW_10;
+                case 0x10:
+                    return CHEST_BOTW_11;
+                case 0x14:
+                    return CHEST_BOTW_12;
+                default: {
+                    return CHEST_MAX;
+                }
+            }
+
+        case SCENE_FOREST_TEMPLE:
+            if (flag <= 5) {
+                return CHEST_FOREST_0 + flag;
+            }
+            if (flag == 7) {
+                return CHEST_FOREST_6;
+            }
+            if (flag == 9) {
+                return CHEST_FOREST_7;
+            }
+            return CHEST_FOREST_8 + (flag - 0xB);
+        case SCENE_FIRE_TEMPLE:
+            return CHEST_FIRE_0 + flag;
+        case SCENE_WATER_TEMPLE:
+            if (flag < 0x04) {
+                return CHEST_WATER_0 + flag;
+            }
+            return CHEST_WATER_0 + (flag - 1);
+        case SCENE_SHADOW_TEMPLE:
+            if (flag <= 0x0D) {
+                return CHEST_SHADOW_0 + (flag - 1);
+            }
+            return CHEST_SHADOW_13 + (flag - 0x14);
+        case SCENE_SPIRIT_TEMPLE:
+            if (flag < 9) {
+                return CHEST_SPIRIT_0 + flag;
+            }
+            if (flag == 0x0A) {
+                return CHEST_SPIRIT_9;
+            }
+            if (flag >= 0x0C && flag <= 0x0F) {
+                return CHEST_SPIRIT_10 + (flag - 0x0C);
+            }
+            if (flag == 0x12) {
+                return CHEST_SPIRIT_14;
+            }
+            return CHEST_SPIRIT_15 + (flag - 0x14);
+        case SCENE_DESERT_COLOSSUS:
+            if (flag == 0x0B) {
+                return CHEST_SPIRIT_17; // Silver Gauntlets chest
+            }
+            return CHEST_SPIRIT_18; // Mirror Shield Chest
+        case SCENE_ICE_CAVERN:
+            return CHEST_ICE_0 + flag;
+        case SCENE_GERUDO_TRAINING_GROUND:
+            return CHEST_GTG_0 + flag;
+        case SCENE_INSIDE_GANONS_CASTLE:
+            if (flag == 0x14) {
+                return CHEST_GANON_14;
+            }
+            return CHEST_GANON_0 + (flag - 5);
+        case SCENE_GANONS_TOWER:
+            return CHEST_VALID_0;
+        default: {
+            return CHEST_MAX;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/code/vector.c b/src/code/vector.c
new file mode 100644
index 000000000..98bc5898e
--- /dev/null
+++ b/src/code/vector.c
@@ -0,0 +1,576 @@
+// The MIT License (MIT)
+// Copyright (c) 2016 Peter Goldsborough
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy of
+// this software and associated documentation files (the "Software"), to deal in
+// the Software without restriction, including without limitation the rights to
+// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+// the Software, and to permit persons to whom the Software is furnished to do so,
+// subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+#define __STDC_WANT_LIB_EXT1__ 1
+
+#include "vector.h"
+
+#include "zelda_arena.h"
+#include "libc64/qrand.h"
+
+#ifndef MAX
+#define MAX(a, b) ((a) > (b) ? (a) : (b))
+#endif
+
+bool _vector_should_grow(Vector* vector);
+bool _vector_should_shrink(Vector* vector);
+
+size_t _vector_free_bytes(const Vector* vector);
+void* _vector_offset(Vector* vector, size_t index);
+const void* _vector_const_offset(const Vector* vector, size_t index);
+
+void _vector_assign(Vector* vector, size_t index, void* element);
+
+int _vector_move_right(Vector* vector, size_t index);
+void _vector_move_left(Vector* vector, size_t index);
+
+int _vector_adjust_capacity(Vector* vector);
+int _vector_reallocate(Vector* vector, size_t new_capacity);
+
+void _vector_swap(size_t* first, size_t* second);
+
+int vector_setup(Vector* vector, size_t capacity, size_t element_size) {
+	assert(vector != NULL);
+
+	if (vector == NULL) return VECTOR_ERROR;
+
+	vector->size = 0;
+	vector->capacity = MAX(VECTOR_MINIMUM_CAPACITY, capacity);
+	vector->element_size = element_size;
+	vector->data = ZeldaArena_Malloc(vector->capacity * element_size);
+
+	return vector->data == NULL ? VECTOR_ERROR : VECTOR_SUCCESS;
+}
+
+int vector_copy(Vector* destination, Vector* source) {
+	assert(destination != NULL);
+	assert(source != NULL);
+	assert(vector_is_initialized(source));
+	assert(!vector_is_initialized(destination));
+
+	if (destination == NULL) return VECTOR_ERROR;
+	if (source == NULL) return VECTOR_ERROR;
+	if (vector_is_initialized(destination)) return VECTOR_ERROR;
+	if (!vector_is_initialized(source)) return VECTOR_ERROR;
+
+	/* Copy ALL the data */
+	destination->size = source->size;
+	destination->capacity = source->size * 2;
+	destination->element_size = source->element_size;
+
+	/* Note that we are not necessarily allocating the same capacity */
+	destination->data = ZeldaArena_Malloc(destination->capacity * source->element_size);
+	if (destination->data == NULL) return VECTOR_ERROR;
+
+	memcpy(destination->data, source->data, vector_byte_size(source));
+
+	return VECTOR_SUCCESS;
+}
+
+int vector_copy_assign(Vector* destination, Vector* source) {
+	assert(destination != NULL);
+	assert(source != NULL);
+	assert(vector_is_initialized(source));
+	assert(vector_is_initialized(destination));
+
+	if (destination == NULL) return VECTOR_ERROR;
+	if (source == NULL) return VECTOR_ERROR;
+	if (!vector_is_initialized(destination)) return VECTOR_ERROR;
+	if (!vector_is_initialized(source)) return VECTOR_ERROR;
+
+	vector_destroy(destination);
+
+	return vector_copy(destination, source);
+}
+
+int vector_move(Vector* destination, Vector* source) {
+	assert(destination != NULL);
+	assert(source != NULL);
+
+	if (destination == NULL) return VECTOR_ERROR;
+	if (source == NULL) return VECTOR_ERROR;
+
+	*destination = *source;
+	source->data = NULL;
+
+	return VECTOR_SUCCESS;
+}
+
+int vector_move_assign(Vector* destination, Vector* source) {
+	vector_swap(destination, source);
+	return vector_destroy(source);
+}
+
+int vector_swap(Vector* destination, Vector* source) {
+	void* temp;
+
+	assert(destination != NULL);
+	assert(source != NULL);
+	assert(vector_is_initialized(source));
+	assert(vector_is_initialized(destination));
+
+	if (destination == NULL) return VECTOR_ERROR;
+	if (source == NULL) return VECTOR_ERROR;
+	if (!vector_is_initialized(destination)) return VECTOR_ERROR;
+	if (!vector_is_initialized(source)) return VECTOR_ERROR;
+
+	_vector_swap(&destination->size, &source->size);
+	_vector_swap(&destination->capacity, &source->capacity);
+	_vector_swap(&destination->element_size, &source->element_size);
+
+	temp = destination->data;
+	destination->data = source->data;
+	source->data = temp;
+
+	return VECTOR_SUCCESS;
+}
+
+int vector_destroy(Vector* vector) {
+	assert(vector != NULL);
+
+	if (vector == NULL) return VECTOR_ERROR;
+
+	ZeldaArena_Free(vector->data);
+	vector->data = NULL;
+
+	return VECTOR_SUCCESS;
+}
+
+/* Insertion */
+int vector_push_back(Vector* vector, void* element) {
+	assert(vector != NULL);
+	assert(element != NULL);
+
+	if (_vector_should_grow(vector)) {
+		if (_vector_adjust_capacity(vector) == VECTOR_ERROR) {
+			return VECTOR_ERROR;
+		}
+	}
+
+	_vector_assign(vector, vector->size, element);
+
+	++vector->size;
+
+	return VECTOR_SUCCESS;
+}
+
+int vector_push_front(Vector* vector, void* element) {
+	return vector_insert(vector, 0, element);
+}
+
+int vector_insert(Vector* vector, size_t index, void* element) {
+	void* offset;
+
+	assert(vector != NULL);
+	assert(element != NULL);
+	assert(index <= vector->size);
+
+	if (vector == NULL) return VECTOR_ERROR;
+	if (element == NULL) return VECTOR_ERROR;
+	if (vector->element_size == 0) return VECTOR_ERROR;
+	if (index > vector->size) return VECTOR_ERROR;
+
+	if (_vector_should_grow(vector)) {
+		if (_vector_adjust_capacity(vector) == VECTOR_ERROR) {
+			return VECTOR_ERROR;
+		}
+	}
+
+	/* Move other elements to the right */
+	if (_vector_move_right(vector, index) == VECTOR_ERROR) {
+		return VECTOR_ERROR;
+	}
+
+	/* Insert the element */
+	offset = _vector_offset(vector, index);
+	memcpy(offset, element, vector->element_size);
+	++vector->size;
+
+	return VECTOR_SUCCESS;
+}
+
+int vector_assign(Vector* vector, size_t index, void* element) {
+	assert(vector != NULL);
+	assert(element != NULL);
+	assert(index < vector->size);
+
+	if (vector == NULL) return VECTOR_ERROR;
+	if (element == NULL) return VECTOR_ERROR;
+	if (vector->element_size == 0) return VECTOR_ERROR;
+	if (index >= vector->size) return VECTOR_ERROR;
+
+	_vector_assign(vector, index, element);
+
+	return VECTOR_SUCCESS;
+}
+
+/* Deletion */
+int vector_pop_back(Vector* vector) {
+	assert(vector != NULL);
+	assert(vector->size > 0);
+
+	if (vector == NULL) return VECTOR_ERROR;
+	if (vector->element_size == 0) return VECTOR_ERROR;
+
+	--vector->size;
+
+#ifndef VECTOR_NO_SHRINK
+	if (_vector_should_shrink(vector)) {
+		_vector_adjust_capacity(vector);
+	}
+#endif
+
+	return VECTOR_SUCCESS;
+}
+
+int vector_pop_front(Vector* vector) {
+	return vector_erase(vector, 0);
+}
+
+int vector_erase(Vector* vector, size_t index) {
+	assert(vector != NULL);
+	assert(index < vector->size);
+
+	if (vector == NULL) return VECTOR_ERROR;
+	if (vector->element_size == 0) return VECTOR_ERROR;
+	if (index >= vector->size) return VECTOR_ERROR;
+
+	/* Just overwrite */
+	_vector_move_left(vector, index);
+
+#ifndef VECTOR_NO_SHRINK
+	if (--vector->size == vector->capacity / 4) {
+		_vector_adjust_capacity(vector);
+	}
+#endif
+
+	return VECTOR_SUCCESS;
+}
+
+int vector_clear(Vector* vector) {
+	return vector_resize(vector, 0);
+}
+
+/* Lookup */
+void* vector_get(Vector* vector, size_t index) {
+	assert(vector != NULL);
+	assert(index < vector->size);
+
+	if (vector == NULL) return NULL;
+	if (vector->element_size == 0) return NULL;
+	if (index >= vector->size) return NULL;
+
+	return _vector_offset(vector, index);
+}
+
+const void* vector_const_get(const Vector* vector, size_t index) {
+	assert(vector != NULL);
+	assert(index < vector->size);
+
+	if (vector == NULL) return NULL;
+	if (vector->element_size == 0) return NULL;
+	if (index >= vector->size) return NULL;
+
+	return _vector_const_offset(vector, index);
+}
+
+void* vector_front(Vector* vector) {
+	return vector_get(vector, 0);
+}
+
+void* vector_back(Vector* vector) {
+	return vector_get(vector, vector->size - 1);
+}
+
+/* Information */
+
+bool vector_is_initialized(const Vector* vector) {
+	return vector->data != NULL;
+}
+
+size_t vector_byte_size(const Vector* vector) {
+	return vector->size * vector->element_size;
+}
+
+size_t vector_free_space(const Vector* vector) {
+	return vector->capacity - vector->size;
+}
+
+bool vector_is_empty(const Vector* vector) {
+	return vector->size == 0;
+}
+
+/* Memory management */
+int vector_resize(Vector* vector, size_t new_size) {
+	if (new_size <= vector->capacity * VECTOR_SHRINK_THRESHOLD) {
+		vector->size = new_size;
+		if (_vector_reallocate(vector, new_size * VECTOR_GROWTH_FACTOR) == -1) {
+			return VECTOR_ERROR;
+		}
+	} else if (new_size > vector->capacity) {
+		if (_vector_reallocate(vector, new_size * VECTOR_GROWTH_FACTOR) == -1) {
+			return VECTOR_ERROR;
+		}
+	}
+
+	vector->size = new_size;
+
+	return VECTOR_SUCCESS;
+}
+
+int vector_reserve(Vector* vector, size_t minimum_capacity) {
+	if (minimum_capacity > vector->capacity) {
+		if (_vector_reallocate(vector, minimum_capacity) == VECTOR_ERROR) {
+			return VECTOR_ERROR;
+		}
+	}
+
+	return VECTOR_SUCCESS;
+}
+
+int vector_shrink_to_fit(Vector* vector) {
+	return _vector_reallocate(vector, vector->size);
+}
+
+/* Iterators */
+Iterator vector_begin(Vector* vector) {
+	return vector_iterator(vector, 0);
+}
+
+Iterator vector_end(Vector* vector) {
+	return vector_iterator(vector, vector->size);
+}
+
+Iterator vector_iterator(Vector* vector, size_t index) {
+	Iterator iterator = {NULL, 0};
+
+	assert(vector != NULL);
+	assert(index <= vector->size);
+
+	if (vector == NULL) return iterator;
+	if (index > vector->size) return iterator;
+	if (vector->element_size == 0) return iterator;
+
+	iterator.pointer = _vector_offset(vector, index);
+	iterator.element_size = vector->element_size;
+
+	return iterator;
+}
+
+void* iterator_get(Iterator* iterator) {
+	return iterator->pointer;
+}
+
+int iterator_erase(Vector* vector, Iterator* iterator) {
+	size_t index = iterator_index(vector, iterator);
+
+	if (vector_erase(vector, index) == VECTOR_ERROR) {
+		return VECTOR_ERROR;
+	}
+
+	*iterator = vector_iterator(vector, index);
+
+	return VECTOR_SUCCESS;
+}
+
+void iterator_increment(Iterator* iterator) {
+	assert(iterator != NULL);
+	iterator->pointer += iterator->element_size;
+}
+
+void iterator_decrement(Iterator* iterator) {
+	assert(iterator != NULL);
+	iterator->pointer -= iterator->element_size;
+}
+
+void* iterator_next(Iterator* iterator) {
+	void* current = iterator->pointer;
+	iterator_increment(iterator);
+
+	return current;
+}
+
+void* iterator_previous(Iterator* iterator) {
+	void* current = iterator->pointer;
+	iterator_decrement(iterator);
+
+	return current;
+}
+
+bool iterator_equals(Iterator* first, Iterator* second) {
+	assert(first->element_size == second->element_size);
+	return first->pointer == second->pointer;
+}
+
+bool iterator_is_before(Iterator* first, Iterator* second) {
+	assert(first->element_size == second->element_size);
+	return first->pointer < second->pointer;
+}
+
+bool iterator_is_after(Iterator* first, Iterator* second) {
+	assert(first->element_size == second->element_size);
+	return first->pointer > second->pointer;
+}
+
+size_t iterator_index(Vector* vector, Iterator* iterator) {
+	assert(vector != NULL);
+	assert(iterator != NULL);
+	return (iterator->pointer - vector->data) / vector->element_size;
+}
+
+void vector_shuffle(Vector* src) {
+    Vector dest;
+    vector_setup(&dest, src->size, src->element_size);
+
+    while (src->size) {
+        size_t const rand = Rand_Next_Mod(src->size);
+        vector_push_back(&dest, vector_get(src, rand));
+        vector_erase(src, rand);
+    }
+
+    vector_destroy(src);
+    vector_copy(src, &dest);
+    vector_destroy(&dest);
+}
+
+/***** PRIVATE *****/
+
+bool _vector_should_grow(Vector* vector) {
+	assert(vector->size <= vector->capacity);
+	return vector->size == vector->capacity;
+}
+
+bool _vector_should_shrink(Vector* vector) {
+	assert(vector->size <= vector->capacity);
+	return vector->size == vector->capacity * VECTOR_SHRINK_THRESHOLD;
+}
+
+size_t _vector_free_bytes(const Vector* vector) {
+	return vector_free_space(vector) * vector->element_size;
+}
+
+void* _vector_offset(Vector* vector, size_t index) {
+	return vector->data + (index * vector->element_size);
+}
+
+const void* _vector_const_offset(const Vector* vector, size_t index) {
+	return vector->data + (index * vector->element_size);
+}
+
+void _vector_assign(Vector* vector, size_t index, void* element) {
+	/* Insert the element */
+	void* offset = _vector_offset(vector, index);
+	memcpy(offset, element, vector->element_size);
+}
+
+int _vector_move_right(Vector* vector, size_t index) {
+	assert(vector->size < vector->capacity);
+
+	/* The location where to start to move from. */
+	void* offset = _vector_offset(vector, index);
+
+	/* How many to move to the right. */
+	size_t elements_in_bytes = (vector->size - index) * vector->element_size;
+
+#ifdef __STDC_LIB_EXT1__
+	size_t right_capacity_in_bytes =
+			(vector->capacity - (index + 1)) * vector->element_size;
+
+	/* clang-format off */
+	int return_code =  memmove_s(
+		offset + vector->element_size,
+		right_capacity_in_bytes,
+		offset,
+		elements_in_bytes
+	);
+	/* clang-format on */
+
+	return return_code == 0 ? VECTOR_SUCCESS : VECTOR_ERROR;
+
+#else
+	memmove(offset + vector->element_size, offset, elements_in_bytes);
+	return VECTOR_SUCCESS;
+#endif
+}
+
+void _vector_move_left(Vector* vector, size_t index) {
+	size_t right_elements_in_bytes;
+	void* offset;
+
+	/* The offset into the memory */
+	offset = _vector_offset(vector, index);
+
+	/* How many to move to the left */
+	right_elements_in_bytes = (vector->size - index - 1) * vector->element_size;
+
+	memmove(offset, offset + vector->element_size, right_elements_in_bytes);
+}
+
+int _vector_adjust_capacity(Vector* vector) {
+	return _vector_reallocate(vector,
+														MAX(1, vector->size * VECTOR_GROWTH_FACTOR));
+}
+
+int _vector_reallocate(Vector* vector, size_t new_capacity) {
+	size_t new_capacity_in_bytes;
+	void* old;
+	assert(vector != NULL);
+
+	if (new_capacity < VECTOR_MINIMUM_CAPACITY) {
+		if (vector->capacity > VECTOR_MINIMUM_CAPACITY) {
+			new_capacity = VECTOR_MINIMUM_CAPACITY;
+		} else {
+			/* NO-OP */
+			return VECTOR_SUCCESS;
+		}
+	}
+
+	new_capacity_in_bytes = new_capacity * vector->element_size;
+	old = vector->data;
+
+	if ((vector->data = ZeldaArena_Malloc(new_capacity_in_bytes)) == NULL) {
+		return VECTOR_ERROR;
+	}
+
+#ifdef __STDC_LIB_EXT1__
+	/* clang-format off */
+	if (memcpy_s(vector->data,
+							 new_capacity_in_bytes,
+							 old,
+							 vector_byte_size(vector)) != 0) {
+		return VECTOR_ERROR;
+	}
+/* clang-format on */
+#else
+	memcpy(vector->data, old, vector_byte_size(vector));
+#endif
+
+	vector->capacity = new_capacity;
+
+	ZeldaArena_Free(old);
+
+	return VECTOR_SUCCESS;
+}
+
+void _vector_swap(size_t* first, size_t* second) {
+	size_t temp = *first;
+	*first = *second;
+	*second = temp;
+}
diff --git a/src/code/z_demo.c b/src/code/z_demo.c
index d5135b99d..9f48a88f5 100644
--- a/src/code/z_demo.c
+++ b/src/code/z_demo.c
@@ -188,6 +188,7 @@ void Cutscene_DrawDebugInfo(PlayState* play, Gfx** dlist, CutsceneContext* csCtx
 void Cutscene_InitContext(PlayState* play, CutsceneContext* csCtx) {
     csCtx->state = CS_STATE_IDLE;
     csCtx->timer = 0.0f;
+    csCtx->skippable = false;
 }
 
 void Cutscene_StartManual(PlayState* play, CutsceneContext* csCtx) {
@@ -589,6 +590,10 @@ void CutsceneCmd_Destination(PlayState* play, CutsceneContext* csCtx, CsCmdDesti
     Player* player = GET_PLAYER(play);
     s32 titleDemoSkipped = false;
 
+    if (!csCtx->skippable && ((csCtx->curFrame > 30) && (gSaveContext.fileNum != 0xFEDC) && (gSaveContext.fileNum != 0xFF))) {
+        csCtx->skippable = true;
+    }
+
     if ((gSaveContext.gameMode != GAMEMODE_NORMAL) && (gSaveContext.gameMode != GAMEMODE_END_CREDITS) &&
         (play->sceneId != SCENE_HYRULE_FIELD) && (csCtx->curFrame > 20) &&
         (CHECK_BTN_ALL(play->state.input[0].press.button, BTN_A) ||
@@ -601,8 +606,7 @@ void CutsceneCmd_Destination(PlayState* play, CutsceneContext* csCtx, CsCmdDesti
     }
 
     if ((csCtx->curFrame == cmd->startFrame) || titleDemoSkipped ||
-        (DEBUG_FEATURES && (csCtx->curFrame > 20) && CHECK_BTN_ALL(play->state.input[0].press.button, BTN_START) &&
-         (gSaveContext.fileNum != 0xFEDC))) {
+        (csCtx->skippable && CHECK_BTN_ALL(play->state.input[0].press.button, BTN_START))) {
         csCtx->state = CS_STATE_RUN_UNSTOPPABLE;
         Audio_SetCutsceneFlag(0);
         gSaveContext.cutsceneTransitionControl = 1;
@@ -902,6 +906,7 @@ void CutsceneCmd_Destination(PlayState* play, CutsceneContext* csCtx, CsCmdDesti
                 break;
 
             case CS_DEST_LAKE_HYLIA_FROM_LAKE_RESTORED:
+                SET_EVENTCHKINF(EVENTCHKINF_RESTORED_LAKE_HYLIA);
                 play->nextEntranceIndex = ENTR_LAKE_HYLIA_5;
                 play->transitionTrigger = TRANS_TRIGGER_START;
                 play->transitionType = TRANS_TYPE_FADE_BLACK;
@@ -915,6 +920,7 @@ void CutsceneCmd_Destination(PlayState* play, CutsceneContext* csCtx, CsCmdDesti
                 break;
 
             case CS_DEST_WINDMILL_FROM_WELL_DRAINED:
+                SET_EVENTCHKINF(EVENTCHKINF_DRAINED_WELL);
                 play->nextEntranceIndex = ENTR_WINDMILL_AND_DAMPES_GRAVE_2;
                 play->transitionTrigger = TRANS_TRIGGER_START;
                 play->transitionType = TRANS_TYPE_FADE_BLACK_FAST;
@@ -945,6 +951,7 @@ void CutsceneCmd_Destination(PlayState* play, CutsceneContext* csCtx, CsCmdDesti
                 break;
 
             case CS_DEST_DESERT_COLOSSUS_FROM_REQUIEM:
+                Item_Give(play, ITEM_SONG_REQUIEM);
                 play->nextEntranceIndex = ENTR_DESERT_COLOSSUS_4;
                 play->transitionTrigger = TRANS_TRIGGER_START;
                 play->transitionType = TRANS_TYPE_SANDSTORM_END;
@@ -2401,15 +2408,20 @@ void Cutscene_HandleEntranceTriggers(PlayState* play) {
             requiredAge = gSaveContext.save.linkAge;
         }
 
-        if ((gSaveContext.save.entranceIndex == entranceCutscene->entrance) &&
-            (!Flags_GetEventChkInf(entranceCutscene->flag) || (entranceCutscene->flag == EVENTCHKINF_EPONA_OBTAINED)) &&
+        if ((gSaveContext.save.entranceIndex == entranceCutscene->entrance)) {
+            if (entranceCutscene->entrance == ENTR_HYRULE_FIELD_16) {
+                Item_Give(play, ITEM_SONG_TIME);
+            }
+
+            if ((!Flags_GetEventChkInf(entranceCutscene->flag) || (entranceCutscene->flag == EVENTCHKINF_EPONA_OBTAINED)) &&
             (gSaveContext.save.cutsceneIndex < 0xFFF0) && ((u8)gSaveContext.save.linkAge == requiredAge) &&
             (gSaveContext.respawnFlag <= 0)) {
-            Flags_SetEventChkInf(entranceCutscene->flag);
-            Cutscene_SetScript(play, entranceCutscene->script);
-            gSaveContext.cutsceneTrigger = 2;
-            gSaveContext.showTitleCard = false;
-            break;
+                Flags_SetEventChkInf(entranceCutscene->flag);
+                Cutscene_SetScript(play, entranceCutscene->script);
+                gSaveContext.cutsceneTrigger = 2;
+                gSaveContext.showTitleCard = false;
+                break;
+            }
         }
     }
 }
@@ -2437,6 +2449,7 @@ void Cutscene_HandleConditionalTriggers(PlayState* play) {
                    LINK_IS_ADULT && !Flags_GetEventChkInf(EVENTCHKINF_C4) &&
                    (gEntranceTable[((void)0, gSaveContext.save.entranceIndex)].sceneId == SCENE_TEMPLE_OF_TIME)) {
             Flags_SetEventChkInf(EVENTCHKINF_C4);
+            Item_Give(play, ITEM_ARROW_LIGHT);
             gSaveContext.save.entranceIndex = ENTR_TEMPLE_OF_TIME_0;
             gSaveContext.save.cutsceneIndex = 0xFFF8;
         } else if (!Flags_GetEventChkInf(EVENTCHKINF_C7) &&
diff --git a/src/code/z_game_dlftbls.c b/src/code/z_game_dlftbls.c
index 57efe90df..f0d4c1a86 100644
--- a/src/code/z_game_dlftbls.c
+++ b/src/code/z_game_dlftbls.c
@@ -2,6 +2,7 @@
 #include "console_logo_state.h"
 #include "file_select_state.h"
 #include "map_select_state.h"
+#include "randomizer_state.h"
 #include "setup_state.h"
 #include "title_setup_state.h"
 #include "z_game_dlftbls.h"
diff --git a/src/code/z_kankyo.c b/src/code/z_kankyo.c
index c78fc5de8..d3a52d79c 100644
--- a/src/code/z_kankyo.c
+++ b/src/code/z_kankyo.c
@@ -285,6 +285,7 @@ void Environment_Init(PlayState* play2, EnvironmentContext* envCtx, s32 unused)
     PlayState* play = play2;
 
     gSaveContext.sunsSongState = SUNSSONG_INACTIVE;
+    envCtx->windSpeed = 0;
 
     //! FAKE: (void)0 on CLOCK_TIME(18, 0)
     if (((void)0, gSaveContext.save.dayTime) > ((void)0, CLOCK_TIME(18, 0)) ||
diff --git a/src/code/z_malloc.c b/src/code/z_malloc.c
index 513a61b31..168b55949 100644
--- a/src/code/z_malloc.c
+++ b/src/code/z_malloc.c
@@ -7,6 +7,7 @@
 #define LOG_SEVERITY_VERBOSE 3
 
 Arena sZeldaArena;
+size_t sMaxAllocated;
 
 #if DEBUG_FEATURES
 s32 gZeldaArenaLogSeverity = LOG_SEVERITY_ERROR;
@@ -29,11 +30,20 @@ void ZeldaArena_CheckPointer(void* ptr, u32 size, const char* name, const char*
 #define ZELDA_ARENA_CHECK_POINTER(ptr, size, name, action) (void)0
 #endif
 
+void ZeldaArena_GetSizes(u32* outMaxFree, u32* outFree, u32* outAlloc) {
+    ArenaImpl_GetSizes(&sZeldaArena, outMaxFree, outFree, outAlloc);
+}
+
 void* ZeldaArena_Malloc(u32 size) {
     void* ptr = __osMalloc(&sZeldaArena, size);
 
     // TODO re-evaluate "secure" as a translation (in this file and others using "")
     ZELDA_ARENA_CHECK_POINTER(ptr, size, "zelda_malloc", T("", "Secure"));
+#if DEBUG_FEATURES_MEM
+    u32 outMaxFree, outFree, outAlloc;
+    ZeldaArena_GetSizes(&outMaxFree, &outFree, &outAlloc);
+    if (outAlloc > sMaxAllocated) { sMaxAllocated = outAlloc; }
+#endif
     return ptr;
 }
 
@@ -42,6 +52,11 @@ void* ZeldaArena_MallocDebug(u32 size, const char* file, int line) {
     void* ptr = __osMallocDebug(&sZeldaArena, size, file, line);
 
     ZELDA_ARENA_CHECK_POINTER(ptr, size, "zelda_malloc_DEBUG", T("", "Secure"));
+#if DEBUG_FEATURES_MEM
+    u32 outMaxFree, outFree, outAlloc;
+    ZeldaArena_GetSizes(&outMaxFree, &outFree, &outAlloc);
+    if (outAlloc > sMaxAllocated) { sMaxAllocated = outAlloc; }
+#endif
     return ptr;
 }
 #endif
@@ -50,6 +65,11 @@ void* ZeldaArena_MallocR(u32 size) {
     void* ptr = __osMallocR(&sZeldaArena, size);
 
     ZELDA_ARENA_CHECK_POINTER(ptr, size, "zelda_malloc_r", T("", "Secure"));
+#if DEBUG_FEATURES_MEM
+    u32 outMaxFree, outFree, outAlloc;
+    ZeldaArena_GetSizes(&outMaxFree, &outFree, &outAlloc);
+    if (outAlloc > sMaxAllocated) { sMaxAllocated = outAlloc; }
+#endif
     return ptr;
 }
 
@@ -58,6 +78,12 @@ void* ZeldaArena_MallocRDebug(u32 size, const char* file, int line) {
     void* ptr = __osMallocRDebug(&sZeldaArena, size, file, line);
 
     ZELDA_ARENA_CHECK_POINTER(ptr, size, "zelda_malloc_r_DEBUG", T("", "Secure"));
+
+#if DEBUG_FEATURES_MEM
+    u32 outMaxFree, outFree, outAlloc;
+    ZeldaArena_GetSizes(&outMaxFree, &outFree, &outAlloc);
+    if (outAlloc > sMaxAllocated) { sMaxAllocated = outAlloc; }
+#endif
     return ptr;
 }
 #endif
@@ -72,6 +98,11 @@ void* ZeldaArena_Realloc(void* ptr, u32 newSize) {
 void* ZeldaArena_ReallocDebug(void* ptr, u32 newSize, const char* file, int line) {
     ptr = __osReallocDebug(&sZeldaArena, ptr, newSize, file, line);
     ZELDA_ARENA_CHECK_POINTER(ptr, newSize, "zelda_realloc_DEBUG", T("", "Re-securing"));
+#if DEBUG_FEATURES_MEM
+    u32 outMaxFree, outFree, outAlloc;
+    ZeldaArena_GetSizes(&outMaxFree, &outFree, &outAlloc);
+    if (outAlloc > sMaxAllocated) { sMaxAllocated = outAlloc; }
+#endif
     return ptr;
 }
 #endif
@@ -96,6 +127,11 @@ void* ZeldaArena_Calloc(u32 num, u32 size) {
     }
 
     ZELDA_ARENA_CHECK_POINTER(ret, n, "zelda_calloc", T("", "Secure"));
+#if DEBUG_FEATURES_MEM
+    u32 outMaxFree, outFree, outAlloc;
+    ZeldaArena_GetSizes(&outMaxFree, &outFree, &outAlloc);
+    if (outAlloc > sMaxAllocated) { sMaxAllocated = outAlloc; }
+#endif
     return ret;
 }
 
@@ -106,10 +142,6 @@ void ZeldaArena_Display(void) {
 }
 #endif
 
-void ZeldaArena_GetSizes(u32* outMaxFree, u32* outFree, u32* outAlloc) {
-    ArenaImpl_GetSizes(&sZeldaArena, outMaxFree, outFree, outAlloc);
-}
-
 void ZeldaArena_Check(void) {
     __osCheckArena(&sZeldaArena);
 }
@@ -119,6 +151,7 @@ void ZeldaArena_Init(void* start, u32 size) {
     gZeldaArenaLogSeverity = LOG_SEVERITY_NOLOG;
 #endif
     __osMallocInit(&sZeldaArena, start, size);
+    sMaxAllocated = 0;
 }
 
 void ZeldaArena_Cleanup(void) {
@@ -126,8 +159,13 @@ void ZeldaArena_Cleanup(void) {
     gZeldaArenaLogSeverity = LOG_SEVERITY_NOLOG;
 #endif
     __osMallocCleanup(&sZeldaArena);
+    sMaxAllocated = 0;
 }
 
 s32 ZeldaArena_IsInitialized(void) {
     return __osMallocIsInitialized(&sZeldaArena);
 }
+
+size_t ZeldaArena_MaxAllocated(void) {
+    return sMaxAllocated;
+}
diff --git a/src/code/z_message.c b/src/code/z_message.c
index 1d6fee156..96d93e845 100644
--- a/src/code/z_message.c
+++ b/src/code/z_message.c
@@ -1512,9 +1512,9 @@ void Message_DrawText(PlayState* play, Gfx** gfxP) {
                                                       msgCtx->msgMode < MSGMODE_SCARECROW_LONG_RECORDING_START))) {
                     for (j = i;; j++) {
                         character = MSG_BUF_DECODED[j];
-                        if (character == MESSAGE_SHIFT) {
+                        if (character == MESSAGE_SHIFT || character == MESSAGE_ITEM_ICON) {
                             j++;
-                        } else if ((character == MESSAGE_QUICKTEXT_DISABLE) || (character == MESSAGE_PERSISTENT) ||
+                        } else if (((character == MESSAGE_QUICKTEXT_DISABLE) && msgCtx->textBoxType >= TEXTBOX_TYPE_OCARINA) || (character == MESSAGE_PERSISTENT) ||
                                    (character == MESSAGE_EVENT) || (character == MESSAGE_BOX_BREAK_DELAYED) ||
                                    (character == MESSAGE_AWAIT_BUTTON_PRESS) || (character == MESSAGE_BOX_BREAK) ||
                                    (character == MESSAGE_END)) {
@@ -1632,7 +1632,7 @@ void Message_DrawText(PlayState* play, Gfx** gfxP) {
                 msgCtx->textDelay = MSG_BUF_DECODED[++i];
                 break;
             case MESSAGE_UNSKIPPABLE:
-                msgCtx->textUnskippable = true;
+                /*msgCtx->textUnskippable = true;*/
                 break;
             case MESSAGE_TWO_CHOICE:
                 msgCtx->textboxEndType = TEXTBOX_ENDTYPE_2_CHOICE;
@@ -2147,6 +2147,12 @@ void Message_Decode(PlayState* play) {
     } else
 #endif
     {
+        if (gSaveContext.quicktextSetting
+            && msgCtx->ocarinaAction != OCARINA_ACTION_SCARECROW_LONG_PLAYBACK && msgCtx->ocarinaAction != OCARINA_ACTION_SCARECROW_SPAWN_PLAYBACK) {
+            msgCtx->msgBufDecoded[decodedBufPos] = MESSAGE_QUICKTEXT_ENABLE;
+            decodedBufPos++;
+        }
+
         // English text for NTSC, eng/ger/fra text for PAL
         for (;;) {
             curChar = MSG_BUF_DECODED[decodedBufPos] = MSG_BUF[msgCtx->msgBufPos];
diff --git a/src/code/z_parameter.c b/src/code/z_parameter.c
index 1498db0fb..62b874f2b 100644
--- a/src/code/z_parameter.c
+++ b/src/code/z_parameter.c
@@ -1489,7 +1489,11 @@ u8 Item_Give(PlayState* play, u8 item) {
         gSaveContext.save.info.inventory.equipment |= OWNED_EQUIP_FLAG(EQUIP_TYPE_BOOTS, item - ITEM_BOOTS_KOKIRI);
         return ITEM_NONE;
     } else if ((item == ITEM_DUNGEON_BOSS_KEY) || (item == ITEM_DUNGEON_COMPASS) || (item == ITEM_DUNGEON_MAP)) {
-        gSaveContext.save.info.inventory.dungeonItems[gSaveContext.mapIndex] |= gBitFlags[item - ITEM_DUNGEON_BOSS_KEY];
+        if (gSaveContext.mapIndex == SCENE_INSIDE_GANONS_CASTLE) {
+            gSaveContext.save.info.inventory.dungeonItems[SCENE_GANONS_TOWER] |= gBitFlags[item - ITEM_DUNGEON_BOSS_KEY];
+        } else {
+            gSaveContext.save.info.inventory.dungeonItems[gSaveContext.mapIndex] |= gBitFlags[item - ITEM_DUNGEON_BOSS_KEY];
+        }
         return ITEM_NONE;
     } else if (item == ITEM_SMALL_KEY) {
         if (gSaveContext.save.info.inventory.dungeonKeys[gSaveContext.mapIndex] < 0) {
@@ -1512,7 +1516,9 @@ u8 Item_Give(PlayState* play, u8 item) {
             }
         }
     } else if (item == ITEM_QUIVER_40) {
-        Inventory_ChangeUpgrade(UPG_QUIVER, 2);
+        if (CUR_UPG_VALUE(UPG_QUIVER) < 2 || !gSaveContext.save.randomizer.shuffleChests) {
+            Inventory_ChangeUpgrade(UPG_QUIVER, 2);
+        }
         AMMO(ITEM_BOW) = CAPACITY(UPG_QUIVER, 2);
         return ITEM_NONE;
     } else if (item == ITEM_QUIVER_50) {
@@ -1520,7 +1526,9 @@ u8 Item_Give(PlayState* play, u8 item) {
         AMMO(ITEM_BOW) = CAPACITY(UPG_QUIVER, 3);
         return ITEM_NONE;
     } else if (item == ITEM_BULLET_BAG_40) {
-        Inventory_ChangeUpgrade(UPG_BULLET_BAG, 2);
+        if (CUR_UPG_VALUE(UPG_BULLET_BAG) < 2 || !gSaveContext.save.randomizer.shuffleChests) {
+            Inventory_ChangeUpgrade(UPG_BULLET_BAG, 2);
+        }
         AMMO(ITEM_SLINGSHOT) = CAPACITY(UPG_BULLET_BAG, 2);
         return ITEM_NONE;
     } else if (item == ITEM_BULLET_BAG_50) {
@@ -1540,7 +1548,9 @@ u8 Item_Give(PlayState* play, u8 item) {
             }
         }
     } else if (item == ITEM_BOMB_BAG_30) {
-        Inventory_ChangeUpgrade(UPG_BOMB_BAG, 2);
+        if (CUR_UPG_VALUE(UPG_BOMB_BAG) < 2 || !gSaveContext.save.randomizer.shuffleChests) {
+            Inventory_ChangeUpgrade(UPG_BOMB_BAG, 2);
+        }
         AMMO(ITEM_BOMB) = CAPACITY(UPG_BOMB_BAG, 2);
         return ITEM_NONE;
     } else if (item == ITEM_BOMB_BAG_40) {
@@ -1548,22 +1558,30 @@ u8 Item_Give(PlayState* play, u8 item) {
         AMMO(ITEM_BOMB) = CAPACITY(UPG_BOMB_BAG, 3);
         return ITEM_NONE;
     } else if (item == ITEM_STRENGTH_GORONS_BRACELET) {
-        Inventory_ChangeUpgrade(UPG_STRENGTH, 1);
+        if (CUR_UPG_VALUE(UPG_STRENGTH) < 1 || !gSaveContext.save.randomizer.shuffleChests) {
+            Inventory_ChangeUpgrade(UPG_STRENGTH, 1);
+        }
         return ITEM_NONE;
     } else if (item == ITEM_STRENGTH_SILVER_GAUNTLETS) {
-        Inventory_ChangeUpgrade(UPG_STRENGTH, 2);
+        if (CUR_UPG_VALUE(UPG_STRENGTH) < 2 || !gSaveContext.save.randomizer.shuffleChests) {
+            Inventory_ChangeUpgrade(UPG_STRENGTH, 2);
+        }
         return ITEM_NONE;
     } else if (item == ITEM_STRENGTH_GOLD_GAUNTLETS) {
         Inventory_ChangeUpgrade(UPG_STRENGTH, 3);
         return ITEM_NONE;
     } else if (item == ITEM_SCALE_SILVER) {
-        Inventory_ChangeUpgrade(UPG_SCALE, 1);
+        if (CUR_UPG_VALUE(UPG_SCALE) < 1 || !gSaveContext.save.randomizer.shuffleChests) {
+            Inventory_ChangeUpgrade(UPG_SCALE, 1);
+        }
         return ITEM_NONE;
     } else if (item == ITEM_SCALE_GOLDEN) {
         Inventory_ChangeUpgrade(UPG_SCALE, 2);
         return ITEM_NONE;
     } else if (item == ITEM_ADULTS_WALLET) {
-        Inventory_ChangeUpgrade(UPG_WALLET, 1);
+        if (CUR_UPG_VALUE(UPG_WALLET) < 1 || !gSaveContext.save.randomizer.shuffleChests) {
+            Inventory_ChangeUpgrade(UPG_WALLET, 1);
+        }
         return ITEM_NONE;
     } else if (item == ITEM_GIANTS_WALLET) {
         Inventory_ChangeUpgrade(UPG_WALLET, 2);
@@ -1596,6 +1614,11 @@ u8 Item_Give(PlayState* play, u8 item) {
         Inventory_ChangeUpgrade(UPG_DEKU_NUTS, 3);
         AMMO(ITEM_DEKU_NUT) = CAPACITY(UPG_DEKU_NUTS, 3);
         return ITEM_NONE;
+    } else if (gSaveContext.save.randomizer.shuffleChests && item == ITEM_HOOKSHOT) {
+        if (INV_CONTENT(ITEM_LONGSHOT) != ITEM_LONGSHOT || !gSaveContext.save.randomizer.shuffleChests) {
+            INV_CONTENT(ITEM_HOOKSHOT) = ITEM_HOOKSHOT;
+        }
+        return ITEM_NONE;
     } else if (item == ITEM_LONGSHOT) {
         INV_CONTENT(item) = item;
         for (i = 1; i < 4; i++) {
@@ -1693,9 +1716,11 @@ u8 Item_Give(PlayState* play, u8 item) {
 
         return ITEM_BOW;
     } else if (item == ITEM_SLINGSHOT) {
-        Inventory_ChangeUpgrade(UPG_BULLET_BAG, 1);
+        if (CUR_UPG_VALUE(UPG_BULLET_BAG) == 0 || !gSaveContext.save.randomizer.shuffleChests) {
+            Inventory_ChangeUpgrade(UPG_BULLET_BAG, 1);
+        }
         INV_CONTENT(ITEM_SLINGSHOT) = ITEM_SLINGSHOT;
-        AMMO(ITEM_SLINGSHOT) = 30;
+        AMMO(ITEM_SLINGSHOT) = CUR_CAPACITY(UPG_BULLET_BAG);
         return ITEM_NONE;
     } else if (item == ITEM_DEKU_SEEDS) {
         AMMO(ITEM_SLINGSHOT) += 5;
@@ -1724,7 +1749,9 @@ u8 Item_Give(PlayState* play, u8 item) {
 
         return ITEM_DEKU_SEEDS;
     } else if (item == ITEM_OCARINA_FAIRY) {
-        INV_CONTENT(ITEM_OCARINA_FAIRY) = ITEM_OCARINA_FAIRY;
+        if (INV_CONTENT(ITEM_OCARINA_OF_TIME) != ITEM_OCARINA_OF_TIME || !gSaveContext.save.randomizer.shuffleChests) {
+            INV_CONTENT(ITEM_OCARINA_FAIRY) = ITEM_OCARINA_FAIRY;
+        }
         return ITEM_NONE;
     } else if (item == ITEM_OCARINA_OF_TIME) {
         INV_CONTENT(ITEM_OCARINA_OF_TIME) = ITEM_OCARINA_OF_TIME;
@@ -1851,7 +1878,7 @@ u8 Item_Give(PlayState* play, u8 item) {
             }
         }
     } else if ((item >= ITEM_WEIRD_EGG) && (item <= ITEM_CLAIM_CHECK)) {
-        if (item == ITEM_POACHERS_SAW) {
+        if (item == ITEM_POACHERS_SAW && !gSaveContext.save.randomizer.shuffleChests) {
             //! @bug Setting this shared flag makes getting the Deku Nut upgrade impossible
             SET_ITEMGETINF(ITEMGETINF_FOREST_STAGE_NUT_UPGRADE);
         }
@@ -3058,6 +3085,27 @@ void Interface_DrawAmmoCount(PlayState* play, s16 button, s16 alpha) {
     CLOSE_DISPS(play->state.gfxCtx, "../z_parameter.c", 3158);
 }
 
+void Interface_DrawSkipButton(PlayState* play) {
+    InterfaceContext* interfaceCtx = &play->interfaceCtx;
+
+    OPEN_DISPS(play->state.gfxCtx, __FILE_NAME__, __LINE__);
+
+    Matrix_Translate(0.0f, 0.0f, XREG(18) / 10.0f, MTXMODE_NEW);
+    Matrix_Scale(1.0f, 1.0f, 1.0f, MTXMODE_APPLY);
+    Matrix_RotateX(interfaceCtx->unk_1F4 / 10000.0f, MTXMODE_APPLY);
+
+    MATRIX_FINALIZE_AND_LOAD(OVERLAY_DISP++, play->state.gfxCtx, __FILE_NAME__, __LINE__);
+    gSPVertex(OVERLAY_DISP++, &interfaceCtx->actionVtx[0], 4, 0);
+
+    gDPLoadTextureBlock(OVERLAY_DISP++, gButtonBackgroundTex, G_IM_FMT_IA, G_IM_SIZ_8b, 32, 32, 0,
+                        G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMASK, G_TX_NOMASK, G_TX_NOLOD,
+                        G_TX_NOLOD);
+
+    gSP1Quadrangle(OVERLAY_DISP++, 0, 2, 3, 1, 0);
+
+    CLOSE_DISPS(play->state.gfxCtx, __FILE_NAME__, __LINE__);
+}
+
 void Interface_DrawActionButton(PlayState* play) {
     InterfaceContext* interfaceCtx = &play->interfaceCtx;
 
@@ -3416,6 +3464,30 @@ void Interface_Draw(PlayState* play) {
             Interface_DrawAmmoCount(play, 3, interfaceCtx->cRightAlpha);
         }
 
+        if (play->csCtx.state > CS_STATE_IDLE && play->csCtx.skippable) {
+            Gfx_SetupDL_42Overlay(play->state.gfxCtx);
+            func_8008A8B8(play, 200, 200 + 35, 143, 143 + 35);
+            gSPClearGeometryMode(OVERLAY_DISP++, G_CULL_BOTH);
+            gDPSetCombineMode(OVERLAY_DISP++, G_CC_MODULATEIA_PRIM, G_CC_MODULATEIA_PRIM);
+            gDPSetPrimColor(OVERLAY_DISP++, 0, 0, START_BUTTON_R, START_BUTTON_G, START_BUTTON_B, 255);
+            Interface_DrawSkipButton(play);
+            gDPPipeSync(OVERLAY_DISP++);
+            Interface_LoadActionLabel(interfaceCtx, DO_ACTION_SKIP, 2);
+            func_8008A8B8(play, 200, 200 + 35, 144, 144 + 35);
+            gSPSetGeometryMode(OVERLAY_DISP++, G_CULL_BACK);
+            gDPSetCombineLERP(OVERLAY_DISP++, PRIMITIVE, ENVIRONMENT, TEXEL0, ENVIRONMENT, TEXEL0, 0, PRIMITIVE, 0,
+                              PRIMITIVE, ENVIRONMENT, TEXEL0, ENVIRONMENT, TEXEL0, 0, PRIMITIVE, 0);
+            gDPSetPrimColor(OVERLAY_DISP++, 0, 0, 255, 255, 255, 255);
+            gDPSetEnvColor(OVERLAY_DISP++, 0, 0, 0, 0);
+            Matrix_Translate(0.0f, 0.0f, R_A_LABEL_Z(gSaveContext.language) / 10.0f, MTXMODE_NEW);
+            Matrix_Scale(1.0f, 1.0f, 1.0f, MTXMODE_APPLY);
+            Matrix_RotateX(interfaceCtx->unk_1F4 / 10000.0f, MTXMODE_APPLY);
+            MATRIX_FINALIZE_AND_LOAD(OVERLAY_DISP++, play->state.gfxCtx, "../z_parameter.c", 3701);
+            gSPVertex(OVERLAY_DISP++, &interfaceCtx->actionVtx[4], 4, 0);
+            Interface_DrawActionLabel(play->state.gfxCtx, interfaceCtx->doActionSegment + DO_ACTION_TEX_SIZE * 2);
+            gDPPipeSync(OVERLAY_DISP++);
+        }
+
         // A Button
         Gfx_SetupDL_42Overlay(play->state.gfxCtx);
         func_8008A8B8(play, R_A_BTN_Y, R_A_BTN_Y + 45, R_A_BTN_X, R_A_BTN_X + 45);
diff --git a/src/code/z_scene.c b/src/code/z_scene.c
index feef5ffc6..f55e68173 100644
--- a/src/code/z_scene.c
+++ b/src/code/z_scene.c
@@ -61,6 +61,33 @@ s32 Object_SpawnPersistent(ObjectContext* objectCtx, s16 objectId) {
     return objectCtx->numEntries - 1;
 }
 
+s32 Object_SpawnTemporary(ObjectContext* objectCtx, s16 objectId) {
+    objectCtx->slots[objectCtx->numEntries].id = objectId;
+    u32 size = gObjectTable[objectId].vromEnd - gObjectTable[objectId].vromStart;
+
+    PRINTF("OBJECT[%d] SIZE %fK SEG=%x\n", objectId, size / 1024.0f, objectCtx->slots[objectCtx->numEntries].segment);
+
+    PRINTF("num=%d adrs=%x end=%x\n", objectCtx->numEntries,
+           (uintptr_t)objectCtx->slots[objectCtx->numEntries].segment + size, objectCtx->spaceEnd);
+
+    ASSERT(((objectCtx->numEntries < ARRAY_COUNT(objectCtx->slots)) &&
+            (((uintptr_t)objectCtx->slots[objectCtx->numEntries].segment + size) < (uintptr_t)objectCtx->spaceEnd)),
+           "this->num < OBJECT_EXCHANGE_BANK_MAX && (this->status[this->num].Segment + size) < this->endSegment",
+           __FILE_NAME__, __LINE__);
+
+    DMA_REQUEST_SYNC(objectCtx->slots[objectCtx->numEntries].segment, gObjectTable[objectId].vromStart, size,
+                     __FILE_NAME__, __LINE__);
+
+    if (objectCtx->numEntries < (ARRAY_COUNT(objectCtx->slots) - 1)) {
+        objectCtx->slots[objectCtx->numEntries + 1].segment =
+            (void*)ALIGN16((uintptr_t)objectCtx->slots[objectCtx->numEntries].segment + size);
+    }
+
+    objectCtx->numEntries++;
+
+    return objectCtx->numEntries - 1;
+}
+
 // PAL N64 versions reduce the size of object space by 4 KiB in order to give some space back to
 // the Zelda arena, which can help prevent an issue where actors fail to spawn in specific areas
 // (sometimes referred to as the "Hyrule Field Glitch" although it can happen in more places than Hyrule Field).
diff --git a/src/code/z_sram.c b/src/code/z_sram.c
index 2eef6db03..cf0019868 100644
--- a/src/code/z_sram.c
+++ b/src/code/z_sram.c
@@ -30,7 +30,7 @@
 #define HEALTH offsetof(SaveContext, save.info.playerData.health)
 #endif
 
-#define SLOT_OFFSET(index) (SRAM_HEADER_SIZE + 0x10 + (index * SLOT_SIZE))
+#define SLOT_OFFSET(index) (SRAM_HEADER_SIZE + 0x10 + (SRAM_HEADER_SIZE % 0x10) + (index * SLOT_SIZE))
 
 #if !PLATFORM_IQUE
 
@@ -59,11 +59,9 @@ void Sram_ReadWriteIQue(s32 addr, void* dramAddr, size_t size, s32 direction) {
 u16 gSramSlotOffsets[] = {
     SLOT_OFFSET(0),
     SLOT_OFFSET(1),
+    // the latter two saves are backup saves for the former saves
     SLOT_OFFSET(2),
-    // the latter three saves are backup saves for the former saves
     SLOT_OFFSET(3),
-    SLOT_OFFSET(4),
-    SLOT_OFFSET(5),
 };
 
 static u8 sSramDefaultHeader[] = {
@@ -74,6 +72,7 @@ static u8 sSramDefaultHeader[] = {
 #else
     LANGUAGE_ENG, // SRAM_HEADER_LANGUAGE
 #endif
+    QUICKTEXT_SETTING_OFF,
 
     // SRAM_HEADER_MAGIC
     0x98,
@@ -198,6 +197,8 @@ static Inventory sNewSaveInventory = {
 
 static Checksum sNewSaveChecksum = { 0 };
 
+static SaveRandomizerData sNewSaveRandomizerData = { 0, 0, 0 };
+
 /**
  *  Initialize new save.
  *  This save has an empty inventory with 3 hearts and single magic.
@@ -211,6 +212,7 @@ void Sram_InitNewSave(void) {
     gSaveContext.save.info.equips = sNewSaveEquips;
     gSaveContext.save.info.inventory = sNewSaveInventory;
     gSaveContext.save.info.checksum = sNewSaveChecksum;
+    gSaveContext.save.randomizer = sNewSaveRandomizerData;
 
     gSaveContext.save.info.horseData.sceneId = SCENE_HYRULE_FIELD;
     gSaveContext.save.info.horseData.pos.x = -1840;
@@ -355,6 +357,8 @@ static Inventory sDebugSaveInventory = {
 
 static Checksum sDebugSaveChecksum = { 0 };
 
+static SaveRandomizerData sDebugSaveRandomizerData = { 0, 0, 0 };
+
 /**
  *  Initialize debug save. This is also used on the Title Screen
  *  This save has a mostly full inventory with 10 hearts and single magic.
@@ -373,6 +377,7 @@ void Sram_InitDebugSave(void) {
     gSaveContext.save.info.equips = sDebugSaveEquips;
     gSaveContext.save.info.inventory = sDebugSaveInventory;
     gSaveContext.save.info.checksum = sDebugSaveChecksum;
+    gSaveContext.save.randomizer = sDebugSaveRandomizerData;
 
     gSaveContext.save.info.horseData.sceneId = SCENE_HYRULE_FIELD;
     gSaveContext.save.info.horseData.pos.x = -1840;
@@ -646,15 +651,15 @@ void Sram_WriteSave(SramContext* sramCtx) {
         checksum += *ptr++;
     }
 
-    offset = gSramSlotOffsets[gSaveContext.fileNum + 3];
+    offset = gSramSlotOffsets[gSaveContext.fileNum + 2];
     SRAM_WRITE(OS_K1_TO_PHYSICAL(0xA8000000) + offset, &gSaveContext, SLOT_SIZE);
 }
 
 /**
- *  For all 3 slots, verify that the checksum is correct. If corrupted, attempt to load a backup save.
+ *  For both slots, verify that the checksum is correct. If corrupted, attempt to load a backup save.
  *  If backup is also corrupted, default to a new save (or debug save for slot 0 on debug rom).
  *
- *  After verifying all 3 saves, pass relevant data to File Select to be displayed.
+ *  After verifying both saves, pass relevant data to File Select to be displayed.
  */
 void Sram_VerifyAndLoadAllSaves(FileSelectState* fileSelect, SramContext* sramCtx) {
     u16 i;
@@ -672,7 +677,7 @@ void Sram_VerifyAndLoadAllSaves(FileSelectState* fileSelect, SramContext* sramCt
 
     dayTime = ((void)0, gSaveContext.save.dayTime);
 
-    for (slotNum = 0; slotNum < 3; slotNum++) {
+    for (slotNum = 0; slotNum < 2; slotNum++) {
         offset = gSramSlotOffsets[slotNum];
         PRINTF(T("%x(%d)    SAVE_MAX=%d\n", "Point=%x(%d)    SAVE_MAX=%d\n"), offset, gSaveContext.fileNum,
                sizeof(Save));
@@ -700,7 +705,7 @@ void Sram_VerifyAndLoadAllSaves(FileSelectState* fileSelect, SramContext* sramCt
         if (newChecksum != oldChecksum) {
             // checksum didnt match, try backup save
             PRINTF("  %x(%d)\n", gSramSlotOffsets[slotNum], slotNum);
-            offset = gSramSlotOffsets[slotNum + 3];
+            offset = gSramSlotOffsets[slotNum + 2];
             MemCpy(&gSaveContext, sramCtx->readBuff + offset, sizeof(Save));
 
             oldChecksum = gSaveContext.save.info.checksum.value;
@@ -724,7 +729,7 @@ void Sram_VerifyAndLoadAllSaves(FileSelectState* fileSelect, SramContext* sramCt
 
             if (newChecksum != oldChecksum) {
                 // backup save didnt work, make new save
-                PRINTF("  %x(%d+3)\n", gSramSlotOffsets[slotNum + 3], slotNum);
+                PRINTF("  %x(%d+3)\n", gSramSlotOffsets[slotNum + 2], slotNum);
                 bzero(&gSaveContext.save.entranceIndex, sizeof(s32));
                 bzero(&gSaveContext.save.linkAge, sizeof(s32));
                 bzero(&gSaveContext.save.cutsceneIndex, sizeof(s32));
@@ -771,7 +776,7 @@ void Sram_VerifyAndLoadAllSaves(FileSelectState* fileSelect, SramContext* sramCt
                 gSaveContext.save.info.checksum.value = newChecksum;
                 PRINTF("\nCheck_Sum=%x(%x)\n", gSaveContext.save.info.checksum.value, newChecksum);
 
-                i = gSramSlotOffsets[slotNum + 3];
+                i = gSramSlotOffsets[slotNum + 2];
                 SRAM_WRITE(OS_K1_TO_PHYSICAL(0xA8000000) + i, &gSaveContext, SLOT_SIZE);
 
                 //! @bug The ??= below is interpreted as a trigraph for # by IDO
@@ -802,41 +807,33 @@ void Sram_VerifyAndLoadAllSaves(FileSelectState* fileSelect, SramContext* sramCt
 
     MemCpy(&fileSelect->deaths[0], sramCtx->readBuff + SLOT_OFFSET(0) + DEATHS, sizeof(fileSelect->deaths[0]));
     MemCpy(&fileSelect->deaths[1], sramCtx->readBuff + SLOT_OFFSET(1) + DEATHS, sizeof(fileSelect->deaths[0]));
-    MemCpy(&fileSelect->deaths[2], sramCtx->readBuff + SLOT_OFFSET(2) + DEATHS, sizeof(fileSelect->deaths[0]));
 
     MemCpy(&fileSelect->fileNames[0], sramCtx->readBuff + SLOT_OFFSET(0) + NAME, sizeof(fileSelect->fileNames[0]));
     MemCpy(&fileSelect->fileNames[1], sramCtx->readBuff + SLOT_OFFSET(1) + NAME, sizeof(fileSelect->fileNames[0]));
-    MemCpy(&fileSelect->fileNames[2], sramCtx->readBuff + SLOT_OFFSET(2) + NAME, sizeof(fileSelect->fileNames[0]));
 
     MemCpy(&fileSelect->healthCapacities[0], sramCtx->readBuff + SLOT_OFFSET(0) + HEALTH_CAP,
            sizeof(fileSelect->healthCapacities[0]));
     MemCpy(&fileSelect->healthCapacities[1], sramCtx->readBuff + SLOT_OFFSET(1) + HEALTH_CAP,
            sizeof(fileSelect->healthCapacities[0]));
-    MemCpy(&fileSelect->healthCapacities[2], sramCtx->readBuff + SLOT_OFFSET(2) + HEALTH_CAP,
-           sizeof(fileSelect->healthCapacities[0]));
 
     MemCpy(&fileSelect->questItems[0], sramCtx->readBuff + SLOT_OFFSET(0) + QUEST, sizeof(fileSelect->questItems[0]));
     MemCpy(&fileSelect->questItems[1], sramCtx->readBuff + SLOT_OFFSET(1) + QUEST, sizeof(fileSelect->questItems[0]));
-    MemCpy(&fileSelect->questItems[2], sramCtx->readBuff + SLOT_OFFSET(2) + QUEST, sizeof(fileSelect->questItems[0]));
 
     MemCpy(&fileSelect->n64ddFlags[0], sramCtx->readBuff + SLOT_OFFSET(0) + N64DD, sizeof(fileSelect->n64ddFlags[0]));
     MemCpy(&fileSelect->n64ddFlags[1], sramCtx->readBuff + SLOT_OFFSET(1) + N64DD, sizeof(fileSelect->n64ddFlags[0]));
-    MemCpy(&fileSelect->n64ddFlags[2], sramCtx->readBuff + SLOT_OFFSET(2) + N64DD, sizeof(fileSelect->n64ddFlags[0]));
 
     MemCpy(&fileSelect->defense[0], sramCtx->readBuff + SLOT_OFFSET(0) + DEFENSE, sizeof(fileSelect->defense[0]));
     MemCpy(&fileSelect->defense[1], sramCtx->readBuff + SLOT_OFFSET(1) + DEFENSE, sizeof(fileSelect->defense[0]));
-    MemCpy(&fileSelect->defense[2], sramCtx->readBuff + SLOT_OFFSET(2) + DEFENSE, sizeof(fileSelect->defense[0]));
 
 #if OOT_PAL
     MemCpy(&fileSelect->health[0], sramCtx->readBuff + SLOT_OFFSET(0) + HEALTH, sizeof(fileSelect->health[0]));
     MemCpy(&fileSelect->health[1], sramCtx->readBuff + SLOT_OFFSET(1) + HEALTH, sizeof(fileSelect->health[0]));
-    MemCpy(&fileSelect->health[2], sramCtx->readBuff + SLOT_OFFSET(2) + HEALTH, sizeof(fileSelect->health[0]));
 #endif
 
-    PRINTF("f_64dd=%d, %d, %d\n", fileSelect->n64ddFlags[0], fileSelect->n64ddFlags[1], fileSelect->n64ddFlags[2]);
-    PRINTF("heart_status=%d, %d, %d\n", fileSelect->defense[0], fileSelect->defense[1], fileSelect->defense[2]);
+    PRINTF("f_64dd=%d, %d\n", fileSelect->n64ddFlags[0], fileSelect->n64ddFlags[1]);
+    PRINTF("heart_status=%d, %d\n", fileSelect->defense[0], fileSelect->defense[1]);
 #if OOT_PAL
-    PRINTF("now_life=%d, %d, %d\n", fileSelect->health[0], fileSelect->health[1], fileSelect->health[2]);
+    PRINTF("now_life=%d, %d\n", fileSelect->health[0], fileSelect->health[1]);
 #endif
 }
 
@@ -911,8 +908,8 @@ void Sram_InitSave(FileSelectState* fileSelect, SramContext* sramCtx) {
     PRINTF("I=%x no=%d\n", offset, gSaveContext.fileNum);
     MemCpy(sramCtx->readBuff + offset, &gSaveContext, sizeof(Save));
 
-    offset = gSramSlotOffsets[gSaveContext.fileNum + 3];
-    PRINTF("I=%x no=%d\n", offset, gSaveContext.fileNum + 3);
+    offset = gSramSlotOffsets[gSaveContext.fileNum + 2];
+    PRINTF("I=%x no=%d\n", offset, gSaveContext.fileNum + 2);
     MemCpy(sramCtx->readBuff + offset, &gSaveContext, sizeof(Save));
 
     SRAM_WRITE(OS_K1_TO_PHYSICAL(0xA8000000), sramCtx->readBuff, SRAM_SIZE);
@@ -956,7 +953,7 @@ void Sram_EraseSave(FileSelectState* fileSelect, SramContext* sramCtx) {
     MemCpy(&fileSelect->n64ddFlags[fileSelect->selectedFileIndex], sramCtx->readBuff + offset + N64DD,
            sizeof(fileSelect->n64ddFlags[0]));
 
-    offset = gSramSlotOffsets[fileSelect->selectedFileIndex + 3];
+    offset = gSramSlotOffsets[fileSelect->selectedFileIndex + 2];
     MemCpy(sramCtx->readBuff + offset, &gSaveContext, sizeof(Save));
     SRAM_WRITE(OS_K1_TO_PHYSICAL(0xA8000000) + offset, &gSaveContext, SLOT_SIZE);
 
@@ -976,7 +973,7 @@ void Sram_CopySave(FileSelectState* fileSelect, SramContext* sramCtx) {
     offset = gSramSlotOffsets[fileSelect->copyDestFileIndex];
     MemCpy(sramCtx->readBuff + offset, &gSaveContext, sizeof(Save));
 
-    offset = gSramSlotOffsets[fileSelect->copyDestFileIndex + 3];
+    offset = gSramSlotOffsets[fileSelect->copyDestFileIndex + 2];
     MemCpy(sramCtx->readBuff + offset, &gSaveContext, sizeof(Save));
 
     SRAM_WRITE(OS_K1_TO_PHYSICAL(0xA8000000), sramCtx->readBuff, SRAM_SIZE);
@@ -1034,6 +1031,7 @@ void Sram_InitSram(GameState* gameState, SramContext* sramCtx) {
         }
     }
 
+    gSaveContext.quicktextSetting = sramCtx->readBuff[SRAM_HEADER_QUICKTEXT] & 1;
     gSaveContext.soundSetting = sramCtx->readBuff[SRAM_HEADER_SOUND] & 3;
     gSaveContext.zTargetSetting = sramCtx->readBuff[SRAM_HEADER_Z_TARGET] & 1;
 
diff --git a/src/gcc_fix/missing_gcc_functions.c b/src/gcc_fix/missing_gcc_functions.c
index 615dd2354..22f83d854 100644
--- a/src/gcc_fix/missing_gcc_functions.c
+++ b/src/gcc_fix/missing_gcc_functions.c
@@ -26,6 +26,12 @@ int memcmp(const void* s1, const void* s2, size_t n) {
     return 0;
 }
 
+char* strcpy (char *dst, const char *src)
+{
+    const size_t len = strlen (src);
+    return (char *) memcpy (dst, src, len + 1) + len;
+}
+
 // Conversions involving 64-bit integer types required by the O32 MIPS ABI.
 
 // f32 -> u64, negative values become 0
diff --git a/src/libc64/qrand.c b/src/libc64/qrand.c
index 69bfa11d7..6655e46c1 100644
--- a/src/libc64/qrand.c
+++ b/src/libc64/qrand.c
@@ -79,6 +79,21 @@ u32 Rand_Next(void) {
 #endif
 }
 
+u32 Rand_Next_Mod(u32 mod) {
+    if (mod == 0) {
+        return 0;
+    }
+
+    u8 count = 0;
+    u32 shift = mod;
+    while ((shift & 0x80000000) == 0) {
+        count++;
+        shift <<= 1;
+    }
+
+    return (Rand_Next() >> count) % mod;
+}
+
 /**
  * Seeds the pseudo-random number generator by providing a starting value.
  *
@@ -156,6 +171,21 @@ u32 Rand_Next_Variable(u32* rndNum) {
     return *rndNum = (*rndNum) * RAND_MULTIPLIER + RAND_INCREMENT;
 }
 
+u32 Rand_Next_Mod_Variable(u32* rndNum, u32 mod) {
+    if (mod == 0) {
+        return 0;
+    }
+
+    u8 count = 0;
+    u32 shift = mod;
+    while ((shift & 0x80000000) == 0) {
+        count++;
+        shift <<= 1;
+    }
+
+    return *rndNum = (*rndNum >> count) % mod;
+}
+
 /**
  * Generates the next pseudo-random floating-point number between 0.0f and 1.0f from the provided rndNum.
  *
diff --git a/src/libultra/os/thread.c b/src/libultra/os/thread.c
index a9429b6b9..b864c9a70 100644
--- a/src/libultra/os/thread.c
+++ b/src/libultra/os/thread.c
@@ -1,10 +1,11 @@
 #include "ultra64.h"
+#include "attributes.h"
 
-__OSThreadTail __osThreadTail = { NULL, OS_PRIORITY_THREADTAIL };
-OSThread* __osRunQueue = (OSThread*)&__osThreadTail;
-OSThread* __osActiveQueue = (OSThread*)&__osThreadTail;
-OSThread* __osRunningThread = NULL;
-OSThread* __osFaultedThread = NULL;
+SECTION_DATA NO_REORDER __OSThreadTail __osThreadTail = { NULL, OS_PRIORITY_THREADTAIL };
+SECTION_DATA NO_REORDER OSThread* __osRunQueue = (OSThread*)&__osThreadTail;
+SECTION_DATA NO_REORDER OSThread* __osActiveQueue = (OSThread*)&__osThreadTail;
+SECTION_DATA NO_REORDER OSThread* __osRunningThread = NULL;
+SECTION_DATA NO_REORDER OSThread* __osFaultedThread = NULL;
 
 void __osDequeueThread(register OSThread** queue, register OSThread* thread) {
     register OSThread* pred = (OSThread*)queue;
diff --git a/src/overlays/actors/ovl_Bg_Toki_Swd/z_bg_toki_swd.c b/src/overlays/actors/ovl_Bg_Toki_Swd/z_bg_toki_swd.c
index a3a385696..1f7b931c2 100644
--- a/src/overlays/actors/ovl_Bg_Toki_Swd/z_bg_toki_swd.c
+++ b/src/overlays/actors/ovl_Bg_Toki_Swd/z_bg_toki_swd.c
@@ -112,10 +112,11 @@ void func_808BAF40(BgTokiSwd* this, PlayState* play) {
         play->csCtx.script = gRevealMasterSwordCs;
         gSaveContext.cutsceneTrigger = 1;
     }
-    if (!LINK_IS_ADULT || GET_EVENTCHKINF(EVENTCHKINF_55)) {
+    if (!LINK_IS_ADULT || GET_EVENTCHKINF(EVENTCHKINF_55) || gSaveContext.save.randomizer.shuffleChests) {
         if (Actor_HasParent(&this->actor, play)) {
             if (!LINK_IS_ADULT) {
                 Item_Give(play, ITEM_SWORD_MASTER);
+                Item_Give(play, ITEM_MEDALLION_LIGHT); // Give in case cutscene is skipped
                 play->csCtx.script = gPullMasterSwordCs;
             } else {
                 play->csCtx.script = gPlaceMasterSwordCs;
diff --git a/src/overlays/actors/ovl_Demo_Kekkai/z_demo_kekkai.c b/src/overlays/actors/ovl_Demo_Kekkai/z_demo_kekkai.c
index 2a79aef45..032b44354 100644
--- a/src/overlays/actors/ovl_Demo_Kekkai/z_demo_kekkai.c
+++ b/src/overlays/actors/ovl_Demo_Kekkai/z_demo_kekkai.c
@@ -175,6 +175,7 @@ void DemoKekkai_SpawnParticles(DemoKekkai* this, PlayState* play) {
 void DemoKekkai_TowerBarrier(DemoKekkai* this, PlayState* play) {
     if ((play->csCtx.state != CS_STATE_IDLE) && (play->csCtx.actorCues[0] != NULL) &&
         (play->csCtx.actorCues[0]->id != 1) && (play->csCtx.actorCues[0]->id == 2)) {
+        Flags_SetEventChkInf(EVENTCHKINF_C3);
         if (!(this->sfxFlag & 1)) {
             Audio_PlayCutsceneEffectsSequence(SEQ_CS_EFFECTS_DISPEL_BARRIER);
             this->sfxFlag |= 1;
@@ -184,7 +185,6 @@ void DemoKekkai_TowerBarrier(DemoKekkai* this, PlayState* play) {
         } else {
             this->timer++;
             if (this->timer > 100) {
-                Flags_SetEventChkInf(EVENTCHKINF_C3);
                 Actor_Kill(&this->actor);
                 return;
             } else if (this->timer > 40) {
diff --git a/src/overlays/actors/ovl_En_Box/z_en_box.c b/src/overlays/actors/ovl_En_Box/z_en_box.c
index c4ef15919..eb1e4a94a 100644
--- a/src/overlays/actors/ovl_En_Box/z_en_box.c
+++ b/src/overlays/actors/ovl_En_Box/z_en_box.c
@@ -7,6 +7,7 @@
 #include "ichain.h"
 #include "one_point_cutscene.h"
 #include "printf.h"
+#include "randomizer_play.h"
 #include "sequence.h"
 #include "sfx.h"
 #include "sys_math3d.h"
@@ -109,6 +110,14 @@ void EnBox_ClipToGround(EnBox* this, PlayState* play) {
     }
 }
 
+GetItemID EnBox_GetContentsGetItemID(EnBox* this, PlayState* play) {
+    unsigned flag = PARAMS_GET_U(this->dyna.actor.params, 0, 5);
+    if (gSaveContext.save.randomizer.shuffleChests && !(play->sceneId == SCENE_TREASURE_BOX_SHOP && flag < 0x0A)) {
+        return gSaveContext.save.randomizer.chestContents[Randomizer_GetRandomizedChestContents(play->sceneId, flag)];
+    }
+    return PARAMS_GET_U(this->dyna.actor.params, 5, 7);
+}
+
 void EnBox_Init(Actor* thisx, PlayState* play2) {
     PlayState* play = play2;
     EnBox* this = (EnBox*)thisx;
@@ -195,6 +204,13 @@ void EnBox_Init(Actor* thisx, PlayState* play2) {
                    this->morphTable, 5);
     Animation_Change(&this->skelanime, anim, 1.5f, animFrameStart, endFrame, ANIMMODE_ONCE, 0.0f);
 
+    if (EnBox_GetContentsGetItemID(this, play) == GI_ICE_TRAP) {
+        // Spawn the object for the ice trap wind effect if the scene has not loaded it
+        if (Object_GetSlot(&play->objectCtx, OBJECT_FZ) == -1) {
+            Object_SpawnTemporary(&play->objectCtx, OBJECT_FZ);
+        }
+    }
+
     switch (this->type) {
         case ENBOX_TYPE_SMALL:
         case ENBOX_TYPE_6:
@@ -446,7 +462,7 @@ void EnBox_WaitOpen(EnBox* this, PlayState* play) {
         Actor_WorldToActorCoords(&this->dyna.actor, &sp4C, &player->actor.world.pos);
         if (sp4C.z > -50.0f && sp4C.z < 0.0f && fabsf(sp4C.y) < 10.0f && fabsf(sp4C.x) < 20.0f &&
             Player_IsFacingActor(&this->dyna.actor, 0x3000, play)) {
-            Actor_OfferGetItemNearby(&this->dyna.actor, play, -PARAMS_GET_U(this->dyna.actor.params, 5, 7));
+            Actor_OfferGetItemNearby(&this->dyna.actor, play, -EnBox_GetContentsGetItemID(this, play));
         }
         if (Flags_GetTreasure(play, PARAMS_GET_U(this->dyna.actor.params, 0, 5))) {
             EnBox_SetupAction(this, EnBox_Open);
@@ -559,7 +575,7 @@ void EnBox_Update(Actor* thisx, PlayState* play) {
             Actor_SetFocus(&this->dyna.actor, 40.0f);
     }
 
-    if (PARAMS_GET_U(this->dyna.actor.params, 5, 7) == GI_ICE_TRAP && this->actionFunc == EnBox_Open &&
+    if (EnBox_GetContentsGetItemID(this, play) == GI_ICE_TRAP && this->actionFunc == EnBox_Open &&
         this->skelanime.curFrame > 45 && this->iceSmokeTimer < 100) {
         EnBox_SpawnIceSmoke(this, play);
     }
diff --git a/src/overlays/actors/ovl_En_Mag/z_en_mag.c b/src/overlays/actors/ovl_En_Mag/z_en_mag.c
index 5c1e68f77..be0a87742 100644
--- a/src/overlays/actors/ovl_En_Mag/z_en_mag.c
+++ b/src/overlays/actors/ovl_En_Mag/z_en_mag.c
@@ -74,7 +74,7 @@ void EnMag_ResetSram(void) {
     SsSram_ReadWrite(OS_K1_TO_PHYSICAL(0xA8007000), buffer, 0x800, 1);
     SsSram_ReadWrite(OS_K1_TO_PHYSICAL(0xA8007800), buffer, 0x800, 1);
 
-    gSaveContext.soundSetting = gSaveContext.zTargetSetting = 0; // SOUND_SETTING_STEREO/Z_TARGET_SETTING_SWITCH
+    gSaveContext.quicktextSetting = gSaveContext.soundSetting = gSaveContext.zTargetSetting = 0; // QUICKTEXT_SETTING_OFF/SOUND_SETTING_STEREO/Z_TARGET_SETTING_SWITCH
     Audio_SetSoundOutputMode(gSaveContext.soundSetting);
 }
 #endif
@@ -571,6 +571,18 @@ void EnMag_DrawInner(Actor* thisx, PlayState* play, Gfx** gfxP) {
         FILENAME_UPPERCASE('R'),
         FILENAME_UPPERCASE('T'),
     };
+    static u8 randomizerFontIndices[] = {
+        FILENAME_UPPERCASE('R'),
+        FILENAME_UPPERCASE('A'),
+        FILENAME_UPPERCASE('N'),
+        FILENAME_UPPERCASE('D'),
+        FILENAME_UPPERCASE('O'),
+        FILENAME_UPPERCASE('M'),
+        FILENAME_UPPERCASE('I'),
+        FILENAME_UPPERCASE('Z'),
+        FILENAME_UPPERCASE('E'),
+        FILENAME_UPPERCASE('R'),
+    };
     static void* effectMaskTextures[] = {
         gTitleEffectMask00Tex, gTitleEffectMask01Tex, gTitleEffectMask02Tex,
         gTitleEffectMask10Tex, gTitleEffectMask11Tex, gTitleEffectMask12Tex,
@@ -657,6 +669,49 @@ void EnMag_DrawInner(Actor* thisx, PlayState* play, Gfx** gfxP) {
         EnMag_DrawTextureI8(&gfx, gTitleTheLegendOfTextTex, 72, 8, 153 + LOGO_X_SHIFT, 72, 72, 8, 1024, 1024);
         EnMag_DrawTextureI8(&gfx, gTitleOcarinaOfTimeTMTextTex, 96, 8, 151 + LOGO_X_SHIFT, 126, 96, 8, 1024, 1024);
 
+        // Draw "RANDOMIZER" Text
+        // Shadow
+        gDPPipeSync(gfx++);
+        gDPSetPrimColor(gfx++, 0, 0, 0, 0, 0, this->mainAlpha);
+
+        rectLeft = YREG(7) + 40 + 1;
+        for (i = 0; i < ARRAY_COUNT(randomizerFontIndices); i++) {
+            EnMag_DrawCharTexture(&gfx, font->fontBuf + randomizerFontIndices[i] * FONT_CHAR_TEX_SIZE, rectLeft, YREG(10) + 131 + 1);
+            rectLeft += YREG(8);
+            if (i == 0) {
+                rectLeft -= 1;
+            } else if (i == 4) {
+                rectLeft += 1;
+            } else if (i == 5) {
+                rectLeft += 2;
+            } else if (i == 6) {
+                rectLeft -= 4;
+            } else if (i == 8) {
+                rectLeft -= 1;
+            }
+        }
+
+        // Actual
+        gDPPipeSync(gfx++);
+        gDPSetPrimColor(gfx++, 0, 0, 100, 150, 255, this->mainAlpha);
+
+        rectLeft = YREG(7) + 40;
+        for (i = 0; i < ARRAY_COUNT(randomizerFontIndices); i++) {
+            EnMag_DrawCharTexture(&gfx, font->fontBuf + randomizerFontIndices[i] * FONT_CHAR_TEX_SIZE, rectLeft, YREG(10) + 131);
+            rectLeft += YREG(8);
+            if (i == 0) {
+                rectLeft -= 1;
+            } else if (i == 4) {
+                rectLeft += 1;
+            } else if (i == 5) {
+                rectLeft += 2;
+            } else if (i == 6) {
+                rectLeft -= 4;
+            } else if (i == 8) {
+                rectLeft -= 1;
+            }
+        }
+
 #if OOT_MQ
         gDPPipeSync(gfx++);
         gDPSetPrimColor(gfx++, 0, 0, 255, 255, 255, (s16)this->subAlpha);
diff --git a/src/overlays/actors/ovl_En_Md/z_en_md.c b/src/overlays/actors/ovl_En_Md/z_en_md.c
index 296f4d42a..1dda52a81 100644
--- a/src/overlays/actors/ovl_En_Md/z_en_md.c
+++ b/src/overlays/actors/ovl_En_Md/z_en_md.c
@@ -536,26 +536,30 @@ s16 EnMd_UpdateTalkState(PlayState* play, Actor* thisx) {
     }
 }
 
-u8 EnMd_ShouldSpawn(EnMd* this, PlayState* play) {
+bool EnMd_ShouldSpawn(EnMd* this, PlayState* play) {
     if (play->sceneId == SCENE_KOKIRI_FOREST) {
-        if (!GET_EVENTCHKINF(EVENTCHKINF_1C) && !GET_EVENTCHKINF(EVENTCHKINF_40)) {
-            return 1;
+        if ((gSaveContext.save.randomizer.shuffleChests
+                && (!GET_EVENTCHKINF(EVENTCHKINF_1C) || !GET_EVENTCHKINF(EVENTCHKINF_04)))
+                || (!GET_EVENTCHKINF(EVENTCHKINF_1C) && !GET_EVENTCHKINF(EVENTCHKINF_40))) {
+            return true;
         }
     }
 
     if (play->sceneId == SCENE_MIDOS_HOUSE) {
-        if (GET_EVENTCHKINF(EVENTCHKINF_1C) || GET_EVENTCHKINF(EVENTCHKINF_40)) {
+        if ((gSaveContext.save.randomizer.shuffleChests
+                && (GET_EVENTCHKINF(EVENTCHKINF_1C) || GET_EVENTCHKINF(EVENTCHKINF_40)) && GET_EVENTCHKINF(EVENTCHKINF_04))
+                || GET_EVENTCHKINF(EVENTCHKINF_1C) || GET_EVENTCHKINF(EVENTCHKINF_40)) {
             if (!LINK_IS_ADULT) {
-                return 1;
+                return true;
             }
         }
     }
 
     if (play->sceneId == SCENE_LOST_WOODS) {
-        return 1;
+        return true;
     }
 
-    return 0;
+    return false;
 }
 
 void EnMd_UpdateEyes(EnMd* this) {
diff --git a/src/overlays/actors/ovl_En_Okarina_Tag/z_en_okarina_tag.c b/src/overlays/actors/ovl_En_Okarina_Tag/z_en_okarina_tag.c
index 2ec4c8f08..889c6e5ce 100644
--- a/src/overlays/actors/ovl_En_Okarina_Tag/z_en_okarina_tag.c
+++ b/src/overlays/actors/ovl_En_Okarina_Tag/z_en_okarina_tag.c
@@ -326,6 +326,7 @@ void func_80ABF7CC(EnOkarinaTag* this, PlayState* play) {
     if ((Message_GetState(&play->msgCtx) == TEXT_STATE_EVENT) && Message_ShouldAdvance(play)) {
         Message_CloseTextbox(play);
         if (!CHECK_QUEST_ITEM(QUEST_SONG_SUN)) {
+            Item_Give(play, ITEM_SONG_SUN); // Give in case cutscene skipped
             play->csCtx.script = SEGMENTED_TO_VIRTUAL(gSunSongGraveSunSongTeachCs);
             gSaveContext.cutsceneTrigger = 1;
         }
diff --git a/src/overlays/actors/ovl_En_Po_Relay/z_en_po_relay.c b/src/overlays/actors/ovl_En_Po_Relay/z_en_po_relay.c
index 983dbf0d7..21ac6f726 100644
--- a/src/overlays/actors/ovl_En_Po_Relay/z_en_po_relay.c
+++ b/src/overlays/actors/ovl_En_Po_Relay/z_en_po_relay.c
@@ -157,7 +157,11 @@ void EnPoRelay_SetupRace(EnPoRelay* this) {
     EnPoRelay_Vec3sToVec3f(&vec, &D_80AD8C30[this->pathIndex]);
     this->actionTimer = ((s16)(this->actor.shape.rot.y - this->actor.world.rot.y - 0x8000) >> 0xB) % 32U;
     Interface_SetTimer(0);
-    this->hookshotSlotFull = INV_CONTENT(ITEM_HOOKSHOT) != ITEM_NONE;
+    if (gSaveContext.save.randomizer.shuffleChests) {
+        this->hookshotSlotFull = 0;
+    } else {
+        this->hookshotSlotFull = INV_CONTENT(ITEM_HOOKSHOT) != ITEM_NONE;
+    }
     this->unk_19A = Actor_WorldYawTowardPoint(&this->actor, &vec);
     this->actor.flags |= ACTOR_FLAG_LOCK_ON_DISABLED;
     Actor_PlaySfx(&this->actor, NA_SE_EN_PO_LAUGH);
@@ -339,7 +343,7 @@ void EnPoRelay_DisappearAndReward(EnPoRelay* this, PlayState* play) {
         }
     }
     if (Math_StepToF(&this->actor.scale.x, 0.0f, 0.001f) != 0) {
-        if (this->hookshotSlotFull != 0) {
+        if (this->hookshotSlotFull != 0 || (gSaveContext.save.randomizer.shuffleChests && Flags_GetClear(play, 4))) {
             Vec3f sp60;
             s32 pad1;
 
diff --git a/src/overlays/actors/ovl_En_Ru2/z_en_ru2.c b/src/overlays/actors/ovl_En_Ru2/z_en_ru2.c
index db44d32ed..fd7acf863 100644
--- a/src/overlays/actors/ovl_En_Ru2/z_en_ru2.c
+++ b/src/overlays/actors/ovl_En_Ru2/z_en_ru2.c
@@ -867,6 +867,8 @@ void EnRu2_StartSwimmingUp(EnRu2* this, PlayState* play) {
 }
 
 void EnRu2_EndSwimmingUp(EnRu2* this, PlayState* play) {
+    /* TODO: See if this line should be part of the quicktext setting instead of always on */
+    Camera_SetFinishedFlag(GET_ACTIVE_CAM(play));
     if (this->swimmingUpFrame > ((((u16)(kREG(3) + 0x28)) + ((u16)(kREG(2) + 0x96))) & 0xFFFF)) {
         Actor_Kill(&this->actor);
     }
diff --git a/src/overlays/actors/ovl_En_Xc/z_en_xc.c b/src/overlays/actors/ovl_En_Xc/z_en_xc.c
index 9d2ec1376..31ea89975 100644
--- a/src/overlays/actors/ovl_En_Xc/z_en_xc.c
+++ b/src/overlays/actors/ovl_En_Xc/z_en_xc.c
@@ -388,8 +388,12 @@ s32 EnXc_SerenadeCS(EnXc* this, PlayState* play) {
         Player* player = GET_PLAYER(play);
         s32 stateFlags = player->stateFlags1;
 
-        if (CHECK_OWNED_EQUIP(EQUIP_TYPE_BOOTS, EQUIP_INV_BOOTS_IRON) && !GET_EVENTCHKINF(EVENTCHKINF_52) &&
-            !(stateFlags & PLAYER_STATE1_29) && !Play_InCsMode(play)) {
+        bool shouldSpawn = CHECK_OWNED_EQUIP(EQUIP_TYPE_BOOTS, EQUIP_INV_BOOTS_IRON) && !GET_EVENTCHKINF(EVENTCHKINF_52);
+        if (gSaveContext.save.randomizer.shuffleChests) {
+            shouldSpawn = Flags_GetTreasure(play, 0x02) && !GET_EVENTCHKINF(EVENTCHKINF_52);
+        }
+
+        if (shouldSpawn && !(stateFlags & PLAYER_STATE1_29) && !Play_InCsMode(play)) {
             s32 pad;
 
             Cutscene_SetScript(play, gIceCavernSerenadeCs);
@@ -2213,6 +2217,10 @@ void EnXc_InitTempleOfTime(EnXc* this, PlayState* play) {
             gSaveContext.cutsceneTrigger = 1;
             this->action = SHEIK_ACTION_30;
         } else if (!GET_EVENTCHKINF(EVENTCHKINF_55)) {
+            if (gSaveContext.save.randomizer.shuffleChests) {
+                Vec3f* pos = &this->actor.world.pos;
+                pos->z -= 60;
+            }
             func_80B3C9EC(this);
         } else {
             Actor_Kill(&this->actor);
diff --git a/src/overlays/actors/ovl_Object_Kankyo/z_object_kankyo.c b/src/overlays/actors/ovl_Object_Kankyo/z_object_kankyo.c
index c17027975..3563f9b21 100644
--- a/src/overlays/actors/ovl_Object_Kankyo/z_object_kankyo.c
+++ b/src/overlays/actors/ovl_Object_Kankyo/z_object_kankyo.c
@@ -918,8 +918,48 @@ void ObjectKankyo_Beams(ObjectKankyo* this, PlayState* play) {
                     Audio_PlayCutsceneEffectsSequence(SEQ_CS_EFFECTS_TRIAL_DESTROY);
                 }
                 Math_ApproachZeroF(&this->effects[i].size, 0.1f, 0.1f);
+            } else if (Flags_GetEventChkInf(EVENTCHKINF_C3)) {
+                this->effects[i].size = 0.0f;
             }
         }
+    } else if (gSaveContext.cutsceneTrigger == 0) {
+        /* Skipped cutscene, scale beam anyway */
+        if (gSaveContext.save.entranceIndex == ENTR_INSIDE_GANONS_CASTLE_2) {
+            if (this->effects[0].size == 0.1f) {
+                Audio_PlayCutsceneEffectsSequence(SEQ_CS_EFFECTS_TRIAL_DESTROY);
+            }
+            Math_ApproachZeroF(&this->effects[0].size, 0.1f, 0.1f);
+        }
+        if (gSaveContext.save.entranceIndex == ENTR_INSIDE_GANONS_CASTLE_3) {
+            if (this->effects[1].size == 0.1f) {
+                Audio_PlayCutsceneEffectsSequence(SEQ_CS_EFFECTS_TRIAL_DESTROY);
+            }
+            Math_ApproachZeroF(&this->effects[1].size, 0.1f, 0.1f);
+        }
+        if (gSaveContext.save.entranceIndex == ENTR_INSIDE_GANONS_CASTLE_4) {
+            if (this->effects[2].size == 0.1f) {
+                Audio_PlayCutsceneEffectsSequence(SEQ_CS_EFFECTS_TRIAL_DESTROY);
+            }
+            Math_ApproachZeroF(&this->effects[2].size, 0.1f, 0.1f);
+        }
+        if (gSaveContext.save.entranceIndex == ENTR_INSIDE_GANONS_CASTLE_5) {
+            if (this->effects[3].size == 0.1f) {
+                Audio_PlayCutsceneEffectsSequence(SEQ_CS_EFFECTS_TRIAL_DESTROY);
+            }
+            Math_ApproachZeroF(&this->effects[3].size, 0.1f, 0.1f);
+        }
+        if (gSaveContext.save.entranceIndex == ENTR_INSIDE_GANONS_CASTLE_6) {
+            if (this->effects[4].size == 0.1f) {
+                Audio_PlayCutsceneEffectsSequence(SEQ_CS_EFFECTS_TRIAL_DESTROY);
+            }
+            Math_ApproachZeroF(&this->effects[4].size, 0.1f, 0.1f);
+        }
+        if (gSaveContext.save.entranceIndex == ENTR_INSIDE_GANONS_CASTLE_7) {
+            if (this->effects[5].size == 0.1f) {
+                Audio_PlayCutsceneEffectsSequence(SEQ_CS_EFFECTS_TRIAL_DESTROY);
+            }
+            Math_ApproachZeroF(&this->effects[5].size, 0.1f, 0.1f);
+        }
     }
 }
 
diff --git a/src/overlays/actors/ovl_player_actor/z_player.c b/src/overlays/actors/ovl_player_actor/z_player.c
index e8b942802..b897a62af 100644
--- a/src/overlays/actors/ovl_player_actor/z_player.c
+++ b/src/overlays/actors/ovl_player_actor/z_player.c
@@ -13718,7 +13718,7 @@ s32 func_8084DFF4(PlayState* play, Player* this) {
         }
     } else {
         if (Message_GetState(&play->msgCtx) == TEXT_STATE_CLOSING) {
-            if (this->getItemId == GI_SILVER_GAUNTLETS) {
+            if (play->sceneId == SCENE_DESERT_COLOSSUS && Flags_GetTreasure(play, 0x0B) && !GET_EVENTCHKINF(EVENTCHKINF_95)) {
                 play->nextEntranceIndex = ENTR_DESERT_COLOSSUS_0;
                 play->transitionTrigger = TRANS_TRIGGER_START;
                 gSaveContext.nextCutsceneIndex = 0xFFF1;
diff --git a/src/overlays/gamestates/ovl_file_choose/file_select.h b/src/overlays/gamestates/ovl_file_choose/file_select.h
index ae41c4dce..96f837a93 100644
--- a/src/overlays/gamestates/ovl_file_choose/file_select.h
+++ b/src/overlays/gamestates/ovl_file_choose/file_select.h
@@ -68,7 +68,11 @@ typedef enum ConfigMode {
     /* 37 */ CM_OPTIONS_MENU,
     /* 38 */ CM_START_OPTIONS,
     /* 39 */ CM_OPTIONS_TO_MAIN,
-    /* 40 */ CM_UNUSED_DELAY
+    /* 40 */ CM_MAIN_TO_RANDOMIZER,
+    /* 41 */ CM_RANDOMIZER_MENU,
+    /* 42 */ CM_START_RANDOMIZER_OPTIONS,
+    /* 43 */ CM_RANDOMIZER_TO_MAIN,
+    /* 44 */ CM_UNUSED_DELAY
 } ConfigMode;
 
 typedef enum SelectMode {
@@ -78,8 +82,10 @@ typedef enum SelectMode {
     /* 3 */ SM_CONFIRM_FILE,
     /* 4 */ SM_FADE_OUT_FILE_INFO,
     /* 5 */ SM_MOVE_FILE_TO_SLOT,
-    /* 6 */ SM_FADE_OUT,
-    /* 7 */ SM_LOAD_GAME
+    /* 6 */ SM_LOAD_SAVE,
+    /* 7 */ SM_SET_RANDO_SETTINGS,
+    /* 8 */ SM_FADE_OUT,
+    /* 9 */ SM_LOAD_GAME
 } SelectMode;
 
 typedef enum TitleLabel {
@@ -106,7 +112,6 @@ typedef enum WarningLabel {
 typedef enum MainMenuButtonIndex {
     /* 0 */ FS_BTN_MAIN_FILE_1,
     /* 1 */ FS_BTN_MAIN_FILE_2,
-    /* 2 */ FS_BTN_MAIN_FILE_3,
     /* 3 */ FS_BTN_MAIN_COPY,
     /* 4 */ FS_BTN_MAIN_ERASE,
     /* 5 */ FS_BTN_MAIN_OPTIONS
@@ -115,21 +120,18 @@ typedef enum MainMenuButtonIndex {
 typedef enum CopyMenuButtonIndex {
     /* 0 */ FS_BTN_COPY_FILE_1,
     /* 1 */ FS_BTN_COPY_FILE_2,
-    /* 2 */ FS_BTN_COPY_FILE_3,
     /* 3 */ FS_BTN_COPY_QUIT
 } CopyMenuButtonIndex;
 
 typedef enum EraseMenuButtonIndex {
     /* 0 */ FS_BTN_ERASE_FILE_1,
     /* 1 */ FS_BTN_ERASE_FILE_2,
-    /* 2 */ FS_BTN_ERASE_FILE_3,
     /* 3 */ FS_BTN_ERASE_QUIT
 } EraseMenuButtonIndex;
 
 typedef enum SelectMenuButtonIndex {
     /* 0 */ FS_BTN_SELECT_FILE_1,
     /* 1 */ FS_BTN_SELECT_FILE_2,
-    /* 2 */ FS_BTN_SELECT_FILE_3,
     /* 3 */ FS_BTN_SELECT_YES,
     /* 4 */ FS_BTN_SELECT_QUIT
 } SelectMenuButtonIndex;
@@ -149,10 +151,8 @@ typedef enum ActionButtonIndex {
 typedef enum SettingIndex {
     /* 0 */ FS_SETTING_AUDIO,
     /* 1 */ FS_SETTING_TARGET,
-#if OOT_PAL_N64
-    /* 2 */ FS_SETTING_LANGUAGE,
-#endif
-    /*   */ FS_SETTING_MAX
+    FS_SETTING_QUICKTEXT,
+    /* 2  */ FS_SETTING_MAX
 } SettingIndex;
 
 typedef enum CharPage {
@@ -211,7 +211,6 @@ void FileSelect_StartNameEntry(GameState* thisx);
 void FileSelect_UpdateOptionsMenu(GameState* thisx);
 void FileSelect_StartOptions(GameState* thisx);
 
-void FileSelect_InitModeDraw(GameState* thisx);
 void FileSelect_ConfigModeDraw(GameState* thisx);
 void FileSelect_SelectModeDraw(GameState* thisx);
 
@@ -221,8 +220,16 @@ void FileSelect_DrawOptions(GameState* thisx);
 void FileSelect_DrawNameEntry(GameState* thisx);
 void FileSelect_DrawCharacter(GraphicsContext* gfxCtx, void* texture, s16 vtx);
 
+void FileSelect_LoadSave(GameState* thisx);
+void FileSelect_RotateToRandomizerSettings(GameState* thisx);
+void FileSelect_StartRandomizerOptions(GameState* thisx);
+void FileSelect_UpdateRandomizerOptionsMenu(GameState* thisx);
+void FileSelect_RotateToMainFromRandomizer(GameState* thisx);
+void FileSelect_DrawRandomizerMenu(GameState* thisx);
+void FileSelect_DrawRandomizerSettings(GameState* thisx);
+
 #if OOT_VERSION == PAL_1_1
-extern s16 D_808124C0[];
+extern s16 fileNameCharWidth[];
 #endif
 
 #endif
diff --git a/src/overlays/gamestates/ovl_file_choose/z_file_choose.c b/src/overlays/gamestates/ovl_file_choose/z_file_choose.c
index e8934c373..f6ddbf26f 100644
--- a/src/overlays/gamestates/ovl_file_choose/z_file_choose.c
+++ b/src/overlays/gamestates/ovl_file_choose/z_file_choose.c
@@ -14,6 +14,7 @@
 #include "n64dd.h"
 #endif
 #include "printf.h"
+#include "randomizer_state.h"
 #include "regs.h"
 #include "rumble.h"
 #include "segment_symbols.h"
@@ -33,53 +34,9 @@
 #include "z64ss_sram.h"
 #include "z64view.h"
 
-#if OOT_PAL_N64
-#include "assets/objects/object_mag/object_mag.h"
-#endif
 #include "assets/textures/title_static/title_static.h"
 #include "assets/textures/parameter_static/parameter_static.h"
 
-#if OOT_PAL_N64
-static s32 sInitialLanguageAlphaAsInt = 100;
-static f32 sInitialLanguageAlphaStep = 8.0f;
-static f32 sInitialLanguageAlpha = 100.0f;
-
-static s16 sInitialLanguageStickAdjX;
-static s16 sInitialLanguageStickXDir;
-static s16 sInitialLanguageInputTimerX;
-
-typedef struct InitialLanguageTextureInfo {
-    /* 0x00 */ void* texture;
-    /* 0x04 */ u16 width;
-    /* 0x06 */ u16 height;
-    /* 0x08 */ u32 x1;
-    /* 0x0C */ u32 y1;
-    /* 0x10 */ u32 x2;
-    /* 0x14 */ u32 y2;
-} InitialLanguageTextureInfo; // size = 0x18
-
-static InitialLanguageTextureInfo sInitialLanguageTextures[] = {
-    { gFileSelInitialLanguageChoiceENGTex, 80, 32, 40, 70, 120, 102 },
-    { gFileSelInitialLanguageChoiceGERTex, 80, 32, 120, 70, 200, 102 },
-    { gFileSelInitialLanguageChoiceFRATex, 80, 32, 200, 70, 280, 102 },
-};
-
-typedef struct InitialLanguageCursorInfo {
-    /* 0x00 */ u32 x1;
-    /* 0x04 */ u32 y1;
-    /* 0x08 */ u32 x2;
-    /* 0x0C */ u32 y2;
-} InitialLanguageCursorInfo; // size = 0x10
-
-static InitialLanguageCursorInfo sInitialLanguageCursors[] = {
-    { 48, 52, 120, 124 },
-    { 128, 52, 200, 124 },
-    { 208, 52, 280, 124 },
-};
-#endif
-
-static s16 sUnused = 106;
-
 static s16 sScreenFillAlpha = 255;
 
 static Gfx sScreenFillSetupDL[] = {
@@ -100,233 +57,6 @@ static s16 sWindowContentColors[2][3] = {
     { 100, 100, 100 }, // gray
 };
 
-#if OOT_PAL_N64
-void FileSelect_UpdateInitialLanguageMenu(FileSelectState* this) {
-    SramContext* sramCtx = &this->sramCtx;
-    Input* input = &this->state.input[0];
-
-    if (gSaveContext.language >= LANGUAGE_MAX) {
-        gSaveContext.language = 0;
-    }
-
-    sInitialLanguageAlpha += sInitialLanguageAlphaStep;
-    if (sInitialLanguageAlphaStep < 0.0f) {
-        if (sInitialLanguageAlpha < 100.0f) {
-            sInitialLanguageAlpha = 100.0f;
-            sInitialLanguageAlphaStep *= -1.0f;
-        }
-    } else if (sInitialLanguageAlphaStep > 0.0f) {
-        if (sInitialLanguageAlpha > 255.0f) {
-            sInitialLanguageAlpha = 255.0f;
-            sInitialLanguageAlphaStep *= -1.0f;
-        }
-    }
-
-    sInitialLanguageAlphaAsInt = (s32)sInitialLanguageAlpha;
-    sInitialLanguageStickAdjX = (s16)input->rel.stick_x;
-    if (sInitialLanguageStickAdjX < -30) {
-        if (sInitialLanguageStickXDir == -1) {
-            sInitialLanguageInputTimerX -= 1;
-            if (sInitialLanguageInputTimerX < 0) {
-                sInitialLanguageInputTimerX = 2;
-            } else {
-                sInitialLanguageStickAdjX = 0;
-            }
-        } else {
-            sInitialLanguageInputTimerX = 10;
-            sInitialLanguageStickXDir = -1;
-        }
-    } else if (sInitialLanguageStickAdjX > 30) {
-        if (sInitialLanguageStickXDir == 1) {
-            sInitialLanguageInputTimerX -= 1;
-            if (sInitialLanguageInputTimerX < 0) {
-                sInitialLanguageInputTimerX = 2;
-            } else {
-                sInitialLanguageStickAdjX = 0;
-            }
-        } else {
-            sInitialLanguageInputTimerX = 10;
-            sInitialLanguageStickXDir = 1;
-        }
-    } else {
-        sInitialLanguageStickXDir = 0;
-    }
-
-    if (CHECK_BTN_ALL(input->press.button, BTN_A) || CHECK_BTN_ALL(input->press.button, BTN_B) ||
-        CHECK_BTN_ALL(input->press.button, BTN_START)) {
-        Audio_PlaySfxGeneral(NA_SE_SY_FSEL_DECIDE_L, &gSfxDefaultPos, 4, &gSfxDefaultFreqAndVolScale,
-                             &gSfxDefaultFreqAndVolScale, &gSfxDefaultReverb);
-        Audio_PlaySfxGeneral(NA_SE_SY_FSEL_DECIDE_L, &gSfxDefaultPos, 4, &gSfxDefaultFreqAndVolScale,
-                             &gSfxDefaultFreqAndVolScale, &gSfxDefaultReverb);
-        sramCtx->readBuff[2] = gSaveContext.language;
-        Sram_WriteSramHeader(sramCtx);
-        this->configMode++;
-        return;
-    }
-
-    if (sInitialLanguageStickAdjX < -30) {
-        Audio_PlaySfxGeneral(NA_SE_SY_FSEL_CURSOR, &gSfxDefaultPos, 4, &gSfxDefaultFreqAndVolScale,
-                             &gSfxDefaultFreqAndVolScale, &gSfxDefaultReverb);
-        gSaveContext.language--;
-        if (gSaveContext.language >= LANGUAGE_MAX) {
-            gSaveContext.language = LANGUAGE_MAX - 1;
-        }
-    } else if (sInitialLanguageStickAdjX > 30) {
-        Audio_PlaySfxGeneral(NA_SE_SY_FSEL_CURSOR, &gSfxDefaultPos, 4, &gSfxDefaultFreqAndVolScale,
-                             &gSfxDefaultFreqAndVolScale, &gSfxDefaultReverb);
-        gSaveContext.language++;
-        if (gSaveContext.language >= LANGUAGE_MAX) {
-            gSaveContext.language = 0;
-        }
-    }
-}
-
-void FileSelect_DrawImageRGBA32(GraphicsContext* gfxCtx, s16 centerX, s16 centerY, u8* source, u32 width, u32 height) {
-    u8* curTexture;
-    s32 textureCount;
-    s32 rectLeft;
-    s32 rectTop;
-    u32 textureHeight;
-    s32 remainingSize;
-    s32 textureSize;
-    s32 pad;
-    s32 i;
-
-    OPEN_DISPS(gfxCtx, "../z_file_choose.c", UNK_LINE);
-
-    Gfx_SetupDL_56Opa(gfxCtx);
-
-    curTexture = source;
-    rectLeft = centerX - (width / 2);
-    rectTop = centerY - (height / 2);
-    remainingSize = (width * height) << 2;
-    textureHeight = 4096 / (width << 2);
-    textureSize = (width * textureHeight) << 2;
-    textureCount = remainingSize / textureSize;
-    if ((remainingSize % textureSize) != 0) {
-        textureCount++;
-    }
-
-    gDPSetTileCustom(POLY_OPA_DISP++, G_IM_FMT_RGBA, G_IM_SIZ_32b, 0, 0, width - 1, textureHeight - 1, 0,
-                     G_TX_NOMIRROR | G_TX_CLAMP, G_TX_NOMIRROR | G_TX_CLAMP, G_TX_NOMASK, G_TX_NOMASK, G_TX_NOLOD,
-                     G_TX_NOLOD);
-
-    remainingSize -= textureSize;
-
-    for (i = 0; i < textureCount; i++) {
-        gDPSetTextureImage(POLY_OPA_DISP++, G_IM_FMT_RGBA, G_IM_SIZ_32b, width, curTexture);
-
-        gDPLoadSync(POLY_OPA_DISP++);
-        gDPLoadTile(POLY_OPA_DISP++, G_TX_LOADTILE, 0, 0, (width - 1) << 2, (textureHeight - 1) << 2);
-
-        gSPTextureRectangle(POLY_OPA_DISP++, rectLeft << 2, rectTop << 2, (rectLeft + (s32)width) << 2,
-                            (rectTop + textureHeight) << 2, G_TX_RENDERTILE, 0, 0, 1 << 10, 1 << 10);
-
-        curTexture += textureSize;
-        rectTop += textureHeight;
-
-        if ((remainingSize - textureSize) < 0) {
-            if (remainingSize > 0) {
-                textureHeight = remainingSize / (s32)(width << 2);
-                remainingSize -= textureSize;
-
-                gDPSetTileCustom(POLY_OPA_DISP++, G_IM_FMT_RGBA, G_IM_SIZ_32b, 0, 0, width - 1, textureHeight - 1, 0,
-                                 G_TX_NOMIRROR | G_TX_CLAMP, G_TX_NOMIRROR | G_TX_CLAMP, G_TX_NOMASK, G_TX_NOMASK,
-                                 G_TX_NOLOD, G_TX_NOLOD);
-            }
-        } else {
-            remainingSize -= textureSize;
-        }
-    }
-
-    CLOSE_DISPS(gfxCtx, "../z_file_choose.c", UNK_LINE);
-}
-
-void FileSelect_DrawInitialLanguageMenu(FileSelectState* this) {
-    u8* source;
-    s32 i;
-    s32 y1;
-    s32 y2;
-
-    OPEN_DISPS(this->state.gfxCtx, "../z_file_choose.c", UNK_LINE);
-
-    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 255, 255, 70 + WREG(0));
-    FileSelect_DrawImageRGBA32(this->state.gfxCtx, 160, 85 + WREG(1), (u8*)gTitleZeldaShieldLogoTex, 160, 160);
-
-    Gfx_SetupDL_39Opa(this->state.gfxCtx);
-
-    gDPSetAlphaCompare(POLY_OPA_DISP++, G_AC_NONE);
-    gDPSetCombineMode(POLY_OPA_DISP++, G_CC_MODULATEIA_PRIM, G_CC_MODULATEIA_PRIM);
-    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 255, 255, 255);
-
-    gDPLoadTextureBlock(POLY_OPA_DISP++, gTitleCopyright1998Tex, G_IM_FMT_IA, G_IM_SIZ_8b, 128, 16, 0,
-                        G_TX_NOMIRROR | G_TX_CLAMP, G_TX_NOMIRROR | G_TX_CLAMP, G_TX_NOMASK, G_TX_NOMASK, G_TX_NOLOD,
-                        G_TX_NOLOD);
-
-    gSPTextureRectangle(POLY_OPA_DISP++, 94 << 2, 198 << 2, 222 << 2, 214 << 2, G_TX_RENDERTILE, 0, 0, 1 << 10,
-                        1 << 10);
-
-    Gfx_SetupDL_39Opa(this->state.gfxCtx);
-
-    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 100, 100, 255, sInitialLanguageAlphaAsInt);
-
-    gDPLoadTextureBlock_4b(POLY_OPA_DISP++, gFileSelInitialLanguageCursorTex, G_IM_FMT_I, 48, 48, 0,
-                           G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMASK, G_TX_NOMASK, G_TX_NOLOD,
-                           G_TX_NOLOD);
-
-    gSPTextureRectangle(POLY_OPA_DISP++, (sInitialLanguageCursors[gSaveContext.language].x1 + GREG(1)) << 2,
-                        (sInitialLanguageCursors[gSaveContext.language].y1 + GREG(2)) << 2,
-                        (sInitialLanguageCursors[gSaveContext.language].x2 + GREG(1)) << 2,
-                        (sInitialLanguageCursors[gSaveContext.language].y2 + GREG(2)) << 2, G_TX_RENDERTILE, 0, 0,
-                        3 << 8, 3 << 8);
-
-    gDPPipeSync(POLY_OPA_DISP++);
-    gDPSetRenderMode(POLY_OPA_DISP++, G_RM_XLU_SURF, G_RM_XLU_SURF2);
-    gDPSetCombineMode(POLY_OPA_DISP++, G_CC_BLENDPEDECALA, G_CC_BLENDPEDECALA);
-    gDPSetEnvColor(POLY_OPA_DISP++, 0, 0, 50, 255);
-
-    for (i = 0; i < LANGUAGE_MAX; i++) {
-        gDPPipeSync(POLY_OPA_DISP++);
-
-        if (i == gSaveContext.language) {
-            gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 255, 255, 255);
-        } else {
-            gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 50, 50, 100, 255);
-        }
-
-        gDPLoadTextureBlock(POLY_OPA_DISP++, sInitialLanguageTextures[i].texture, G_IM_FMT_IA, G_IM_SIZ_8b,
-                            sInitialLanguageTextures[i].width, sInitialLanguageTextures[i].height, 0,
-                            G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMASK, G_TX_NOMASK, G_TX_NOLOD,
-                            G_TX_NOLOD);
-
-        gSPTextureRectangle(POLY_OPA_DISP++, (sInitialLanguageTextures[i].x1 + GREG(1)) << 2,
-                            (sInitialLanguageTextures[i].y1 + GREG(2)) << 2,
-                            (sInitialLanguageTextures[i].x2 + GREG(1)) << 2,
-                            (sInitialLanguageTextures[i].y2 + GREG(2)) << 2, G_TX_RENDERTILE, 0, 0, 1 << 10, 1 << 10);
-    }
-
-    gDPPipeSync(POLY_OPA_DISP++);
-
-    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 220, 180, 30, 255);
-    gDPSetEnvColor(POLY_OPA_DISP++, 60, 20, 0, 255);
-
-    source = (u8*)gFileSelSelectYourLanguageTex;
-    y1 = 120 + GREG(3);
-    for (i = 0; i < 8; i++, source += 0x500) {
-        y2 = y1 + 8;
-        gDPLoadTextureBlock(POLY_OPA_DISP++, source, G_IM_FMT_IA, G_IM_SIZ_8b, 160, 8, 0, G_TX_NOMIRROR | G_TX_WRAP,
-                            G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMASK, G_TX_NOMASK, G_TX_NOLOD, G_TX_NOLOD);
-
-        gSPTextureRectangle(POLY_OPA_DISP++, (80 + GREG(4)) << 2, y1 << 2, (240 + GREG(4)) << 2, y2 << 2,
-                            G_TX_RENDERTILE, 0, 0, 1 << 10, 1 << 10);
-
-        y1 = y2;
-    }
-
-    CLOSE_DISPS(this->state.gfxCtx, "../z_file_choose.c", UNK_LINE);
-}
-#endif
-
 void FileSelect_SetView(FileSelectState* this, f32 eyeX, f32 eyeY, f32 eyeZ) {
     Vec3f eye;
     Vec3f lookAt;
@@ -371,7 +101,7 @@ void FileSelect_InitModeUpdate(GameState* thisx) {
     if (this->configMode == CM_FADE_IN_START) {
         Sram_VerifyAndLoadAllSaves(this, sramCtx);
 
-        if (!SLOT_OCCUPIED(sramCtx, 0) && !SLOT_OCCUPIED(sramCtx, 1) && !SLOT_OCCUPIED(sramCtx, 2)) {
+        if (!SLOT_OCCUPIED(sramCtx, 0) && !SLOT_OCCUPIED(sramCtx, 1)) {
             this->configMode++; // = CM_FADE_IN_END
         } else {
             this->menuMode = FS_MENU_MODE_CONFIG;
@@ -386,8 +116,6 @@ void FileSelect_InitModeUpdate(GameState* thisx) {
             sScreenFillAlpha = 0;
             this->configMode++; // = CM_MAIN_MENU
         }
-    } else if (this->configMode == CM_MAIN_MENU) {
-        FileSelect_UpdateInitialLanguageMenu(this);
     } else {
         sScreenFillAlpha += 40;
         if (sScreenFillAlpha >= 255) {
@@ -401,12 +129,6 @@ void FileSelect_InitModeUpdate(GameState* thisx) {
 }
 
 void FileSelect_InitModeDraw(GameState* thisx) {
-#if OOT_PAL_N64
-    FileSelectState* this = (FileSelectState*)thisx;
-
-    Gfx_SetupDL_39Opa(this->state.gfxCtx);
-    FileSelect_DrawInitialLanguageMenu(this);
-#endif
 }
 
 /**
@@ -422,7 +144,7 @@ void FileSelect_FadeInMenuElements(GameState* thisx) {
     this->titleAlpha[0] += VREG(1);
     this->windowAlpha += VREG(2);
 
-    for (i = 0; i < 3; i++) {
+    for (i = 0; i < 2; i++) {
         this->fileButtonAlpha[i] = this->windowAlpha;
 
         if (SLOT_OCCUPIED(sramCtx, i)) {
@@ -519,7 +241,7 @@ void FileSelect_UpdateMainMenu(GameState* thisx) {
     Input* input = &this->state.input[0];
 
     if (CHECK_BTN_ALL(input->press.button, BTN_START) || CHECK_BTN_ALL(input->press.button, BTN_A)) {
-        if (this->buttonIndex <= FS_BTN_MAIN_FILE_3) {
+        if (this->buttonIndex <= FS_BTN_MAIN_FILE_2) {
             PRINTF("REGCK_ALL[%x]=%x,%x,%x,%x,%x,%x\n", this->buttonIndex, GET_NEWF(sramCtx, this->buttonIndex, 0),
                    GET_NEWF(sramCtx, this->buttonIndex, 1), GET_NEWF(sramCtx, this->buttonIndex, 2),
                    GET_NEWF(sramCtx, this->buttonIndex, 3), GET_NEWF(sramCtx, this->buttonIndex, 4),
@@ -615,11 +337,11 @@ void FileSelect_UpdateMainMenu(GameState* thisx) {
         }
 
         if (this->buttonIndex == FS_BTN_MAIN_COPY) {
-            if (!SLOT_OCCUPIED(sramCtx, 0) && !SLOT_OCCUPIED(sramCtx, 1) && !SLOT_OCCUPIED(sramCtx, 2)) {
+            if (!SLOT_OCCUPIED(sramCtx, 0) && !SLOT_OCCUPIED(sramCtx, 1)) {
                 this->warningButtonIndex = this->buttonIndex;
                 this->warningLabel = FS_WARNING_NO_FILE_COPY;
                 this->emptyFileTextAlpha = 255;
-            } else if (SLOT_OCCUPIED(sramCtx, 0) && SLOT_OCCUPIED(sramCtx, 1) && SLOT_OCCUPIED(sramCtx, 2)) {
+            } else if (SLOT_OCCUPIED(sramCtx, 0) && SLOT_OCCUPIED(sramCtx, 1)) {
                 this->warningButtonIndex = this->buttonIndex;
                 this->warningLabel = FS_WARNING_NO_EMPTY_FILES;
                 this->emptyFileTextAlpha = 255;
@@ -627,7 +349,7 @@ void FileSelect_UpdateMainMenu(GameState* thisx) {
                 this->warningLabel = FS_WARNING_NONE;
             }
         } else if (this->buttonIndex == FS_BTN_MAIN_ERASE) {
-            if (!SLOT_OCCUPIED(sramCtx, 0) && !SLOT_OCCUPIED(sramCtx, 1) && !SLOT_OCCUPIED(sramCtx, 2)) {
+            if (!SLOT_OCCUPIED(sramCtx, 0) && !SLOT_OCCUPIED(sramCtx, 1)) {
                 this->warningButtonIndex = this->buttonIndex;
                 this->warningLabel = FS_WARNING_NO_FILE_ERASE;
                 this->emptyFileTextAlpha = 255;
@@ -709,26 +431,28 @@ void FileSelect_RotateToMain(GameState* thisx) {
 }
 
 static void (*sConfigModeUpdateFuncs[])(GameState*) = {
-    FileSelect_StartFadeIn,        FileSelect_FinishFadeIn,
-    FileSelect_UpdateMainMenu,     FileSelect_SetupCopySource,
-    FileSelect_SelectCopySource,   FileSelect_SetupCopyDest1,
-    FileSelect_SetupCopyDest2,     FileSelect_SelectCopyDest,
-    FileSelect_ExitToCopySource1,  FileSelect_ExitToCopySource2,
-    FileSelect_SetupCopyConfirm1,  FileSelect_SetupCopyConfirm2,
-    FileSelect_CopyConfirm,        FileSelect_ReturnToCopyDest,
-    FileSelect_CopyAnim1,          FileSelect_CopyAnim2,
-    FileSelect_CopyAnim3,          FileSelect_CopyAnim4,
-    FileSelect_CopyAnim5,          FileSelect_ExitCopyToMain,
-    FileSelect_SetupEraseSelect,   FileSelect_EraseSelect,
-    FileSelect_SetupEraseConfirm1, FileSelect_SetupEraseConfirm2,
-    FileSelect_EraseConfirm,       FileSelect_ExitToEraseSelect1,
-    FileSelect_ExitToEraseSelect2, FileSelect_EraseAnim1,
-    FileSelect_EraseAnim2,         FileSelect_EraseAnim3,
-    FileSelect_ExitEraseToMain,    FileSelect_UnusedCM31,
-    FileSelect_RotateToNameEntry,  FileSelect_UpdateKeyboardCursor,
-    FileSelect_StartNameEntry,     FileSelect_RotateToMain,
-    FileSelect_RotateToOptions,    FileSelect_UpdateOptionsMenu,
-    FileSelect_StartOptions,       FileSelect_RotateToMain,
+    FileSelect_StartFadeIn,                 FileSelect_FinishFadeIn,
+    FileSelect_UpdateMainMenu,              FileSelect_SetupCopySource,
+    FileSelect_SelectCopySource,            FileSelect_SetupCopyDest1,
+    FileSelect_SetupCopyDest2,              FileSelect_SelectCopyDest,
+    FileSelect_ExitToCopySource1,           FileSelect_ExitToCopySource2,
+    FileSelect_SetupCopyConfirm1,           FileSelect_SetupCopyConfirm2,
+    FileSelect_CopyConfirm,                 FileSelect_ReturnToCopyDest,
+    FileSelect_CopyAnim1,                   FileSelect_CopyAnim2,
+    FileSelect_CopyAnim3,                   FileSelect_CopyAnim4,
+    FileSelect_CopyAnim5,                   FileSelect_ExitCopyToMain,
+    FileSelect_SetupEraseSelect,            FileSelect_EraseSelect,
+    FileSelect_SetupEraseConfirm1,          FileSelect_SetupEraseConfirm2,
+    FileSelect_EraseConfirm,                FileSelect_ExitToEraseSelect1,
+    FileSelect_ExitToEraseSelect2,          FileSelect_EraseAnim1,
+    FileSelect_EraseAnim2,                  FileSelect_EraseAnim3,
+    FileSelect_ExitEraseToMain,             FileSelect_UnusedCM31,
+    FileSelect_RotateToNameEntry,           FileSelect_UpdateKeyboardCursor,
+    FileSelect_StartNameEntry,              FileSelect_RotateToMain,
+    FileSelect_RotateToOptions,             FileSelect_UpdateOptionsMenu,
+    FileSelect_StartOptions,                FileSelect_RotateToMain,
+    FileSelect_RotateToRandomizerSettings,  FileSelect_UpdateRandomizerOptionsMenu,
+    FileSelect_StartRandomizerOptions,      FileSelect_RotateToMainFromRandomizer,
     FileSelect_UnusedCMDelay,
 };
 
@@ -857,303 +581,323 @@ void FileSelect_SetWindowVtx(GameState* thisx) {
     }
 }
 
-static s16 D_80812818[] = { 0x001A, 0x000A, 0x000A, 0x000A };
-static s16 D_80812820[] = { 0x0020, 0x000C, 0x000C, 0x000C };
-static s16 D_80812828[] = { 0x0010, 0x000C, 0x000C, 0x000C };
-static s16 D_80812830[] = { 0x0040, 0x0054, 0x0068, 0x0274, 0x0278, 0x027C };
-static s16 D_8081283C[] = { 0x0040, 0x0054, 0x0068, 0x0278 };
-static s16 D_80812844[] = { 0x0274, 0x0278 };
-static s16 D_80812848[] = { 0x0274, 0x0278 };
+static s16 sDeathCounterXOffsets[] = { 0x001A, 0x000A, 0x000A, 0x000A };
+static s16 sDeathCounterTextureWidths[] = { 0x0020, 0x000C, 0x000C, 0x000C };  // index 0 doesn't seem to affect anything
+static s16 sDeathCounterTextureHeights[] = { 0x0010, 0x000C, 0x000C, 0x000C };  // index 0 doesn't seem to affect anything
+static s16 sSelectMenuButtonYOffsets[] = { 0x002C, 0x0040, 0x01A4, 0x01A8, 0x01AC };
+static s16 sCopyEraseSelectButtonYOffsets[] = { 0x0054, 0x0040, 0x01AC };
+static s16 sCopyEraseConfirmButtonYOffsets[] = { 0x01A4, 0x01AC };
+static s16 sFileSelectConfirmButtonYOffsets[] = { 0x01A4, 0x01AC };
 
 void FileSelect_SetWindowContentVtx(GameState* thisx) {
     FileSelectState* this = (FileSelectState*)thisx;
     SramContext* sramCtx = &this->sramCtx;
-    s16 phi_t2;
-    s16 phi_t0;
-    s16 phi_t5;
-    s16 phi_a1;
-    s16 phi_ra;
-    s16 temp_t1;
+    s16 currentVtx;
+    s16 currentPosX;
+    s16 buttonIndex;
+    s16 i;
+    s16 currentPosY;
+    s16 yOffset;
 #if OOT_PAL_N64
     u8 fileNameChar;
 #endif
 
-    this->windowContentVtx = GRAPH_ALLOC(this->state.gfxCtx, 0x288 * sizeof(Vtx));
+    this->windowContentVtx = GRAPH_ALLOC(this->state.gfxCtx, 0x1B8 * sizeof(Vtx));
 
-    for (phi_t2 = 0; phi_t2 < 0x288; phi_t2 += 4) {
-        this->windowContentVtx[phi_t2].v.ob[0] = this->windowContentVtx[phi_t2 + 2].v.ob[0] = 0x12C;
-        this->windowContentVtx[phi_t2 + 1].v.ob[0] = this->windowContentVtx[phi_t2 + 3].v.ob[0] =
-            this->windowContentVtx[phi_t2].v.ob[0] + 0x10;
+    for (currentVtx = 0; currentVtx < 0x1B8; currentVtx += 4) {
+        this->windowContentVtx[currentVtx].v.ob[0] = this->windowContentVtx[currentVtx + 2].v.ob[0] = 0x12C;
+        this->windowContentVtx[currentVtx + 1].v.ob[0] = this->windowContentVtx[currentVtx + 3].v.ob[0] =
+            this->windowContentVtx[currentVtx].v.ob[0] + 0x10;
 
-        this->windowContentVtx[phi_t2].v.ob[1] = this->windowContentVtx[phi_t2 + 1].v.ob[1] = 0;
-        this->windowContentVtx[phi_t2 + 2].v.ob[1] = this->windowContentVtx[phi_t2 + 3].v.ob[1] =
-            this->windowContentVtx[phi_t2].v.ob[1] - 0x10;
+        this->windowContentVtx[currentVtx].v.ob[1] = this->windowContentVtx[currentVtx + 1].v.ob[1] = 0;
+        this->windowContentVtx[currentVtx + 2].v.ob[1] = this->windowContentVtx[currentVtx + 3].v.ob[1] =
+            this->windowContentVtx[currentVtx].v.ob[1] - 0x10;
 
-        this->windowContentVtx[phi_t2].v.ob[2] = this->windowContentVtx[phi_t2 + 1].v.ob[2] =
-            this->windowContentVtx[phi_t2 + 2].v.ob[2] = this->windowContentVtx[phi_t2 + 3].v.ob[2] = 0;
+        this->windowContentVtx[currentVtx].v.ob[2] = this->windowContentVtx[currentVtx + 1].v.ob[2] =
+            this->windowContentVtx[currentVtx + 2].v.ob[2] = this->windowContentVtx[currentVtx + 3].v.ob[2] = 0;
 
-        this->windowContentVtx[phi_t2].v.flag = this->windowContentVtx[phi_t2 + 1].v.flag =
-            this->windowContentVtx[phi_t2 + 2].v.flag = this->windowContentVtx[phi_t2 + 3].v.flag = 0;
+        this->windowContentVtx[currentVtx].v.flag = this->windowContentVtx[currentVtx + 1].v.flag =
+            this->windowContentVtx[currentVtx + 2].v.flag = this->windowContentVtx[currentVtx + 3].v.flag = 0;
 
-        this->windowContentVtx[phi_t2].v.tc[0] = this->windowContentVtx[phi_t2].v.tc[1] =
-            this->windowContentVtx[phi_t2 + 1].v.tc[1] = this->windowContentVtx[phi_t2 + 2].v.tc[0] = 0;
+        this->windowContentVtx[currentVtx].v.tc[0] = this->windowContentVtx[currentVtx].v.tc[1] =
+            this->windowContentVtx[currentVtx + 1].v.tc[1] = this->windowContentVtx[currentVtx + 2].v.tc[0] = 0;
 
-        this->windowContentVtx[phi_t2 + 1].v.tc[0] = this->windowContentVtx[phi_t2 + 2].v.tc[1] =
-            this->windowContentVtx[phi_t2 + 3].v.tc[0] = this->windowContentVtx[phi_t2 + 3].v.tc[1] = 0x200;
+        this->windowContentVtx[currentVtx + 1].v.tc[0] = this->windowContentVtx[currentVtx + 2].v.tc[1] =
+            this->windowContentVtx[currentVtx + 3].v.tc[0] = this->windowContentVtx[currentVtx + 3].v.tc[1] = 0x200;
 
-        this->windowContentVtx[phi_t2].v.cn[0] = this->windowContentVtx[phi_t2 + 1].v.cn[0] =
-            this->windowContentVtx[phi_t2 + 2].v.cn[0] = this->windowContentVtx[phi_t2 + 3].v.cn[0] =
-                this->windowContentVtx[phi_t2].v.cn[1] = this->windowContentVtx[phi_t2 + 1].v.cn[1] =
-                    this->windowContentVtx[phi_t2 + 2].v.cn[1] = this->windowContentVtx[phi_t2 + 3].v.cn[1] =
-                        this->windowContentVtx[phi_t2].v.cn[2] = this->windowContentVtx[phi_t2 + 1].v.cn[2] =
-                            this->windowContentVtx[phi_t2 + 2].v.cn[2] = this->windowContentVtx[phi_t2 + 3].v.cn[2] =
-                                this->windowContentVtx[phi_t2].v.cn[3] = this->windowContentVtx[phi_t2 + 1].v.cn[3] =
-                                    this->windowContentVtx[phi_t2 + 2].v.cn[3] =
-                                        this->windowContentVtx[phi_t2 + 3].v.cn[3] = 0xFF;
+        this->windowContentVtx[currentVtx].v.cn[0] = this->windowContentVtx[currentVtx + 1].v.cn[0] =
+            this->windowContentVtx[currentVtx + 2].v.cn[0] = this->windowContentVtx[currentVtx + 3].v.cn[0] =
+                this->windowContentVtx[currentVtx].v.cn[1] = this->windowContentVtx[currentVtx + 1].v.cn[1] =
+                    this->windowContentVtx[currentVtx + 2].v.cn[1] = this->windowContentVtx[currentVtx + 3].v.cn[1] =
+                        this->windowContentVtx[currentVtx].v.cn[2] = this->windowContentVtx[currentVtx + 1].v.cn[2] =
+                            this->windowContentVtx[currentVtx + 2].v.cn[2] = this->windowContentVtx[currentVtx + 3].v.cn[2] =
+                                this->windowContentVtx[currentVtx].v.cn[3] = this->windowContentVtx[currentVtx + 1].v.cn[3] =
+                                    this->windowContentVtx[currentVtx + 2].v.cn[3] =
+                                        this->windowContentVtx[currentVtx + 3].v.cn[3] = 0xFF;
     }
 
+    // Title label
+    // X (left)
     this->windowContentVtx[0].v.ob[0] = this->windowContentVtx[2].v.ob[0] = this->windowPosX;
+    // X (right)
     this->windowContentVtx[1].v.ob[0] = this->windowContentVtx[3].v.ob[0] = this->windowContentVtx[0].v.ob[0] + 0x80;
+    // Y (top)
     this->windowContentVtx[0].v.ob[1] = this->windowContentVtx[1].v.ob[1] = 0x48;
+    // Y (bottom)
     this->windowContentVtx[2].v.ob[1] = this->windowContentVtx[3].v.ob[1] = this->windowContentVtx[0].v.ob[1] - 0x10;
+    // Texture coordinates
     this->windowContentVtx[1].v.tc[0] = this->windowContentVtx[3].v.tc[0] = 0x1000;
 
-    for (phi_a1 = 0, phi_t2 = 4; phi_a1 < 3; phi_a1++) {
-        phi_t0 = this->windowPosX - 6;
+    // File info boxes
+    for (i = 0, currentVtx = 4; i < 2; i++) {
+        currentPosX = this->windowPosX - 6;
 
-        for (phi_t5 = 0; phi_t5 < 5; phi_t5++, phi_t2 += 4) {
-            this->windowContentVtx[phi_t2].v.ob[0] = this->windowContentVtx[phi_t2 + 2].v.ob[0] = phi_t0;
-            this->windowContentVtx[phi_t2 + 1].v.ob[0] = this->windowContentVtx[phi_t2 + 3].v.ob[0] =
-                this->windowContentVtx[phi_t2].v.ob[0] + sFileInfoBoxPartWidths[phi_t5];
+        for (buttonIndex = 0; buttonIndex < 5; buttonIndex++, currentVtx += 4) {
+            this->windowContentVtx[currentVtx].v.ob[0] = this->windowContentVtx[currentVtx + 2].v.ob[0] = currentPosX;
+            this->windowContentVtx[currentVtx + 1].v.ob[0] = this->windowContentVtx[currentVtx + 3].v.ob[0] =
+                this->windowContentVtx[currentVtx].v.ob[0] + sFileInfoBoxPartWidths[buttonIndex];
 
-            this->windowContentVtx[phi_t2].v.ob[1] = this->windowContentVtx[phi_t2 + 1].v.ob[1] =
-                this->fileNamesY[phi_a1] + 0x2C;
+            this->windowContentVtx[currentVtx].v.ob[1] = this->windowContentVtx[currentVtx + 1].v.ob[1] =
+                this->fileNamesY[i] + 0x2C;
 
-            this->windowContentVtx[phi_t2 + 2].v.ob[1] = this->windowContentVtx[phi_t2 + 3].v.ob[1] =
-                this->windowContentVtx[phi_t2].v.ob[1] - 0x38;
+            this->windowContentVtx[currentVtx + 2].v.ob[1] = this->windowContentVtx[currentVtx + 3].v.ob[1] =
+                this->windowContentVtx[currentVtx].v.ob[1] - 0x38;
 
-            this->windowContentVtx[phi_t2 + 1].v.tc[0] = this->windowContentVtx[phi_t2 + 3].v.tc[0] =
-                sFileInfoBoxPartWidths[phi_t5] << 5;
-            this->windowContentVtx[phi_t2 + 2].v.tc[1] = this->windowContentVtx[phi_t2 + 3].v.tc[1] = 0x700;
-            phi_t0 += sFileInfoBoxPartWidths[phi_t5];
+            this->windowContentVtx[currentVtx + 1].v.tc[0] = this->windowContentVtx[currentVtx + 3].v.tc[0] =
+                sFileInfoBoxPartWidths[buttonIndex] << 5;
+            this->windowContentVtx[currentVtx + 2].v.tc[1] = this->windowContentVtx[currentVtx + 3].v.tc[1] = 0x700;
+            currentPosX += sFileInfoBoxPartWidths[buttonIndex];
         }
     }
 
-    phi_t0 = this->windowPosX - 6;
-    phi_ra = 0x2C;
+    currentPosX = this->windowPosX - 6;
+    currentPosY = 0x2C;
 
-    for (phi_t5 = 0; phi_t5 < 3; phi_t5++, phi_t2 += 20, phi_ra -= 0x10) {
-        this->windowContentVtx[phi_t2].v.ob[0] = this->windowContentVtx[phi_t2 + 2].v.ob[0] = phi_t0;
+    for (buttonIndex = 0; buttonIndex < 2; buttonIndex++, currentVtx += 20, currentPosY -= 0x10) {
+        this->windowContentVtx[currentVtx].v.ob[0] = this->windowContentVtx[currentVtx + 2].v.ob[0] = currentPosX;
 
-        this->windowContentVtx[phi_t2 + 1].v.ob[0] = this->windowContentVtx[phi_t2 + 3].v.ob[0] =
-            this->windowContentVtx[phi_t2].v.ob[0] + 0x40;
+        this->windowContentVtx[currentVtx + 1].v.ob[0] = this->windowContentVtx[currentVtx + 3].v.ob[0] =
+            this->windowContentVtx[currentVtx].v.ob[0] + 0x40;
 
-        this->windowContentVtx[phi_t2].v.ob[1] = this->windowContentVtx[phi_t2 + 1].v.ob[1] =
-            this->buttonYOffsets[phi_t5] + phi_ra;
-        this->windowContentVtx[phi_t2 + 2].v.ob[1] = this->windowContentVtx[phi_t2 + 3].v.ob[1] =
-            this->windowContentVtx[phi_t2].v.ob[1] - 0x10;
+        this->windowContentVtx[currentVtx].v.ob[1] = this->windowContentVtx[currentVtx + 1].v.ob[1] =
+            this->buttonYOffsets[buttonIndex] + currentPosY;
+        this->windowContentVtx[currentVtx + 2].v.ob[1] = this->windowContentVtx[currentVtx + 3].v.ob[1] =
+            this->windowContentVtx[currentVtx].v.ob[1] - 0x10;
 
-        this->windowContentVtx[phi_t2 + 1].v.tc[0] = this->windowContentVtx[phi_t2 + 3].v.tc[0] = 0x800;
+        this->windowContentVtx[currentVtx + 1].v.tc[0] = this->windowContentVtx[currentVtx + 3].v.tc[0] = 0x800;
 
-        this->windowContentVtx[phi_t2 + 4].v.ob[0] = this->windowContentVtx[phi_t2 + 6].v.ob[0] = phi_t0 + 0x40;
+        this->windowContentVtx[currentVtx + 4].v.ob[0] = this->windowContentVtx[currentVtx + 6].v.ob[0] = currentPosX + 0x40;
 
-        this->windowContentVtx[phi_t2 + 5].v.ob[0] = this->windowContentVtx[phi_t2 + 7].v.ob[0] =
-            this->windowContentVtx[phi_t2 + 4].v.ob[0] + 0x6C;
+        this->windowContentVtx[currentVtx + 5].v.ob[0] = this->windowContentVtx[currentVtx + 7].v.ob[0] =
+            this->windowContentVtx[currentVtx + 4].v.ob[0] + 0x6C;
 
-        this->windowContentVtx[phi_t2 + 4].v.ob[1] = this->windowContentVtx[phi_t2 + 5].v.ob[1] =
-            this->buttonYOffsets[phi_t5] + phi_ra;
+        this->windowContentVtx[currentVtx + 4].v.ob[1] = this->windowContentVtx[currentVtx + 5].v.ob[1] =
+            this->buttonYOffsets[buttonIndex] + currentPosY;
 
-        this->windowContentVtx[phi_t2 + 6].v.ob[1] = this->windowContentVtx[phi_t2 + 7].v.ob[1] =
-            this->windowContentVtx[phi_t2 + 4].v.ob[1] - 0x10;
+        this->windowContentVtx[currentVtx + 6].v.ob[1] = this->windowContentVtx[currentVtx + 7].v.ob[1] =
+            this->windowContentVtx[currentVtx + 4].v.ob[1] - 0x10;
 
-        this->windowContentVtx[phi_t2 + 5].v.tc[0] = this->windowContentVtx[phi_t2 + 7].v.tc[0] = 0xD80;
+        this->windowContentVtx[currentVtx + 5].v.tc[0] = this->windowContentVtx[currentVtx + 7].v.tc[0] = 0xD80;
 
-        if ((this->configMode == CM_COPY_ANIM_2) && (phi_t5 == this->copyDestFileIndex)) {
-            temp_t1 = this->fileNamesY[phi_t5] + 0x2C;
+        if ((this->configMode == CM_COPY_ANIM_2) && (buttonIndex == this->copyDestFileIndex)) {
+            yOffset = this->fileNamesY[buttonIndex] + 0x2C;
         } else if (((this->configMode == CM_COPY_ANIM_3) || (this->configMode == CM_COPY_ANIM_4)) &&
-                   (phi_t5 == this->copyDestFileIndex)) {
-            temp_t1 = this->buttonYOffsets[phi_t5] + phi_ra;
+                   (buttonIndex == this->copyDestFileIndex)) {
+            yOffset = this->buttonYOffsets[buttonIndex] + currentPosY;
         } else {
-            temp_t1 = phi_ra + this->buttonYOffsets[phi_t5] + this->fileNamesY[phi_t5];
+            yOffset = currentPosY + this->buttonYOffsets[buttonIndex] + this->fileNamesY[buttonIndex];
         }
 
-        this->windowContentVtx[phi_t2 + 8].v.ob[0] = this->windowContentVtx[phi_t2 + 10].v.ob[0] = phi_t0 + 0xA8;
+        // Button - Filename connectors
+        this->windowContentVtx[currentVtx + 8].v.ob[0] = this->windowContentVtx[currentVtx + 10].v.ob[0] = currentPosX + 0xA8;
 
-        this->windowContentVtx[phi_t2 + 9].v.ob[0] = this->windowContentVtx[phi_t2 + 11].v.ob[0] =
-            this->windowContentVtx[phi_t2 + 8].v.ob[0] + 0x2C;
+        this->windowContentVtx[currentVtx + 9].v.ob[0] = this->windowContentVtx[currentVtx + 11].v.ob[0] =
+            this->windowContentVtx[currentVtx + 8].v.ob[0] + 0x2C;
 
-        this->windowContentVtx[phi_t2 + 8].v.ob[1] = this->windowContentVtx[phi_t2 + 9].v.ob[1] = temp_t1;
-        this->windowContentVtx[phi_t2 + 10].v.ob[1] = this->windowContentVtx[phi_t2 + 11].v.ob[1] =
-            this->windowContentVtx[phi_t2 + 8].v.ob[1] - 0x10;
+        this->windowContentVtx[currentVtx + 8].v.ob[1] = this->windowContentVtx[currentVtx + 9].v.ob[1] = yOffset;
+        this->windowContentVtx[currentVtx + 10].v.ob[1] = this->windowContentVtx[currentVtx + 11].v.ob[1] =
+            this->windowContentVtx[currentVtx + 8].v.ob[1] - 0x10;
 
-        this->windowContentVtx[phi_t2 + 9].v.tc[0] = this->windowContentVtx[phi_t2 + 11].v.tc[0] = 0x580;
-        this->windowContentVtx[phi_t2 + 12].v.ob[0] = this->windowContentVtx[phi_t2 + 14].v.ob[0] = phi_t0 + 0x34;
-        this->windowContentVtx[phi_t2 + 13].v.ob[0] = this->windowContentVtx[phi_t2 + 15].v.ob[0] =
-            this->windowContentVtx[phi_t2 + 12].v.ob[0] + 0x18;
+        this->windowContentVtx[currentVtx + 9].v.tc[0] = this->windowContentVtx[currentVtx + 11].v.tc[0] = 0x580;
+        this->windowContentVtx[currentVtx + 12].v.ob[0] = this->windowContentVtx[currentVtx + 14].v.ob[0] = currentPosX + 0x34;
+        this->windowContentVtx[currentVtx + 13].v.ob[0] = this->windowContentVtx[currentVtx + 15].v.ob[0] =
+            this->windowContentVtx[currentVtx + 12].v.ob[0] + 0x18;
 
-        this->windowContentVtx[phi_t2 + 12].v.ob[1] = this->windowContentVtx[phi_t2 + 13].v.ob[1] =
-            this->buttonYOffsets[phi_t5] + phi_ra;
+        this->windowContentVtx[currentVtx + 12].v.ob[1] = this->windowContentVtx[currentVtx + 13].v.ob[1] =
+            this->buttonYOffsets[buttonIndex] + currentPosY;
 
-        this->windowContentVtx[phi_t2 + 14].v.ob[1] = this->windowContentVtx[phi_t2 + 15].v.ob[1] =
-            this->windowContentVtx[phi_t2 + 12].v.ob[1] - 0x10;
+        this->windowContentVtx[currentVtx + 14].v.ob[1] = this->windowContentVtx[currentVtx + 15].v.ob[1] =
+            this->windowContentVtx[currentVtx + 12].v.ob[1] - 0x10;
 
-        this->windowContentVtx[phi_t2 + 13].v.tc[0] = this->windowContentVtx[phi_t2 + 15].v.tc[0] = 0x300;
-        this->windowContentVtx[phi_t2 + 16].v.ob[0] = this->windowContentVtx[phi_t2 + 18].v.ob[0] = phi_t0 + 0x9C;
-        this->windowContentVtx[phi_t2 + 17].v.ob[0] = this->windowContentVtx[phi_t2 + 19].v.ob[0] =
-            this->windowContentVtx[phi_t2 + 16].v.ob[0] + 0x18;
+        this->windowContentVtx[currentVtx + 13].v.tc[0] = this->windowContentVtx[currentVtx + 15].v.tc[0] = 0x300;
+        this->windowContentVtx[currentVtx + 16].v.ob[0] = this->windowContentVtx[currentVtx + 18].v.ob[0] = currentPosX + 0x9C;
+        this->windowContentVtx[currentVtx + 17].v.ob[0] = this->windowContentVtx[currentVtx + 19].v.ob[0] =
+            this->windowContentVtx[currentVtx + 16].v.ob[0] + 0x18;
 
-        this->windowContentVtx[phi_t2 + 16].v.ob[1] = this->windowContentVtx[phi_t2 + 17].v.ob[1] =
-            this->buttonYOffsets[phi_t5] + phi_ra;
+        this->windowContentVtx[currentVtx + 16].v.ob[1] = this->windowContentVtx[currentVtx + 17].v.ob[1] =
+            this->buttonYOffsets[buttonIndex] + currentPosY;
 
-        this->windowContentVtx[phi_t2 + 18].v.ob[1] = this->windowContentVtx[phi_t2 + 19].v.ob[1] =
-            this->windowContentVtx[phi_t2 + 16].v.ob[1] - 0x10;
+        this->windowContentVtx[currentVtx + 18].v.ob[1] = this->windowContentVtx[currentVtx + 19].v.ob[1] =
+            this->windowContentVtx[currentVtx + 16].v.ob[1] - 0x10;
 
-        this->windowContentVtx[phi_t2 + 17].v.tc[0] = this->windowContentVtx[phi_t2 + 19].v.tc[0] = 0x300;
+        this->windowContentVtx[currentVtx + 17].v.tc[0] = this->windowContentVtx[currentVtx + 19].v.tc[0] = 0x300;
     }
 
-    phi_ra = 0x2C;
+    currentPosY = 0x2C;
 
-    for (phi_t5 = 0; phi_t5 < 3; phi_t5++, phi_ra -= WREG(38)) {
-        if (SLOT_OCCUPIED(sramCtx, phi_t5)) {
-            phi_t0 = this->windowPosX - WREG(39);
+    for (buttonIndex = 0; buttonIndex < 2; buttonIndex++, currentPosY -= WREG(38)) {
+        if (SLOT_OCCUPIED(sramCtx, buttonIndex)) {
+            currentPosX = this->windowPosX - WREG(39);
 
-            if ((this->configMode == 0xF) && (phi_t5 == this->copyDestFileIndex)) {
-                temp_t1 = this->fileNamesY[phi_t5] + 0x2C;
+            if ((this->configMode == CM_COPY_ANIM_2) && (buttonIndex == this->copyDestFileIndex)) {
+                // Adjust file info starting Y upwards when creating copied file
+                yOffset = this->fileNamesY[buttonIndex] + 0x2C;
             } else if (((this->configMode == CM_COPY_ANIM_3) || (this->configMode == CM_COPY_ANIM_4)) &&
-                       (phi_t5 == this->copyDestFileIndex)) {
-                temp_t1 = this->buttonYOffsets[phi_t5] + phi_ra;
+                       (buttonIndex == this->copyDestFileIndex)) {
+                // Adjust file info ending Y upwards when finishing copied file
+                yOffset = this->buttonYOffsets[buttonIndex] + currentPosY;
             } else {
-                temp_t1 = phi_ra + this->buttonYOffsets[phi_t5] + this->fileNamesY[phi_t5];
+                // Set normal file info Y position
+                yOffset = currentPosY + this->buttonYOffsets[buttonIndex] + this->fileNamesY[buttonIndex];
             }
 
-            temp_t1 += 2;
+            yOffset += 1;
 
-            for (phi_a1 = 0; phi_a1 < 8; phi_a1++, phi_t2 += 4, phi_t0 += WREG(40)) {
+            // Filename vertices
+            for (i = 0; i < 8; i++, currentVtx += 4, currentPosX += WREG(40)) {
 #if OOT_VERSION == PAL_1_1
-                fileNameChar = this->fileNames[phi_t5][phi_a1];
-                this->windowContentVtx[phi_t2].v.ob[0] = this->windowContentVtx[phi_t2 + 2].v.ob[0] =
-                    phi_t0 + 0x40 + WREG(41) + D_808124C0[fileNameChar];
+                fileNameChar = this->fileNames[buttonIndex][i];
+                this->windowContentVtx[currentVtx].v.ob[0] = this->windowContentVtx[currentVtx + 2].v.ob[0] =
+                    currentPosX + 0x40 + WREG(41) + fileNameCharWidth[fileNameChar];
 #else
                 this->windowContentVtx[phi_t2].v.ob[0] = this->windowContentVtx[phi_t2 + 2].v.ob[0] =
                     phi_t0 + 0x40 + WREG(41);
 #endif
-                this->windowContentVtx[phi_t2 + 1].v.ob[0] = this->windowContentVtx[phi_t2 + 3].v.ob[0] =
-                    this->windowContentVtx[phi_t2].v.ob[0] + WREG(42);
-                this->windowContentVtx[phi_t2].v.ob[1] = this->windowContentVtx[phi_t2 + 1].v.ob[1] = temp_t1 - 3;
-                this->windowContentVtx[phi_t2 + 2].v.ob[1] = this->windowContentVtx[phi_t2 + 3].v.ob[1] =
-                    this->windowContentVtx[phi_t2].v.ob[1] - WREG(43);
+                this->windowContentVtx[currentVtx + 1].v.ob[0] = this->windowContentVtx[currentVtx + 3].v.ob[0] =
+                    this->windowContentVtx[currentVtx].v.ob[0] + WREG(42);
+                this->windowContentVtx[currentVtx].v.ob[1] = this->windowContentVtx[currentVtx + 1].v.ob[1] = yOffset - 3;
+                this->windowContentVtx[currentVtx + 2].v.ob[1] = this->windowContentVtx[currentVtx + 3].v.ob[1] =
+                    this->windowContentVtx[currentVtx].v.ob[1] - WREG(43);
             }
 
-            phi_t0 = this->windowPosX - 14;
-            temp_t1 -= 0x16;
-
-            for (phi_a1 = 0; phi_a1 < 4; phi_a1++, phi_t2 += 4) {
-                this->windowContentVtx[phi_t2].v.ob[0] = this->windowContentVtx[phi_t2 + 2].v.ob[0] = phi_t0;
-                this->windowContentVtx[phi_t2 + 1].v.ob[0] = this->windowContentVtx[phi_t2 + 3].v.ob[0] =
-                    this->windowContentVtx[phi_t2].v.ob[0] + D_80812820[phi_a1];
-                this->windowContentVtx[phi_t2].v.ob[1] = this->windowContentVtx[phi_t2 + 1].v.ob[1] = temp_t1;
-                this->windowContentVtx[phi_t2 + 2].v.ob[1] = this->windowContentVtx[phi_t2 + 3].v.ob[1] =
-                    this->windowContentVtx[phi_t2].v.ob[1] - D_80812828[phi_a1];
-                phi_t0 += D_80812818[phi_a1];
+            currentPosX = this->windowPosX - 14;
+            yOffset -= 0x16;
+
+            // Death counter vertices
+            for (i = 0; i < 4; i++, currentVtx += 4) {
+                this->windowContentVtx[currentVtx].v.ob[0] = this->windowContentVtx[currentVtx + 2].v.ob[0] = currentPosX;
+                this->windowContentVtx[currentVtx + 1].v.ob[0] = this->windowContentVtx[currentVtx + 3].v.ob[0] =
+                    this->windowContentVtx[currentVtx].v.ob[0] + sDeathCounterTextureWidths[i];
+                this->windowContentVtx[currentVtx].v.ob[1] = this->windowContentVtx[currentVtx + 1].v.ob[1] = yOffset;
+                this->windowContentVtx[currentVtx + 2].v.ob[1] = this->windowContentVtx[currentVtx + 3].v.ob[1] =
+                    this->windowContentVtx[currentVtx].v.ob[1] - sDeathCounterTextureHeights[i];
+                currentPosX += sDeathCounterXOffsets[i];
             }
 
-            this->windowContentVtx[phi_t2 - 15].v.tc[0] = this->windowContentVtx[phi_t2 - 13].v.tc[0] = 0x400;
+            this->windowContentVtx[currentVtx - 15].v.tc[0] = this->windowContentVtx[currentVtx - 13].v.tc[0] = 0x400;
 
-            phi_t0 = this->windowPosX + 63;
-            temp_t1 += 4;
+            currentPosX = this->windowPosX + 63;
+            yOffset += 4;
 
-            for (phi_a1 = 0; phi_a1 < 20; phi_a1++, phi_t2 += 4, phi_t0 += 9) {
-                this->windowContentVtx[phi_t2].v.ob[0] = this->windowContentVtx[phi_t2 + 2].v.ob[0] = phi_t0;
-                this->windowContentVtx[phi_t2 + 1].v.ob[0] = this->windowContentVtx[phi_t2 + 3].v.ob[0] =
-                    this->windowContentVtx[phi_t2].v.ob[0] + 0xA;
-                this->windowContentVtx[phi_t2].v.ob[1] = this->windowContentVtx[phi_t2 + 1].v.ob[1] = temp_t1;
-                this->windowContentVtx[phi_t2 + 2].v.ob[1] = this->windowContentVtx[phi_t2 + 3].v.ob[1] =
-                    this->windowContentVtx[phi_t2].v.ob[1] - 0xA;
+            // Hearts vertices
+            for (i = 0; i < 20; i++, currentVtx += 4, currentPosX += 9) {
+                this->windowContentVtx[currentVtx].v.ob[0] = this->windowContentVtx[currentVtx + 2].v.ob[0] = currentPosX;
+                this->windowContentVtx[currentVtx + 1].v.ob[0] = this->windowContentVtx[currentVtx + 3].v.ob[0] =
+                    this->windowContentVtx[currentVtx].v.ob[0] + 0xA;
+                this->windowContentVtx[currentVtx].v.ob[1] = this->windowContentVtx[currentVtx + 1].v.ob[1] = yOffset;
+                this->windowContentVtx[currentVtx + 2].v.ob[1] = this->windowContentVtx[currentVtx + 3].v.ob[1] =
+                    this->windowContentVtx[currentVtx].v.ob[1] - 0xA;
 
-                if (phi_a1 == 9) {
-                    phi_t0 = this->windowPosX + 54;
-                    temp_t1 -= 8;
+                // Start second row
+                if (i == 9) {
+                    currentPosX = this->windowPosX + 54;
+                    yOffset -= 8;
                 }
             }
 
-            phi_t0 = this->windowPosX + 4;
-            temp_t1 -= 0xA;
-
-            for (phi_a1 = 0; phi_a1 < 10; phi_a1++, phi_t2 += 4, phi_t0 += 0x10) {
-                this->windowContentVtx[phi_t2].v.ob[0] = this->windowContentVtx[phi_t2 + 2].v.ob[0] = phi_t0;
-                this->windowContentVtx[phi_t2 + 1].v.ob[0] = this->windowContentVtx[phi_t2 + 3].v.ob[0] =
-                    this->windowContentVtx[phi_t2].v.ob[0] + 0x10;
-                this->windowContentVtx[phi_t2].v.ob[1] = this->windowContentVtx[phi_t2 + 1].v.ob[1] = temp_t1;
-                this->windowContentVtx[phi_t2 + 2].v.ob[1] = this->windowContentVtx[phi_t2 + 3].v.ob[1] =
-                    this->windowContentVtx[phi_t2].v.ob[1] - 0x10;
+            currentPosX = this->windowPosX + 4;
+            yOffset -= 0xA;
+
+            // Dungeon rewards vertices
+            for (i = 0; i < 10; i++, currentVtx += 4, currentPosX += 0x10) {
+                this->windowContentVtx[currentVtx].v.ob[0] = this->windowContentVtx[currentVtx + 2].v.ob[0] = currentPosX;
+                this->windowContentVtx[currentVtx + 1].v.ob[0] = this->windowContentVtx[currentVtx + 3].v.ob[0] =
+                    this->windowContentVtx[currentVtx].v.ob[0] + 0x10;
+                this->windowContentVtx[currentVtx].v.ob[1] = this->windowContentVtx[currentVtx + 1].v.ob[1] = yOffset;
+                this->windowContentVtx[currentVtx + 2].v.ob[1] = this->windowContentVtx[currentVtx + 3].v.ob[1] =
+                    this->windowContentVtx[currentVtx].v.ob[1] - 0x10;
             }
         } else {
-            phi_t2 += 0xA8;
+            currentVtx += 0xA8;
         }
     }
 
-    phi_t0 = this->windowPosX - 6;
-    phi_ra = -0xC;
-
-    for (phi_t5 = 0; phi_t5 < 2; phi_t5++, phi_t2 += 4, phi_ra -= 0x10) {
-        this->windowContentVtx[phi_t2].v.ob[0] = this->windowContentVtx[phi_t2 + 2].v.ob[0] = phi_t0;
-        this->windowContentVtx[phi_t2 + 1].v.ob[0] = this->windowContentVtx[phi_t2 + 3].v.ob[0] =
-            this->windowContentVtx[phi_t2].v.ob[0] + 0x40;
-        this->windowContentVtx[phi_t2].v.ob[1] = this->windowContentVtx[phi_t2 + 1].v.ob[1] =
-            this->buttonYOffsets[phi_t5 + 3] + phi_ra;
-        this->windowContentVtx[phi_t2 + 2].v.ob[1] = this->windowContentVtx[phi_t2 + 3].v.ob[1] =
-            this->windowContentVtx[phi_t2].v.ob[1] - 0x10;
-        this->windowContentVtx[phi_t2 + 1].v.tc[0] = this->windowContentVtx[phi_t2 + 3].v.tc[0] = 0x800;
+    currentPosX = this->windowPosX - 6;
+    currentPosY = -0xC;
+
+    // Middle Button(s)
+    for (buttonIndex = 0; buttonIndex < 2; buttonIndex++, currentVtx += 4, currentPosY -= 0x10) {
+        this->windowContentVtx[currentVtx].v.ob[0] = this->windowContentVtx[currentVtx + 2].v.ob[0] = currentPosX;
+        this->windowContentVtx[currentVtx + 1].v.ob[0] = this->windowContentVtx[currentVtx + 3].v.ob[0] =
+            this->windowContentVtx[currentVtx].v.ob[0] + 0x40;
+        this->windowContentVtx[currentVtx].v.ob[1] = this->windowContentVtx[currentVtx + 1].v.ob[1] =
+            this->buttonYOffsets[buttonIndex + 3] + currentPosY;
+        this->windowContentVtx[currentVtx + 2].v.ob[1] = this->windowContentVtx[currentVtx + 3].v.ob[1] =
+            this->windowContentVtx[currentVtx].v.ob[1] - 0x10;
+        this->windowContentVtx[currentVtx + 1].v.tc[0] = this->windowContentVtx[currentVtx + 3].v.tc[0] = 0x800;
     }
 
-    this->windowContentVtx[phi_t2].v.ob[0] = this->windowContentVtx[phi_t2 + 2].v.ob[0] = phi_t0;
-    this->windowContentVtx[phi_t2 + 1].v.ob[0] = this->windowContentVtx[phi_t2 + 3].v.ob[0] =
-        this->windowContentVtx[phi_t2].v.ob[0] + 0x40;
-    this->windowContentVtx[phi_t2].v.ob[1] = this->windowContentVtx[phi_t2 + 1].v.ob[1] =
-        this->buttonYOffsets[5] - 0x34;
-    this->windowContentVtx[phi_t2 + 2].v.ob[1] = this->windowContentVtx[phi_t2 + 3].v.ob[1] =
-        this->windowContentVtx[phi_t2].v.ob[1] - 0x10;
-    this->windowContentVtx[phi_t2 + 1].v.tc[0] = this->windowContentVtx[phi_t2 + 3].v.tc[0] = 0x800;
+    // Bottom Button
+    this->windowContentVtx[currentVtx].v.ob[0] = this->windowContentVtx[currentVtx + 2].v.ob[0] = currentPosX;
+    this->windowContentVtx[currentVtx + 1].v.ob[0] = this->windowContentVtx[currentVtx + 3].v.ob[0] =
+        this->windowContentVtx[currentVtx].v.ob[0] + 0x40;
+    this->windowContentVtx[currentVtx].v.ob[1] = this->windowContentVtx[currentVtx + 1].v.ob[1] =
+        this->buttonYOffsets[4] - 0x34;
+    this->windowContentVtx[currentVtx + 2].v.ob[1] = this->windowContentVtx[currentVtx + 3].v.ob[1] =
+        this->windowContentVtx[currentVtx].v.ob[1] - 0x10;
+    this->windowContentVtx[currentVtx + 1].v.tc[0] = this->windowContentVtx[currentVtx + 3].v.tc[0] = 0x800;
 
-    phi_t2 += 4;
+    currentVtx += 4;
 
+    // Submenu vertices
     if (((this->menuMode == FS_MENU_MODE_CONFIG) && (this->configMode >= CM_MAIN_MENU)) ||
         ((this->menuMode == FS_MENU_MODE_SELECT) && (this->selectMode == SM_CONFIRM_FILE))) {
         if (this->menuMode == FS_MENU_MODE_CONFIG) {
             if ((this->configMode == CM_SELECT_COPY_SOURCE) || (this->configMode == CM_SELECT_COPY_DEST) ||
                 (this->configMode == CM_ERASE_SELECT)) {
-                phi_t5 = D_8081283C[this->buttonIndex];
+                buttonIndex = sCopyEraseSelectButtonYOffsets[this->buttonIndex];
             } else if ((this->configMode == CM_ERASE_CONFIRM) || (this->configMode == CM_COPY_CONFIRM)) {
-                phi_t5 = D_80812844[this->buttonIndex];
+                buttonIndex = sCopyEraseConfirmButtonYOffsets[this->buttonIndex];
             } else {
-                phi_t5 = D_80812830[this->buttonIndex];
+                buttonIndex = sSelectMenuButtonYOffsets[this->buttonIndex];
             }
         } else {
-            phi_t5 = D_80812848[this->confirmButtonIndex];
+            buttonIndex = sFileSelectConfirmButtonYOffsets[this->confirmButtonIndex];
         }
 
-        this->windowContentVtx[phi_t2].v.ob[0] = this->windowContentVtx[phi_t2 + 2].v.ob[0] = this->windowPosX - 0xA;
-        this->windowContentVtx[phi_t2 + 1].v.ob[0] = this->windowContentVtx[phi_t2 + 3].v.ob[0] =
-            this->windowContentVtx[phi_t2].v.ob[0] + 0x48;
-        this->windowContentVtx[phi_t2].v.ob[1] = this->windowContentVtx[phi_t2 + 1].v.ob[1] =
-            this->windowContentVtx[phi_t5].v.ob[1] + 4;
-        this->windowContentVtx[phi_t2 + 2].v.ob[1] = this->windowContentVtx[phi_t2 + 3].v.ob[1] =
-            this->windowContentVtx[phi_t2].v.ob[1] - 0x18;
-        this->windowContentVtx[phi_t2 + 1].v.tc[0] = this->windowContentVtx[phi_t2 + 3].v.tc[0] = 0x900;
-        this->windowContentVtx[phi_t2 + 2].v.tc[1] = this->windowContentVtx[phi_t2 + 3].v.tc[1] = 0x300;
-    }
-
-    this->windowContentVtx[phi_t2 + 4].v.ob[0] = this->windowContentVtx[phi_t2 + 6].v.ob[0] = this->windowPosX + 0x3A;
-    this->windowContentVtx[phi_t2 + 5].v.ob[0] = this->windowContentVtx[phi_t2 + 7].v.ob[0] =
-        this->windowContentVtx[phi_t2 + 4].v.ob[0] + 0x80;
-    this->windowContentVtx[phi_t2 + 4].v.ob[1] = this->windowContentVtx[phi_t2 + 5].v.ob[1] =
-        this->windowContentVtx[D_80812830[this->warningButtonIndex]].v.ob[1];
-    this->windowContentVtx[phi_t2 + 6].v.ob[1] = this->windowContentVtx[phi_t2 + 7].v.ob[1] =
-        this->windowContentVtx[phi_t2 + 4].v.ob[1] - 0x10;
-    this->windowContentVtx[phi_t2 + 5].v.tc[0] = this->windowContentVtx[phi_t2 + 7].v.tc[0] = 0x1000;
+        this->windowContentVtx[currentVtx].v.ob[0] = this->windowContentVtx[currentVtx + 2].v.ob[0] = this->windowPosX - 0xA;
+        this->windowContentVtx[currentVtx + 1].v.ob[0] = this->windowContentVtx[currentVtx + 3].v.ob[0] =
+            this->windowContentVtx[currentVtx].v.ob[0] + 0x48;
+        this->windowContentVtx[currentVtx].v.ob[1] = this->windowContentVtx[currentVtx + 1].v.ob[1] =
+            this->windowContentVtx[buttonIndex].v.ob[1] + 4;
+        this->windowContentVtx[currentVtx + 2].v.ob[1] = this->windowContentVtx[currentVtx + 3].v.ob[1] =
+            this->windowContentVtx[currentVtx].v.ob[1] - 0x18;
+        this->windowContentVtx[currentVtx + 1].v.tc[0] = this->windowContentVtx[currentVtx + 3].v.tc[0] = 0x900;
+        this->windowContentVtx[currentVtx + 2].v.tc[1] = this->windowContentVtx[currentVtx + 3].v.tc[1] = 0x300;
+    }
+
+    // Warning messages
+    this->windowContentVtx[currentVtx + 4].v.ob[0] = this->windowContentVtx[currentVtx + 6].v.ob[0] = this->windowPosX + 0x3A;
+    this->windowContentVtx[currentVtx + 5].v.ob[0] = this->windowContentVtx[currentVtx + 7].v.ob[0] =
+        this->windowContentVtx[currentVtx + 4].v.ob[0] + 0x80;
+    this->windowContentVtx[currentVtx + 4].v.ob[1] = this->windowContentVtx[currentVtx + 5].v.ob[1] =
+        this->windowContentVtx[sSelectMenuButtonYOffsets[this->warningButtonIndex]].v.ob[1];
+    this->windowContentVtx[currentVtx + 6].v.ob[1] = this->windowContentVtx[currentVtx + 7].v.ob[1] =
+        this->windowContentVtx[currentVtx + 4].v.ob[1] - 0x10;
+    this->windowContentVtx[currentVtx + 5].v.tc[0] = this->windowContentVtx[currentVtx + 7].v.tc[0] = 0x1000;
 }
 
-static u16 D_8081284C[] = { 0x007C, 0x0124, 0x01CC };
+static u16 sFileNameVtx[] = { 0x0054, 0x00FC, 0x01A4 };
 
 static void* sQuestItemTextures[] = {
     gFileSelKokiriEmeraldTex,   gFileSelGoronRubyTex,       gFileSelZoraSapphireTex,
@@ -1211,7 +955,7 @@ void FileSelect_DrawFileInfo(GameState* thisx, s16 fileIndex, s16 isActive) {
 
     // draw file name
     if (this->nameAlpha[fileIndex] != 0) {
-        gSPVertex(POLY_OPA_DISP++, &this->windowContentVtx[D_8081284C[fileIndex]], 32, 0);
+        gSPVertex(POLY_OPA_DISP++, &this->windowContentVtx[sFileNameVtx[fileIndex]], 32, 0);
         gDPSetPrimColor(POLY_OPA_DISP++, 0x00, 0x00, sNamePrimColors[isActive][0], sNamePrimColors[isActive][1],
                         sNamePrimColors[isActive][2], this->nameAlpha[fileIndex]);
 
@@ -1226,7 +970,7 @@ void FileSelect_DrawFileInfo(GameState* thisx, s16 fileIndex, s16 isActive) {
         gDPSetCombineLERP(POLY_OPA_DISP++, 1, 0, PRIMITIVE, 0, TEXEL0, 0, PRIMITIVE, 0, 1, 0, PRIMITIVE, 0, TEXEL0, 0,
                           PRIMITIVE, 0);
         gDPSetPrimColor(POLY_OPA_DISP++, 0x00, 0x00, 255, 255, 255, this->fileInfoAlpha[fileIndex]);
-        gSPVertex(POLY_OPA_DISP++, &this->windowContentVtx[D_8081284C[fileIndex]] + 0x24, 12, 0);
+        gSPVertex(POLY_OPA_DISP++, &this->windowContentVtx[sFileNameVtx[fileIndex]] + 0x24, 12, 0);
 
         FileSelect_SplitNumber(this->deaths[fileIndex], &deathCountSplit[0], &deathCountSplit[1], &deathCountSplit[2]);
 
@@ -1276,7 +1020,7 @@ void FileSelect_DrawFileInfo(GameState* thisx, s16 fileIndex, s16 isActive) {
                 health -= 16;
             }
 
-            gSPVertex(POLY_OPA_DISP++, &this->windowContentVtx[D_8081284C[fileIndex] + vtxOffset] + 0x30, 4, 0);
+            gSPVertex(POLY_OPA_DISP++, &this->windowContentVtx[sFileNameVtx[fileIndex] + vtxOffset] + 0x30, 4, 0);
             POLY_OPA_DISP =
                 FileSelect_QuadTextureIA8(POLY_OPA_DISP, sHeartTextures[heartType][heartTextureIndex], 0x10, 0x10, 0);
         }
@@ -1287,7 +1031,7 @@ void FileSelect_DrawFileInfo(GameState* thisx, s16 fileIndex, s16 isActive) {
         // draw quest items
         for (vtxOffset = 0, j = 0; j < 9; j++, vtxOffset += 4) {
             if (this->questItems[fileIndex] & gBitFlags[sQuestItemFlags[j]]) {
-                gSPVertex(POLY_OPA_DISP++, &this->windowContentVtx[D_8081284C[fileIndex] + vtxOffset] + 0x80, 4, 0);
+                gSPVertex(POLY_OPA_DISP++, &this->windowContentVtx[sFileNameVtx[fileIndex] + vtxOffset] + 0x80, 4, 0);
                 gDPPipeSync(POLY_OPA_DISP++);
                 gDPSetPrimColor(POLY_OPA_DISP++, 0x00, 0x00, sQuestItemRed[j], sQuestItemGreen[j], sQuestItemBlue[j],
                                 this->fileInfoAlpha[fileIndex]);
@@ -1351,14 +1095,14 @@ static void* sWarningLabels[][5] = {
 #endif
 };
 
-static void* sFileButtonTextures[][3] = {
+static void* sFileButtonTextures[][2] = {
 #if OOT_NTSC
     { gFileSelFile1ButtonJPNTex, gFileSelFile2ButtonJPNTex, gFileSelFile3ButtonJPNTex },
     { gFileSelFile1ButtonENGTex, gFileSelFile2ButtonENGTex, gFileSelFile3ButtonENGTex },
 #else
-    { gFileSelFile1ButtonENGTex, gFileSelFile2ButtonENGTex, gFileSelFile3ButtonENGTex },
-    { gFileSelFile1ButtonGERTex, gFileSelFile2ButtonGERTex, gFileSelFile3ButtonGERTex },
-    { gFileSelFile1ButtonFRATex, gFileSelFile2ButtonFRATex, gFileSelFile3ButtonFRATex },
+    { gFileSelFile1ButtonENGTex, gFileSelFile2ButtonENGTex },
+    { gFileSelFile1ButtonGERTex, gFileSelFile2ButtonGERTex },
+    { gFileSelFile1ButtonFRATex, gFileSelFile2ButtonFRATex },
 #endif
 };
 
@@ -1416,7 +1160,7 @@ void FileSelect_DrawWindowContents(GameState* thisx) {
     gDPPipeSync(POLY_OPA_DISP++);
 
     // draw file info box (large box when a file is selected)
-    for (fileIndex = 0; fileIndex < 3; fileIndex++, temp += 20) {
+    for (fileIndex = 0; fileIndex < 2; fileIndex++, temp += 20) {
         gDPPipeSync(POLY_OPA_DISP++);
         gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, this->windowColor[0], this->windowColor[1], this->windowColor[2],
                         this->fileInfoAlpha[fileIndex]);
@@ -1430,7 +1174,7 @@ void FileSelect_DrawWindowContents(GameState* thisx) {
         }
     }
 
-    for (i = 0; i < 3; i++, temp += 20) {
+    for (i = 0; i < 2; i++, temp += 20) {
         // draw file button
         gSPVertex(POLY_OPA_DISP++, &this->windowContentVtx[temp], 20, 0);
 
@@ -1475,7 +1219,7 @@ void FileSelect_DrawWindowContents(GameState* thisx) {
     }
 
     // draw file info
-    for (fileIndex = 0; fileIndex < 3; fileIndex++) {
+    for (fileIndex = 0; fileIndex < 2; fileIndex++) {
         isActive = ((this->n64ddFlag == this->n64ddFlags[fileIndex]) || (this->nameBoxAlpha[fileIndex] == 0)) ? 0 : 1;
         FileSelect_DrawFileInfo(&this->state, fileIndex, isActive);
     }
@@ -1484,7 +1228,7 @@ void FileSelect_DrawWindowContents(GameState* thisx) {
     gDPSetCombineLERP(POLY_OPA_DISP++, PRIMITIVE, ENVIRONMENT, TEXEL0, ENVIRONMENT, TEXEL0, 0, PRIMITIVE, 0, PRIMITIVE,
                       ENVIRONMENT, TEXEL0, ENVIRONMENT, TEXEL0, 0, PRIMITIVE, 0);
     gDPSetEnvColor(POLY_OPA_DISP++, 0, 0, 0, 0);
-    gSPVertex(POLY_OPA_DISP++, &this->windowContentVtx[0x274], 20, 0);
+    gSPVertex(POLY_OPA_DISP++, &this->windowContentVtx[0x1A4], 20, 0);
 
     // draw primary action buttons (copy/erase)
     for (quadVtxIndex = 0, i = 0; i < 2; i++, quadVtxIndex += 4) {
@@ -1500,7 +1244,7 @@ void FileSelect_DrawWindowContents(GameState* thisx) {
     gDPPipeSync(POLY_OPA_DISP++);
 
     // draw confirm buttons (yes/quit)
-    for (quadVtxIndex = 0, i = 0; i < 2; i++, quadVtxIndex += 4) {
+    for (quadVtxIndex = 0, i = 0; i < 2; i++, quadVtxIndex += 8) {
         temp = this->confirmButtonTexIndices[i];
 
         gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, this->windowColor[0], this->windowColor[1], this->windowColor[2],
@@ -1680,7 +1424,7 @@ void FileSelect_FadeMainToSelect(GameState* thisx) {
     SramContext* sramCtx = &this->sramCtx;
     s16 i;
 
-    for (i = 0; i < 3; i++) {
+    for (i = 0; i < 2; i++) {
         if (i != this->buttonIndex) {
             this->fileButtonAlpha[i] -= 25;
             this->actionButtonAlpha[FS_BTN_ACTION_COPY] = this->actionButtonAlpha[FS_BTN_ACTION_ERASE] =
@@ -1709,7 +1453,7 @@ void FileSelect_FadeMainToSelect(GameState* thisx) {
  * Update function for `SM_MOVE_FILE_TO_TOP`
  */
 void FileSelect_MoveSelectedFileToTop(GameState* thisx) {
-    static s16 fileYOffsets[] = { 0, 16, 32 }; // amount to move by to reach the top of the screen
+    static s16 fileYOffsets[] = { 0, 16 }; // amount to move by to reach the top of the screen
     FileSelectState* this = (FileSelectState*)thisx;
     s16 yStep;
 
@@ -1761,10 +1505,7 @@ void FileSelect_ConfirmFile(GameState* thisx) {
     if (CHECK_BTN_ALL(input->press.button, BTN_START) || (CHECK_BTN_ALL(input->press.button, BTN_A))) {
         if (this->confirmButtonIndex == FS_BTN_CONFIRM_YES) {
             Rumble_Request(300.0f, 180, 20, 100);
-            Audio_PlaySfxGeneral(NA_SE_SY_FSEL_DECIDE_L, &gSfxDefaultPos, 4, &gSfxDefaultFreqAndVolScale,
-                                 &gSfxDefaultFreqAndVolScale, &gSfxDefaultReverb);
-            this->selectMode = SM_FADE_OUT;
-            func_800F6964(0xF);
+            this->selectMode = SM_LOAD_SAVE;
         } else {
             Audio_PlaySfxGeneral(NA_SE_SY_FSEL_CLOSE, &gSfxDefaultPos, 4, &gSfxDefaultFreqAndVolScale,
                                  &gSfxDefaultFreqAndVolScale, &gSfxDefaultReverb);
@@ -1822,7 +1563,7 @@ void FileSelect_MoveSelectedFileToSlot(GameState* thisx) {
         this->buttonYOffsets[this->buttonIndex] = 0;
     }
 
-    for (i = 0; i < 3; i++) {
+    for (i = 0; i < 2; i++) {
         if (i != this->buttonIndex) {
             this->fileButtonAlpha[i] += 25;
 
@@ -1879,26 +1620,10 @@ void FileSelect_FadeOut(GameState* thisx) {
 void FileSelect_LoadGame(GameState* thisx) {
     FileSelectState* this = (FileSelectState*)thisx;
 
-#if DEBUG_FEATURES
-    if (this->buttonIndex == FS_BTN_SELECT_FILE_1) {
-        Audio_PlaySfxGeneral(NA_SE_SY_FSEL_DECIDE_L, &gSfxDefaultPos, 4, &gSfxDefaultFreqAndVolScale,
-                             &gSfxDefaultFreqAndVolScale, &gSfxDefaultReverb);
-        gSaveContext.fileNum = this->buttonIndex;
-        Sram_OpenSave(&this->sramCtx);
-        gSaveContext.gameMode = GAMEMODE_NORMAL;
-        SET_NEXT_GAMESTATE(&this->state, MapSelect_Init, MapSelectState);
-        this->state.running = false;
-    } else
-#endif
-    {
-        Audio_PlaySfxGeneral(NA_SE_SY_FSEL_DECIDE_L, &gSfxDefaultPos, 4, &gSfxDefaultFreqAndVolScale,
-                             &gSfxDefaultFreqAndVolScale, &gSfxDefaultReverb);
-        gSaveContext.fileNum = this->buttonIndex;
-        Sram_OpenSave(&this->sramCtx);
-        gSaveContext.gameMode = GAMEMODE_NORMAL;
-        SET_NEXT_GAMESTATE(&this->state, Play_Init, PlayState);
-        this->state.running = false;
-    }
+    gSaveContext.fileNum = this->buttonIndex;
+    gSaveContext.gameMode = GAMEMODE_NORMAL;
+    SET_NEXT_GAMESTATE(&this->state, Randomizer_Init, RandomizerState);
+    this->state.running = false;
 
     gSaveContext.respawn[RESPAWN_MODE_DOWN].entranceIndex = ENTR_LOAD_OPENING;
     gSaveContext.respawnFlag = 0;
@@ -1978,7 +1703,8 @@ void FileSelect_LoadGame(GameState* thisx) {
 
 static void (*sSelectModeUpdateFuncs[])(GameState*) = {
     FileSelect_FadeMainToSelect, FileSelect_MoveSelectedFileToTop,  FileSelect_FadeInFileInfo, FileSelect_ConfirmFile,
-    FileSelect_FadeOutFileInfo,  FileSelect_MoveSelectedFileToSlot, FileSelect_FadeOut,        FileSelect_LoadGame,
+    FileSelect_FadeOutFileInfo,  FileSelect_MoveSelectedFileToSlot, FileSelect_LoadSave,       FileSelect_RotateToRandomizerSettings,
+    FileSelect_FadeOut,          FileSelect_LoadGame,
 };
 
 void FileSelect_SelectModeUpdate(GameState* thisx) {
@@ -2142,6 +1868,10 @@ void FileSelect_Main(GameState* thisx) {
     sFileSelectUpdateFuncs[this->menuMode](&this->state);
     sFileSelectDrawFuncs[this->menuMode](&this->state);
 
+    if ((this->configMode >= CM_MAIN_TO_RANDOMIZER)) {
+        FileSelect_DrawRandomizerMenu(&this->state);
+    }
+
     // do not draw controls text in the options menu
     if ((this->configMode <= CM_NAME_ENTRY_TO_MAIN) || (this->configMode >= CM_UNUSED_DELAY)) {
         Gfx_SetupDL_39Opa(this->state.gfxCtx);
@@ -2287,8 +2017,8 @@ void FileSelect_InitContext(GameState* thisx) {
     this->warningLabel = FS_WARNING_NONE;
 
     this->warningButtonIndex = this->buttonYOffsets[0] = this->buttonYOffsets[1] = this->buttonYOffsets[2] =
-        this->buttonYOffsets[3] = this->buttonYOffsets[4] = this->buttonYOffsets[5] = this->fileNamesY[0] =
-            this->fileNamesY[1] = this->fileNamesY[2] = 0;
+        this->buttonYOffsets[3] = this->buttonYOffsets[4] = this->fileNamesY[0] =
+            this->fileNamesY[1] = 0;
 
     this->unk_1CAD6[0] = 0;
     this->unk_1CAD6[1] = 3;
@@ -2326,8 +2056,7 @@ void FileSelect_InitContext(GameState* thisx) {
     gSaveContext.buttonStatus[0] = gSaveContext.buttonStatus[1] = gSaveContext.buttonStatus[2] =
         gSaveContext.buttonStatus[3] = gSaveContext.buttonStatus[4] = BTN_ENABLED;
 
-    this->n64ddFlags[0] = this->n64ddFlags[1] = this->n64ddFlags[2] = this->defense[0] = this->defense[1] =
-        this->defense[2] = 0;
+    this->n64ddFlags[0] = this->n64ddFlags[1] = this->n64ddFlags[2] = this->defense[0] = this->defense[1] = 0;
 
 #if PLATFORM_GC && OOT_PAL
     SsSram_ReadWrite(OS_K1_TO_PHYSICAL(0xA8000000), sramCtx->readBuff, SRAM_SIZE, OS_READ);
diff --git a/src/overlays/gamestates/ovl_file_choose/z_file_copy_erase.c b/src/overlays/gamestates/ovl_file_choose/z_file_copy_erase.c
index 03fb5d0f1..78b98e7e6 100644
--- a/src/overlays/gamestates/ovl_file_choose/z_file_copy_erase.c
+++ b/src/overlays/gamestates/ovl_file_choose/z_file_copy_erase.c
@@ -13,12 +13,11 @@
 // compiler errors (see docs/compilers.md)
 
 // when choosing a file to copy or erase, the 6 main menu buttons are placed at these offsets
-static s16 sChooseFileYOffsets[] = { -48, -48, -48, -24, -24, 0 };
+static s16 sChooseFileYOffsets[] = { -48, -48, -24, -24, 0 };
 
 static s16 D_8081248C[3][3] = {
-    { 0, -48, -48 },
-    { -64, 16, -48 },
-    { -64, -64, 32 },
+    { 0, -48, },
+    { -64, 16 },
 };
 
 static s16 sEraseDelayTimer = 15;
@@ -36,7 +35,7 @@ void FileSelect_SetupCopySource(GameState* thisx) {
 #endif
 
 #if !PLATFORM_IQUE
-    for (i = 0; i < 5; i++) {
+    for (i = 0; i < 4; i++) {
         yStep = (ABS(this->buttonYOffsets[i] - sChooseFileYOffsets[i])) / this->actionTimer;
 
         if (this->buttonYOffsets[i] >= sChooseFileYOffsets[i]) {
@@ -157,7 +156,7 @@ void FileSelect_SetupCopyDest1(GameState* thisx) {
 #endif
 
 #if !PLATFORM_IQUE
-    for (i = 0; i < 3; i++) {
+    for (i = 0; i < 2; i++) {
         yStep = ABS(this->buttonYOffsets[i] - D_8081248C[this->buttonIndex][i]) / this->actionTimer;
 
         if (this->buttonYOffsets[i] <= D_8081248C[this->buttonIndex][i]) {
@@ -383,7 +382,7 @@ void FileSelect_ExitToCopySource2(GameState* thisx) {
 #endif
 
 #if !PLATFORM_IQUE
-    for (i = 0; i < 3; i++) {
+    for (i = 0; i < 2; i++) {
         yStep = ABS(this->buttonYOffsets[i] - sChooseFileYOffsets[i]) / this->actionTimer;
 
         if (this->buttonYOffsets[i] >= sChooseFileYOffsets[i]) {
@@ -438,7 +437,7 @@ void FileSelect_ExitToCopySource2(GameState* thisx) {
  * Update function for `CM_SETUP_COPY_CONFIRM_1`
  */
 void FileSelect_SetupCopyConfirm1(GameState* thisx) {
-    static s16 D_808124A4[] = { -56, -40, -24, 0 };
+    static s16 D_808124A4[] = { -56, -40, 0 };
     FileSelectState* this = (FileSelectState*)thisx;
     SramContext* sramCtx = &this->sramCtx;
     s16 i;
@@ -457,7 +456,7 @@ void FileSelect_SetupCopyConfirm1(GameState* thisx) {
 #endif
 
 #if !PLATFORM_IQUE
-    for (i = 0; i < 3; i++) {
+    for (i = 0; i < 2; i++) {
         if ((i != this->copyDestFileIndex) && (i != this->selectedFileIndex)) {
             this->fileButtonAlpha[i] -= 25;
 
@@ -599,7 +598,7 @@ void FileSelect_ReturnToCopyDest(GameState* thisx) {
 #endif
 
 #if !PLATFORM_IQUE
-    for (i = 0; i < 3; i++) {
+    for (i = 0; i < 2; i++) {
         if ((i != this->copyDestFileIndex) && (i != this->selectedFileIndex)) {
             this->fileButtonAlpha[i] += 25;
 
@@ -854,7 +853,7 @@ void FileSelect_CopyAnim5(GameState* thisx) {
 #endif
 
 #if !PLATFORM_IQUE
-    for (i = 0; i < 3; i++) {
+    for (i = 0; i < 2; i++) {
         if (i != this->buttonIndex) {
             this->fileButtonAlpha[i] += 25;
 
@@ -902,7 +901,7 @@ void FileSelect_CopyAnim5(GameState* thisx) {
 
     if (this->actionTimer == 0) {
 #if !PLATFORM_IQUE
-        for (i = 0; i < 3; i++) {
+        for (i = 0; i < 2; i++) {
             this->fileButtonAlpha[i] = 200;
             this->nameBoxAlpha[i] = this->nameAlpha[i] = this->connectorAlpha[i] = 0;
 
@@ -1215,7 +1214,7 @@ void FileSelect_SetupEraseConfirm1(GameState* thisx) {
 #endif
 
 #if !PLATFORM_IQUE
-    for (i = 0; i < 3; i++) {
+    for (i = 0; i < 2; i++) {
         if (i != this->buttonIndex) {
             this->fileButtonAlpha[i] -= 25;
 
@@ -1282,7 +1281,7 @@ void FileSelect_SetupEraseConfirm1(GameState* thisx) {
 
     if (this->actionTimer == 0) {
 #if !PLATFORM_IQUE
-        for (i = 0; i < 3; i++) {
+        for (i = 0; i < 2; i++) {
             if (i != this->buttonIndex) {
                 this->fileButtonAlpha[i] = 0;
 
@@ -1481,7 +1480,7 @@ void FileSelect_ExitToEraseSelect2(GameState* thisx) {
 #endif
 
 #if !PLATFORM_IQUE
-    for (i = 0; i < 3; i++) {
+    for (i = 0; i < 2; i++) {
         if (i != this->buttonIndex) {
             this->fileButtonAlpha[i] += 25;
 
@@ -1683,7 +1682,7 @@ void FileSelect_EraseAnim3(GameState* thisx) {
 #endif
 
 #if !PLATFORM_IQUE
-    for (i = 0; i < 3; i++) {
+    for (i = 0; i < 2; i++) {
         this->fileButtonAlpha[i] += 25;
 
         if (SLOT_OCCUPIED(sramCtx, i)) {
diff --git a/src/overlays/gamestates/ovl_file_choose/z_file_nameset.c b/src/overlays/gamestates/ovl_file_choose/z_file_nameset.c
index bc7ae7edc..4f611c524 100644
--- a/src/overlays/gamestates/ovl_file_choose/z_file_nameset.c
+++ b/src/overlays/gamestates/ovl_file_choose/z_file_nameset.c
@@ -46,7 +46,7 @@ void FileSelect_DrawCharacterTransition(GraphicsContext* gfxCtx, void* texture1,
 #if OOT_PAL
 
 #if OOT_VERSION >= PAL_1_1
-s16 D_808124C0[] = {
+s16 fileNameCharWidth[] = {
     2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 0, 1, 1, 2, 1, 1, 4, 2, 2, 2, 1, 1, 0, 2, 0, 1, 1, 1, 1, 1, 0,
     1, 1, 1, 2, 2, 2, 2, 2, 3, 2, 2, 4, 3, 2, 4, 1, 2, 2, 1, 1, 2, 2, 3, 2, 2, 0, 2, 2, 2, 0, 3, 1, 0,
 };
@@ -268,7 +268,7 @@ void FileSelect_SetNameEntryVtx(GameState* thisx) {
             temp = this->fileNames[this->buttonIndex][phi_s0 - 1];
 
             this->nameEntryVtx[phi_t1].v.ob[0] = this->nameEntryVtx[phi_t1 + 2].v.ob[0] =
-                D_808125EC[phi_s0] + this->nameEntryBoxPosX + D_808124C0[temp];
+                D_808125EC[phi_s0] + this->nameEntryBoxPosX + fileNameCharWidth[temp];
 #else
             this->nameEntryVtx[phi_t1].v.ob[0] = this->nameEntryVtx[phi_t1 + 2].v.ob[0] =
                 D_808125EC[phi_s0] + this->nameEntryBoxPosX;
@@ -1355,11 +1355,12 @@ void FileSelect_UpdateOptionsMenu(GameState* thisx) {
         Audio_PlaySfxGeneral(NA_SE_SY_FSEL_DECIDE_L, &gSfxDefaultPos, 4, &gSfxDefaultFreqAndVolScale,
                              &gSfxDefaultFreqAndVolScale, &gSfxDefaultReverb);
         this->configMode = CM_OPTIONS_TO_MAIN;
-        sramCtx->readBuff[0] = gSaveContext.soundSetting;
-        sramCtx->readBuff[1] = gSaveContext.zTargetSetting;
+        sramCtx->readBuff[SRAM_HEADER_SOUND] = gSaveContext.soundSetting;
+        sramCtx->readBuff[SRAM_HEADER_Z_TARGET] = gSaveContext.zTargetSetting;
 #if OOT_PAL_N64
-        sramCtx->readBuff[2] = gSaveContext.language;
+        sramCtx->readBuff[SRAM_HEADER_LANGUAGE] = gSaveContext.language;
 #endif
+        sramCtx->readBuff[SRAM_HEADER_QUICKTEXT] = gSaveContext.quicktextSetting;
         PRINTF("");
         Sram_WriteSramHeader(sramCtx);
         PRINTF_COLOR_YELLOW();
@@ -1385,19 +1386,10 @@ void FileSelect_UpdateOptionsMenu(GameState* thisx) {
             if (gSaveContext.soundSetting > 0xF0) {
                 gSaveContext.soundSetting = SOUND_SETTING_SURROUND;
             }
-        } else {
-#if !OOT_PAL_N64
+        } else if (sSelectedSetting == FS_SETTING_TARGET) {
             gSaveContext.zTargetSetting ^= 1;
-#else
-            if (sSelectedSetting == FS_SETTING_TARGET) {
-                gSaveContext.zTargetSetting ^= 1;
-            } else {
-                gSaveContext.language--;
-                if (gSaveContext.language >= LANGUAGE_MAX) {
-                    gSaveContext.language = LANGUAGE_MAX - 1;
-                }
-            }
-#endif
+        } else {
+            gSaveContext.quicktextSetting ^= 1;
         }
     } else if (this->stickAdjX > 30) {
         Audio_PlaySfxGeneral(NA_SE_SY_FSEL_CURSOR, &gSfxDefaultPos, 4, &gSfxDefaultFreqAndVolScale,
@@ -1409,19 +1401,10 @@ void FileSelect_UpdateOptionsMenu(GameState* thisx) {
             if (gSaveContext.soundSetting > SOUND_SETTING_SURROUND) {
                 gSaveContext.soundSetting = SOUND_SETTING_STEREO;
             }
-        } else {
-#if !OOT_PAL_N64
+        } else if (sSelectedSetting == FS_SETTING_TARGET) {
             gSaveContext.zTargetSetting ^= 1;
-#else
-            if (sSelectedSetting == FS_SETTING_TARGET) {
-                gSaveContext.zTargetSetting ^= 1;
-            } else {
-                gSaveContext.language++;
-                if (gSaveContext.language >= LANGUAGE_MAX) {
-                    gSaveContext.language = 0;
-                }
-            }
-#endif
+        } else {
+            gSaveContext.quicktextSetting ^= 1;
         }
     }
 
@@ -1521,9 +1504,9 @@ static OptionsMenuTextureInfo sOptionsMenuHeaders[] = {
     { { gFileSelSOUNDENGTex, gFileSelSOUNDENGTex, gFileSelSOUNDFRATex }, 64, 16 },
     { { gFileSelZTargetingENGTex, gFileSelZTargetingGERTex, gFileSelZTargetingFRATex }, 64, 16 },
     { { gFileSelCheckBrightnessENGTex, gFileSelCheckBrightnessGERTex, gFileSelCheckBrightnessFRATex }, 128, 16 },
+    { { gOptionQuicktextENGTex, gOptionQuicktextENGTex, gOptionQuicktextENGTex }, 64, 16 },
     { { gFileSelLanguageENGTex, gFileSelLanguageGERTex, gFileSelLanguageFRATex }, 64, 16 },
 };
-
 static OptionsMenuTextureInfo sOptionsMenuSettings[] = {
     { { gFileSelStereoENGTex, gFileSelStereoENGTex, gFileSelStereoFRATex }, 48, 16 },
     { { gFileSelMonoENGTex, gFileSelMonoENGTex, gFileSelMonoENGTex }, 48, 16 },
@@ -1531,8 +1514,8 @@ static OptionsMenuTextureInfo sOptionsMenuSettings[] = {
     { { gFileSelSurroundENGTex, gFileSelSurroundENGTex, gFileSelSurroundENGTex }, 48, 16 },
     { { gFileSelSwitchENGTex, gFileSelSwitchGERTex, gFileSelSwitchFRATex }, 48, 16 },
     { { gFileSelHoldENGTex, gFileSelHoldGERTex, gFileSelHoldFRATex }, 48, 16 },
-    { { gFileSelSwitchENGTex, gFileSelSwitchGERTex, gFileSelSwitchFRATex }, 48, 16 },
-    { { gFileSelHoldENGTex, gFileSelHoldGERTex, gFileSelHoldFRATex }, 48, 16 },
+    { { gOptionOffENGTex, gOptionOffENGTex, gOptionOffENGTex}, 32, 16 },
+    { { gOptionOnENGTex, gOptionOnENGTex, gOptionOnENGTex}, 24, 16 },
 };
 
 #else
@@ -1827,6 +1810,30 @@ void FileSelect_DrawOptionsImpl(GameState* thisx) {
         gSP1Quadrangle(POLY_OPA_DISP++, vtx, vtx + 2, vtx + 3, vtx + 1, 0);
     }
 
+    for (i = 6; i < 8; i++, vtx += 4) {
+        int j = i - 6;
+        gDPPipeSync(POLY_OPA_DISP++);
+        if (j == gSaveContext.quicktextSetting) {
+            if (sSelectedSetting == FS_SETTING_QUICKTEXT) {
+                gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, cursorPrimRed, cursorPrimGreen, cursorPrimBlue,
+                                this->titleAlpha[0]);
+                gDPSetEnvColor(POLY_OPA_DISP++, cursorEnvRed, cursorEnvGreen, cursorEnvBlue, 255);
+            } else {
+                gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 255, 255, this->titleAlpha[0]);
+                gDPSetEnvColor(POLY_OPA_DISP++, 0, 0, 0, 255);
+            }
+        } else {
+            gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 120, 120, 120, this->titleAlpha[0]);
+            gDPSetEnvColor(POLY_OPA_DISP++, 0, 0, 0, 255);
+        }
+
+        gDPLoadTextureBlock(POLY_OPA_DISP++, sOptionsMenuSettings[i].texture[gSaveContext.language], G_IM_FMT_IA,
+                            G_IM_SIZ_8b, OPTIONS_MENU_TEXTURE_WIDTH(sOptionsMenuSettings[i]),
+                            OPTIONS_MENU_TEXTURE_HEIGHT(sOptionsMenuSettings[i]), 0, G_TX_NOMIRROR | G_TX_WRAP,
+                            G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMASK, G_TX_NOMASK, G_TX_NOLOD, G_TX_NOLOD);
+        gSP1Quadrangle(POLY_OPA_DISP++, vtx, vtx + 2, vtx + 3, vtx + 1, 0);
+    }
+
     gSPVertex(POLY_OPA_DISP++, gOptionsMenuBrightnessVtx, 8, 0);
     vtx = 0;
 #endif
@@ -1850,33 +1857,6 @@ void FileSelect_DrawOptionsImpl(GameState* thisx) {
 
     vtx += 4;
 
-#if OOT_PAL_N64
-    gSPVertex(POLY_OPA_DISP++, gOptionsMenuLanguageVtx, 12, 0);
-
-    for (i = 0, vtx = 0; i != LANGUAGE_MAX; i++, vtx += 4) {
-        gDPPipeSync(POLY_OPA_DISP++);
-
-        if (i == gSaveContext.language) {
-            if (sSelectedSetting == FS_SETTING_LANGUAGE) {
-                gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, cursorPrimRed, cursorPrimGreen, cursorPrimBlue,
-                                this->titleAlpha[0]);
-                gDPSetEnvColor(POLY_OPA_DISP++, cursorEnvRed, cursorEnvGreen, cursorEnvBlue, 0xFF);
-            } else {
-                gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 255, 255, this->titleAlpha[0]);
-                gDPSetEnvColor(POLY_OPA_DISP++, 0, 0, 0, 255);
-            }
-        } else {
-            gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 120, 120, 120, this->titleAlpha[0]);
-            gDPSetEnvColor(POLY_OPA_DISP++, 0, 0, 0, 255);
-        }
-
-        gDPLoadTextureBlock(POLY_OPA_DISP++, sLanguageChoices[i].texture, G_IM_FMT_IA, G_IM_SIZ_8b,
-                            sLanguageChoices[i].width, sLanguageChoices[i].height, 0, G_TX_NOMIRROR | G_TX_WRAP,
-                            G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMASK, G_TX_NOMASK, G_TX_NOLOD, G_TX_NOLOD);
-        gSP1Quadrangle(POLY_OPA_DISP++, vtx, vtx + 2, vtx + 3, vtx + 1, 0);
-    }
-#endif
-
     // blue divider lines
     gDPPipeSync(POLY_OPA_DISP++);
     gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 0, 255, 255, this->titleAlpha[0]);
@@ -1908,14 +1888,12 @@ void FileSelect_DrawOptionsImpl(GameState* thisx) {
     gSP1Quadrangle(POLY_OPA_DISP++, 0, 2, 3, 1, 0);
     Matrix_Pop();
 
-#if OOT_PAL_N64
     Matrix_Push();
     Matrix_Translate(0.0f, 0.8f, 0.0f, MTXMODE_APPLY);
     MATRIX_FINALIZE_AND_LOAD(POLY_OPA_DISP++, this->state.gfxCtx, "../z_file_nameset_PAL.c", UNK_LINE);
     gSPVertex(POLY_OPA_DISP++, gOptionsDividerLanguageVtx, 4, 0);
     gSP1Quadrangle(POLY_OPA_DISP++, 0, 2, 3, 1, 0);
     Matrix_Pop();
-#endif
 
     CLOSE_DISPS(this->state.gfxCtx, "../z_file_nameset_PAL.c", 1040);
 }
diff --git a/src/overlays/gamestates/ovl_file_choose/z_file_randomizer.c b/src/overlays/gamestates/ovl_file_choose/z_file_randomizer.c
new file mode 100644
index 000000000..0adff7a13
--- /dev/null
+++ b/src/overlays/gamestates/ovl_file_choose/z_file_randomizer.c
@@ -0,0 +1,341 @@
+#include "file_select.h"
+#include "file_select_state.h"
+
+#include "controller.h"
+#include "gfx_setupdl.h"
+#include "regs.h"
+#include "rumble.h"
+#include "sfx.h"
+#include "sys_matrix.h"
+#include "z64audio.h"
+#include "z64save.h"
+#include "assets/overlays/ovl_file_choose/ovl_file_choose.h"
+
+#include "assets/textures/title_static/title_static.h"
+#include "libc64/qrand.h"
+
+void FileSelect_LoadSave(GameState* thisx) {
+    FileSelectState* this = (FileSelectState*)thisx;
+
+    gSaveContext.fileNum = this->buttonIndex;
+    Sram_OpenSave(&this->sramCtx);
+    if (gSaveContext.save.randomizer.initialized) {
+        Audio_PlaySfxGeneral(NA_SE_SY_FSEL_DECIDE_L, &gSfxDefaultPos, 4, &gSfxDefaultFreqAndVolScale,
+                             &gSfxDefaultFreqAndVolScale, &gSfxDefaultReverb);
+
+        this->selectMode = SM_FADE_OUT;
+        func_800F6964(0xF);
+    } else {
+        Audio_PlaySfxGeneral(NA_SE_SY_FSEL_DECIDE_S, &gSfxDefaultPos, 4, &gSfxDefaultFreqAndVolScale,
+                             &gSfxDefaultFreqAndVolScale, &gSfxDefaultReverb);
+        this->menuMode = FS_MENU_MODE_CONFIG;
+        this->configMode = CM_MAIN_TO_RANDOMIZER;
+    }
+}
+
+void FileSelect_RotateToRandomizerSettings(GameState* thisx) {
+    FileSelectState* this = (FileSelectState*)thisx;
+
+    this->windowRot += VREG(16);
+
+    if (this->windowRot >= 314.0f) {
+        this->windowRot = 314.0f;
+        this->configMode = CM_START_RANDOMIZER_OPTIONS;
+    }
+}
+
+void FileSelect_StartRandomizerOptions(GameState* thisx) {
+    FileSelectState* this = (FileSelectState*)thisx;
+
+    this->nameEntryBoxAlpha += 25;
+
+    if (this->nameEntryBoxAlpha >= 255) {
+        this->nameEntryBoxAlpha = 255;
+    }
+
+    this->nameEntryBoxPosX -= 30;
+
+    if (this->nameEntryBoxPosX <= 0) {
+        this->nameEntryBoxPosX = 0;
+        this->nameEntryBoxAlpha = 255;
+        this->configMode = CM_RANDOMIZER_MENU;
+    }
+}
+
+void FileSelect_UpdateRandomizerOptionsMenu(GameState* thisx) {
+    FileSelectState* this = (FileSelectState*)thisx;
+    SramContext* sramCtx = &this->sramCtx;
+    Input* input = &this->state.input[0];
+
+    if (CHECK_BTN_ALL(input->press.button, BTN_B)) {
+        Audio_PlaySfxGeneral(NA_SE_SY_FSEL_CLOSE, &gSfxDefaultPos, 4, &gSfxDefaultFreqAndVolScale,
+                             &gSfxDefaultFreqAndVolScale, &gSfxDefaultReverb);
+        this->configMode = CM_RANDOMIZER_TO_MAIN;
+        return;
+    }
+
+    if (CHECK_BTN_ALL(input->press.button, BTN_START)) {
+        Audio_PlaySfxGeneral(NA_SE_SY_FSEL_DECIDE_L, &gSfxDefaultPos, 4, &gSfxDefaultFreqAndVolScale,
+                             &gSfxDefaultFreqAndVolScale, &gSfxDefaultReverb);
+        Rumble_Request(300.0f, 180, 20, 100);
+        gSaveContext.save.randomizer.seed = Rand_Next();
+        gSaveContext.save.randomizer.initialized = true;
+        Sram_WriteSave(sramCtx);
+        this->menuMode = FS_MENU_MODE_SELECT;
+        this->selectMode = SM_FADE_OUT;
+        func_800F6964(0xF);
+        return;
+    }
+
+    if (this->stickAdjX < -30) {
+        Audio_PlaySfxGeneral(NA_SE_SY_FSEL_CURSOR, &gSfxDefaultPos, 4, &gSfxDefaultFreqAndVolScale,
+                             &gSfxDefaultFreqAndVolScale, &gSfxDefaultReverb);
+        gSaveContext.save.randomizer.shuffleChests ^= 1;
+    } else if (this->stickAdjX > 30) {
+        Audio_PlaySfxGeneral(NA_SE_SY_FSEL_CURSOR, &gSfxDefaultPos, 4, &gSfxDefaultFreqAndVolScale,
+                             &gSfxDefaultFreqAndVolScale, &gSfxDefaultReverb);
+        gSaveContext.save.randomizer.shuffleChests ^= 1;
+    }
+}
+
+void FileSelect_RotateToMainFromRandomizer(GameState* thisx) {
+    FileSelectState* this = (FileSelectState*)thisx;
+
+    this->windowRot += VREG(16);
+
+    if (this->windowRot >= 628.0f) {
+        this->windowRot = 0.0f;
+        this->configMode = CM_MAIN_MENU;
+        this->menuMode = FS_MENU_MODE_SELECT;
+        this->selectMode = SM_FADE_OUT_FILE_INFO;
+    }
+}
+
+void FileSelect_SetRandomizerSettingsVtx(GameState* thisx) {
+    FileSelectState* this = (FileSelectState*)thisx;
+
+    OPEN_DISPS(this->state.gfxCtx, __FILE_NAME__, __LINE__);
+
+    gDPPipeSync(POLY_OPA_DISP++);
+
+    CLOSE_DISPS(this->state.gfxCtx, __FILE_NAME__, __LINE__);;
+}
+
+typedef struct RandomizerMenuTextureInfo {
+    void* texture;
+    u16 width;
+    u16 height;
+} RandomizerMenuTextureInfo;
+
+static RandomizerMenuTextureInfo sRandomizerMenuHeaders[] = {
+    { gRandoSettingsENGTex, 64, 16 },
+    { gRandoShuffleENGTex, 64, 16 },
+};
+
+static RandomizerMenuTextureInfo sRandomizerToggleOptions[] = {
+    { gRandoNoENGTex, 32, 16 },
+    { gRandoYesENGTex, 32, 16 },
+};
+
+void FileSelect_DrawRandomizerSettings(GameState* thisx) {
+    static s16 cursorPrimRed = 255;
+    static s16 cursorPrimGreen = 255;
+    static s16 cursorPrimBlue = 255;
+    static s16 cursorEnvRed = 0;
+    static s16 cursorEnvGreen = 0;
+    static s16 cursorEnvBlue = 0;
+    static s16 cursorPulseDir = 1;
+    static s16 cursorFlashTimer = 20;
+    static s16 cursorPrimColors[][3] = {
+        { 255, 255, 255 },
+        { 0, 255, 255 },
+    };
+    static s16 cursorEnvColors[][3] = {
+        { 0, 0, 0 },
+        { 0, 150, 150 },
+    };
+    FileSelectState* this = (FileSelectState*)thisx;
+    s16 cursorRed;
+    s16 cursorGreen;
+    s16 cursorBlue;
+
+    OPEN_DISPS(this->state.gfxCtx, __FILE_NAME__, __LINE__);
+
+    cursorRed = ABS(cursorPrimRed - cursorPrimColors[cursorPulseDir][0]) / cursorFlashTimer;
+    cursorGreen = ABS(cursorPrimGreen - cursorPrimColors[cursorPulseDir][1]) / cursorFlashTimer;
+    cursorBlue = ABS(cursorPrimBlue - cursorPrimColors[cursorPulseDir][2]) / cursorFlashTimer;
+
+    if (cursorPrimRed >= cursorPrimColors[cursorPulseDir][0]) {
+        cursorPrimRed -= cursorRed;
+    } else {
+        cursorPrimRed += cursorRed;
+    }
+
+    if (cursorPrimGreen >= cursorPrimColors[cursorPulseDir][1]) {
+        cursorPrimGreen -= cursorGreen;
+    } else {
+        cursorPrimGreen += cursorGreen;
+    }
+
+    if (cursorPrimBlue >= cursorPrimColors[cursorPulseDir][2]) {
+        cursorPrimBlue -= cursorBlue;
+    } else {
+        cursorPrimBlue += cursorBlue;
+    }
+
+    cursorRed = ABS(cursorEnvRed - cursorEnvColors[cursorPulseDir][0]) / cursorFlashTimer;
+    cursorGreen = ABS(cursorEnvGreen - cursorEnvColors[cursorPulseDir][1]) / cursorFlashTimer;
+    cursorBlue = ABS(cursorEnvBlue - cursorEnvColors[cursorPulseDir][2]) / cursorFlashTimer;
+
+    if (cursorEnvRed >= cursorEnvColors[cursorPulseDir][0]) {
+        cursorEnvRed -= cursorRed;
+    } else {
+        cursorEnvRed += cursorRed;
+    }
+
+    if (cursorEnvGreen >= cursorEnvColors[cursorPulseDir][1]) {
+        cursorEnvGreen -= cursorGreen;
+    } else {
+        cursorEnvGreen += cursorGreen;
+    }
+
+    if (cursorEnvBlue >= cursorEnvColors[cursorPulseDir][2]) {
+        cursorEnvBlue -= cursorBlue;
+    } else {
+        cursorEnvBlue += cursorBlue;
+    }
+
+    if (--cursorFlashTimer == 0) {
+        cursorPrimRed = cursorPrimColors[cursorPulseDir][0];
+        cursorPrimGreen = cursorPrimColors[cursorPulseDir][1];
+        cursorPrimBlue = cursorPrimColors[cursorPulseDir][2];
+
+        cursorEnvRed = cursorEnvColors[cursorPulseDir][0];
+        cursorEnvGreen = cursorEnvColors[cursorPulseDir][1];
+        cursorEnvBlue = cursorEnvColors[cursorPulseDir][2];
+
+        cursorFlashTimer = 20;
+
+        if (++cursorPulseDir > 1) {
+            cursorPulseDir = 0;
+        }
+    }
+
+    // Headers
+    gSPVertex(POLY_OPA_DISP++, gRandoMenuHeadersVtx, 12, 0);
+
+    gDPPipeSync(POLY_OPA_DISP++);
+
+    gDPSetCombineLERP(POLY_OPA_DISP++, PRIMITIVE, ENVIRONMENT, TEXEL0, ENVIRONMENT, TEXEL0, 0, PRIMITIVE, 0, PRIMITIVE,
+                      ENVIRONMENT, TEXEL0, ENVIRONMENT, TEXEL0, 0, PRIMITIVE, 0);
+    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 255, 255, this->titleAlpha[1]);
+    gDPSetEnvColor(POLY_OPA_DISP++, 0, 0, 0, 255);
+
+    for (int i = 0, vtx = 0; i < 2; i++, vtx += 4) {
+        gDPLoadTextureBlock(POLY_OPA_DISP++, sRandomizerMenuHeaders[i].texture, G_IM_FMT_IA,
+                            G_IM_SIZ_8b, 64, 16,
+                            0, G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMASK, G_TX_NOMASK, G_TX_NOLOD, G_TX_NOLOD);
+        gSP1Quadrangle(POLY_OPA_DISP++, vtx, vtx + 2, vtx + 3, vtx + 1, 0);
+
+        if (i > 0) {
+            // Divider lines
+            gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 0, 255, 255, this->titleAlpha[1]);
+            gDPSetEnvColor(POLY_OPA_DISP++, 0, 0, 0, 0);
+
+            gDPLoadTextureBlock_4b(POLY_OPA_DISP++, gFileSelOptionsDividerTex, G_IM_FMT_IA, 256, 2, 0,
+                                   G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMASK, G_TX_NOMASK, G_TX_NOLOD,
+                                   G_TX_NOLOD);
+
+            vtx += 4;
+
+            Matrix_Push();
+            Matrix_Translate(0.0f, 0.1f, 0.0f, MTXMODE_APPLY);
+            MATRIX_FINALIZE_AND_LOAD(POLY_OPA_DISP++, this->state.gfxCtx, "../z_file_nameset_PAL.c", 1009);
+            gSP1Quadrangle(POLY_OPA_DISP++, vtx, vtx + 2, vtx + 3, vtx + 1, 0);
+            Matrix_Pop();
+        }
+    }
+
+    // Settings
+    gSPVertex(POLY_OPA_DISP++, gRandoMenuSettingsVtx, 12, 0);
+
+    gDPPipeSync(POLY_OPA_DISP++);
+
+    gDPSetCombineLERP(POLY_OPA_DISP++, PRIMITIVE, ENVIRONMENT, TEXEL0, ENVIRONMENT, TEXEL0, 0, PRIMITIVE, 0, PRIMITIVE,
+                      ENVIRONMENT, TEXEL0, ENVIRONMENT, TEXEL0, 0, PRIMITIVE, 0);
+    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 255, 255, this->titleAlpha[1]);
+    gDPSetEnvColor(POLY_OPA_DISP++, 0, 0, 0, 255);
+
+    gDPLoadTextureBlock(POLY_OPA_DISP++, gRandoChestsENGTex, G_IM_FMT_IA,
+                            G_IM_SIZ_8b, 64, 16,
+                            0, G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMASK, G_TX_NOMASK, G_TX_NOLOD, G_TX_NOLOD);
+    gSP1Quadrangle(POLY_OPA_DISP++, 0, 2, 3, 1, 0);
+
+    // Settings choices
+    for (int i = 0, vtx = 4; i < 2; i++, vtx += 4) {
+        gDPPipeSync(POLY_OPA_DISP++);
+        if (i == gSaveContext.save.randomizer.shuffleChests) {
+            gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, cursorPrimRed, cursorPrimGreen, cursorPrimBlue,
+                                this->titleAlpha[1]);
+            gDPSetEnvColor(POLY_OPA_DISP++, cursorEnvRed, cursorEnvGreen, cursorEnvBlue, 255);
+        } else {
+            gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 255, 255, 255, this->titleAlpha[1]);
+            gDPSetEnvColor(POLY_OPA_DISP++, 0, 0, 0, 255);
+        }
+
+        gDPLoadTextureBlock(POLY_OPA_DISP++, sRandomizerToggleOptions[i].texture, G_IM_FMT_IA,
+                                    G_IM_SIZ_8b, 32, 16,
+                                    0, G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMASK, G_TX_NOMASK, G_TX_NOLOD, G_TX_NOLOD);
+
+        gSP1Quadrangle(POLY_OPA_DISP++, vtx, vtx + 2, vtx + 3, vtx + 1, 0);
+    }
+
+    CLOSE_DISPS(this->state.gfxCtx, __FILE_NAME__, __LINE__);;
+}
+
+void FileSelect_DrawRandomizerMenu(GameState* thisx) {
+    FileSelectState* this = (FileSelectState*)thisx;
+
+    OPEN_DISPS(this->state.gfxCtx, __FILE_NAME__, __LINE__);
+
+    gDPPipeSync(POLY_OPA_DISP++);
+    gDPSetCombineMode(POLY_OPA_DISP++, G_CC_MODULATEIA_PRIM, G_CC_MODULATEIA_PRIM);
+    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, this->windowColor[0], this->windowColor[1], this->windowColor[2],
+                    this->windowAlpha);
+    gDPSetEnvColor(POLY_OPA_DISP++, 0, 0, 0, 0);
+
+    Matrix_Translate(0.0f, 0.0f, -93.6f, MTXMODE_NEW);
+    Matrix_Scale(0.78f, 0.78f, 0.78f, MTXMODE_APPLY);
+    Matrix_RotateX((this->windowRot - 314.0f) / 100.0f, MTXMODE_APPLY);
+
+    MATRIX_FINALIZE_AND_LOAD(POLY_OPA_DISP++, this->state.gfxCtx, "../z_file_choose.c", 2337);
+
+    gSPVertex(POLY_OPA_DISP++, &this->windowVtx[0], 32, 0);
+    gSPDisplayList(POLY_OPA_DISP++, gFileSelWindow1DL);
+
+    gSPVertex(POLY_OPA_DISP++, &this->windowVtx[32], 32, 0);
+    gSPDisplayList(POLY_OPA_DISP++, gFileSelWindow2DL);
+
+    gSPVertex(POLY_OPA_DISP++, &this->windowVtx[64], 16, 0);
+    gSPDisplayList(POLY_OPA_DISP++, gFileSelWindow3DL);
+
+    gDPPipeSync(POLY_OPA_DISP++);
+
+    FileSelect_DrawRandomizerSettings(&this->state);
+
+    gDPPipeSync(POLY_OPA_DISP++);
+
+    Gfx_SetupDL_39Opa(this->state.gfxCtx);
+
+    gDPSetCombineLERP(POLY_OPA_DISP++, PRIMITIVE, ENVIRONMENT, TEXEL0, ENVIRONMENT, TEXEL0, 0, PRIMITIVE, 0,
+                      PRIMITIVE, ENVIRONMENT, TEXEL0, ENVIRONMENT, TEXEL0, 0, PRIMITIVE, 0);
+    gDPSetPrimColor(POLY_OPA_DISP++, 0, 0, 100, 255, 255, this->controlsAlpha);
+    gDPSetEnvColor(POLY_OPA_DISP++, 0, 0, 0, 0);
+    gDPLoadTextureBlock(POLY_OPA_DISP++, gRandoControlsENGTex, G_IM_FMT_IA, G_IM_SIZ_8b, 144, 16,
+                        0, G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMIRROR | G_TX_WRAP, G_TX_NOMASK, G_TX_NOMASK,
+                        G_TX_NOLOD, G_TX_NOLOD);
+    gSPTextureRectangle(POLY_OPA_DISP++, 90 << 2, 204 << 2, 234 << 2, 220 << 2, G_TX_RENDERTILE, 0, 0, 1 << 10,
+                        1 << 10);
+
+    CLOSE_DISPS(this->state.gfxCtx, __FILE_NAME__, __LINE__);
+}
diff --git a/src/overlays/gamestates/ovl_randomizer/logic/dungeon_region.logic.c b/src/overlays/gamestates/ovl_randomizer/logic/dungeon_region.logic.c
new file mode 100644
index 000000000..72ef6063a
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/logic/dungeon_region.logic.c
@@ -0,0 +1,140 @@
+/*
+REGION                              NAME
+    AST COMMANDS
+total = 37
+*/
+{ DEKU_TREE_LOBBY,                  "Kokiri Forest", {
+    { AST_END }
+} },
+{ DEKU_TREE_LOBBY,                  "Gohma", {
+    { AST_HAS, ITEM_SLINGSHOT }, { AST_END }
+} },
+{ DEKU_TREE_BOSS,                   "Deku Tree Lobby", {
+    { AST_END }
+} },
+{ DODONGOS_CAVERN_LOBBY,            "Death Mountain Trail", {
+    { AST_END }
+} },
+{ DODONGOS_CAVERN_LOBBY,            "King Dodongo", {
+    { AST_HAS, ITEM_BOMB_BAG_20 }, { AST_HAS, ITEM_SLINGSHOT }, { AST_END }
+} },
+{ DODONGOS_CAVERN_BOSS,             "Dodongo's Cavern Lobby", {
+    { AST_END }
+} },
+{ JABU_JABUS_BELLY_LOBBY,           "Zora's Fountain", {
+    { AST_END }
+} },
+{ JABU_JABUS_BELLY_LOBBY,           "Barinade", {
+    { AST_HAS, ITEM_BOOMERANG }, { AST_END }
+} },
+{ JABU_JABUS_BELLY_BOSS,            "Jabu-Jabu's Belly Lobby", {
+    { AST_IS_CHILD }, { AST_END }
+} },
+{ BOTTOM_OF_THE_WELL_LOBBY,         "Kakariko Village", {
+    { AST_END }
+} },
+{ FOREST_TEMPLE_LOBBY,              "Sacred Forest Meadow", {
+    { AST_END }
+} },
+{ FOREST_TEMPLE_LOBBY,              "Phantom Ganon", {
+    { AST_HAS_COUNT, ITEM_SMALL_KEY_FOREST_TEMPLE, 5 }, { AST_HAS, ITEM_DUNGEON_BOSS_KEY_FOREST_TEMPLE }, { AST_CAN_USE, ITEM_BOW }, { AST_END }
+} },
+{ FOREST_TEMPLE_BOSS,               "Forest Temple Lobby", {
+    { AST_END }
+} },
+{ FOREST_TEMPLE_LOBBY,              "Forest Temple Block Push Room", {
+    { AST_HAS_COUNT, ITEM_SMALL_KEY_FOREST_TEMPLE, 1 }, { AST_END }
+} },
+{ FOREST_TEMPLE_BLOCK_PUSH_ROOM,    "Forest Temple Outside Upper Ledge", {
+    { AST_CAN_USE, ITEM_BOOTS_HOVER }, { AST_END }
+} },
+{ FOREST_TEMPLE_BLOCK_PUSH_ROOM,    "Forest Temple Bow Region", {
+    { AST_HAS_COUNT, ITEM_SMALL_KEY_FOREST_TEMPLE, 3 }, { AST_END }
+} },
+{ FOREST_TEMPLE_BLOCK_PUSH_ROOM,    "Forest Temple Straightened Hall", {
+    { AST_HAS_COUNT, ITEM_SMALL_KEY_FOREST_TEMPLE, 2 }, { AST_CAN_USE, ITEM_BOW }, { AST_END }
+} },
+{ FOREST_TEMPLE_STRAIGHT_HALL,      "Forest Temple Outside Upper Ledge", {
+    { AST_END }
+} },
+{ FOREST_TEMPLE_OUTSIDE_UPPER,      "Forest Temple Lobby", {
+    { AST_END }
+} },
+{ FOREST_TEMPLE_BOW_REGION,         "Forest Temple Frozen Eye Switch Room", {
+    { AST_HAS_COUNT, ITEM_SMALL_KEY_FOREST_TEMPLE, 5 }, { AST_END }
+} },
+{ FOREST_TEMPLE_FROZEN_EYE,         "Forest Temple Lobby", {
+    { AST_END }
+} },
+{ FIRE_TEMPLE_LOBBY,                "Death Mountain Crater Central", {
+    { AST_END }
+} },
+{ FIRE_TEMPLE_LOBBY,                "Volvagia", {
+    { AST_HAS, ITEM_DUNGEON_BOSS_KEY_FIRE_TEMPLE }, { AST_HAS, ITEM_HAMMER }, { AST_HAS, ITEM_BOOTS_HOVER }, { AST_END }
+} },
+{ FIRE_TEMPLE_BOSS,                 "Fire Temple Lobby", {
+    { AST_END }
+} },
+{ FIRE_TEMPLE_LOBBY, "Fire Temple Big Lava Room", {
+    { AST_HAS_COUNT, ITEM_SMALL_KEY_FIRE_TEMPLE, 2 }, { AST_END }
+} },
+{ FIRE_TEMPLE_BIG_LAVA_ROOM, "Fire Temple Elevator Room", {
+    { AST_HAS_COUNT, ITEM_SMALL_KEY_FIRE_TEMPLE, 3 }, { AST_END }
+} },
+{ FIRE_TEMPLE_ELEVATOR_ROOM, "Fire Temple Boulder Maze Lower", {
+    { AST_HAS_COUNT, ITEM_SMALL_KEY_FIRE_TEMPLE, 4 }, { AST_END }
+} },
+{ FIRE_TEMPLE_MAZE_LOWER, "Fire Temple Narrow Path Room", {
+    { AST_HAS_COUNT, ITEM_SMALL_KEY_FIRE_TEMPLE, 5 }, { AST_END }
+} },
+{ FIRE_TEMPLE_NARROW_PATH, "Fire Temple Boulder Maze Upper", {
+    { AST_HAS_COUNT, ITEM_SMALL_KEY_FIRE_TEMPLE, 6 }, { AST_END }
+} },
+{ FIRE_TEMPLE_MAZE_UPPER, "Fire Temple Flame Maze", {
+    { AST_HAS_COUNT, ITEM_SMALL_KEY_FIRE_TEMPLE, 7 }, { AST_END }
+} },
+{ FIRE_TEMPLE_FLAME_MAZE, "Fire Temple Upper", {
+    { AST_HAS_COUNT, ITEM_SMALL_KEY_FIRE_TEMPLE, 8 }, { AST_OR }, { AST_HAS, ITEM_BOOTS_HOVER }, { AST_HAS, ITEM_HAMMER }, { AST_END }
+} },
+{ FIRE_TEMPLE_UPPER, "Volvagia", {
+    { AST_HAS, ITEM_DUNGEON_BOSS_KEY_FIRE_TEMPLE }, { AST_HAS, ITEM_HAMMER }, { AST_END }
+} },
+{ WATER_TEMPLE_LOBBY,               "Lake Hylia", {
+    { AST_END }
+} },
+{ WATER_TEMPLE_LOBBY,               "Morpha", {
+    { AST_HAS, ITEM_DUNGEON_BOSS_KEY_WATER_TEMPLE }, { AST_HAS, ITEM_LONGSHOT }, { AST_END }
+} },
+{ WATER_TEMPLE_BOSS,                "Water Temple Lobby", {
+    { AST_END }
+} },
+{ SHADOW_TEMPLE_LOBBY,              "Graveyard", {
+    { AST_END }
+} },
+{ SHADOW_TEMPLE_LOBBY,              "Bongo-Bongo", {
+    { AST_HAS_COUNT, ITEM_SMALL_KEY_SHADOW_TEMPLE, 4 }, { AST_HAS, ITEM_DUNGEON_BOSS_KEY_SHADOW_TEMPLE }, { AST_HAS, ITEM_BOOTS_HOVER }, { AST_END }
+} },
+{ SHADOW_TEMPLE_BOSS,               "Shadow Temple Lobby", {
+    { AST_END }
+} },
+{ SPIRIT_TEMPLE_LOBBY,              "Desert Colossus", {
+    { AST_END }
+} },
+{ SPIRIT_TEMPLE_LOBBY,              "Twinrova", {
+    { AST_IS_ADULT }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SPIRIT_TEMPLE, 5 }, { AST_HAS, ITEM_DUNGEON_BOSS_KEY_SPIRIT_TEMPLE }, { AST_HAS, ITEM_SHIELD_MIRROR }, { AST_HAS, ITEM_LONGSHOT }, { AST_END }
+} },
+{ SPIRIT_TEMPLE_BOSS,               "Spirit Temple Lobby", {
+    { AST_END }
+} },
+{ ICE_CAVERN_LOBBY,                 "Zora's Fountain", {
+    { AST_END }
+} },
+{ GERUDO_TRAINING_GROUND_LOBBY,     "Gerudo Fortress", {
+    { AST_END }
+} },
+{ GANONS_CASTLE_LOBBY,              "Outside Ganon's Castle", {
+    { AST_END }
+} },
+{ GANONS_CASTLE_LOBBY,              "Ganon's Castle Tower", {
+    { AST_HAS_COUNT, ITEM_SMALL_KEY_GANONS_CASTLE, 2 }, { AST_END }
+} },
\ No newline at end of file
diff --git a/src/overlays/gamestates/ovl_randomizer/logic/gerudo_region.logic.c b/src/overlays/gamestates/ovl_randomizer/logic/gerudo_region.logic.c
new file mode 100644
index 000000000..e4f60d8ce
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/logic/gerudo_region.logic.c
@@ -0,0 +1,35 @@
+/*
+REGION                      NAME
+    AST COMMANDS
+total = 8
+*/
+{ GERUDO_VALLEY,            "Hyrule Field", {
+    { AST_END }
+} },
+{ GERUDO_VALLEY,            "Lake Hylia", {
+    { AST_END }
+} },
+{ GERUDO_VALLEY,            "Gerudo Valley Far Side", {
+    { AST_IS_ADULT }, { AST_END }
+} },
+{ GERUDO_VALLEY_FAR_SIDE,   "Gerudo Fortress", {
+    { AST_END }
+} },
+{ GERUDO_FORTRESS,          "Haunted Wasteland", {
+    { AST_HAS, ITEM_LONGSHOT }, { AST_OR }, { AST_HAS, ITEM_BOOTS_HOVER }, { AST_END }
+} },
+{ GERUDO_FORTRESS,          "Gerudo Training Ground Lobby", {
+    { AST_END }
+} },
+{ HAUNTED_WASTELAND,        "Desert Colossus", {
+    { AST_HAS, ITEM_LENS_OF_TRUTH }, {AST_AND}, { AST_CAN_REACH, DEATH_MOUNTAIN_CRATER_UPPER, LINK_AGE_CHILD }, { AST_END }
+} },
+{ DESERT_COLOSSUS,          "Spirit Temple Lobby", {
+    { AST_END }
+} },
+{ SPIRIT_TEMPLE_LOBBY,      "Spirit Temple Hands", {
+    { AST_HAS_COUNT, ITEM_SMALL_KEY_SPIRIT_TEMPLE, 5 }, { AST_OR }, { AST_GROUP_OPEN }, { AST_IS_ADULT }, { AST_AND }, { AST_HAS, ITEM_BOMB_BAG_20 }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SPIRIT_TEMPLE, 3 }, { AST_GROUP_CLOSE }, { AST_END }
+} },
+{ SPIRIT_TEMPLE_HANDS,       "Desert Colossus", {
+    { AST_END }
+} },
\ No newline at end of file
diff --git a/src/overlays/gamestates/ovl_randomizer/logic/goron_region.logic.c b/src/overlays/gamestates/ovl_randomizer/logic/goron_region.logic.c
new file mode 100644
index 000000000..1a2c4bf99
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/logic/goron_region.logic.c
@@ -0,0 +1,67 @@
+/*
+REGION                              NAME
+    AST COMMANDS
+total = 18
+*/
+{ DEATH_MOUNTAIN,                   "Kakariko Village",                 {
+    { AST_END }
+} },
+{ DEATH_MOUNTAIN,                   "Goron City",                       {
+    { AST_END }
+} },
+{ DEATH_MOUNTAIN,                   "Death Mountain Crater Upper",      {
+    { AST_CAN_BLAST_OR_SMASH }, { AST_END }
+} },
+{ DEATH_MOUNTAIN,                   "Dodongo's Cavern Lobby",           {
+    { AST_HAS, ITEM_BOMB_BAG_20 }, { AST_OR }, { AST_CAN_LEAVE_FOREST }, { AST_END }
+} },
+{ GORON_CITY,                       "Death Mountain Trail",             {
+    { AST_END }
+} },
+{ GORON_CITY,                       "Death Mountain Crater Lower",      {
+    { AST_IS_ADULT }, { AST_END }
+} },
+{ GORON_CITY,                       "Goron City Woods Warp",            {
+    { AST_END }
+} },
+{ GORON_CITY_WOODS_WARP,            "Goron City",                       {
+    { AST_CAN_BLAST_OR_SMASH }, { AST_END }
+} },
+{ GORON_CITY_WOODS_WARP,            "Lost Woods",                       {
+    { AST_CAN_BLAST_OR_SMASH }, { AST_END }
+} },
+{ DEATH_MOUNTAIN_CRATER_UPPER,      "Death Mountain Trail",             {
+    { AST_END }
+} },
+{ DEATH_MOUNTAIN_CRATER_UPPER,      "Death Mountain Crater Lower",      {
+    { AST_IS_ADULT }, { AST_AND }, { AST_HAS, ITEM_BOOTS_HOVER }, { AST_OR }, { AST_AT, DEATH_MOUNTAIN_CRATER_LOWER, { AST_CAN_USE, ITEM_HAMMER }}, { AST_END }
+} },
+{ DEATH_MOUNTAIN_CRATER_UPPER,      "Death Mountain Crater Central",    {
+    { AST_IS_ADULT }, { AST_CAN_USE, ITEM_LONGSHOT }, { AST_END }
+} },
+{ DEATH_MOUNTAIN_CRATER_LOWER,      "Goron City",                       {
+    { AST_END }
+} },
+{ DEATH_MOUNTAIN_CRATER_LOWER,      "Death Mountain Crater Central",    {
+    { AST_IS_ADULT}, { AST_AND },
+    { AST_GROUP_OPEN },
+    { AST_HAS, ITEM_BOOTS_HOVER }, { AST_OR }, { AST_HAS, ITEM_HOOKSHOT },
+    { AST_GROUP_CLOSE },
+    { AST_END }
+} },
+{ DEATH_MOUNTAIN_CRATER_LOWER,      "Death Mountain Crater Upper",      {
+    { AST_IS_ADULT }, { AST_END }
+} },
+{ DEATH_MOUNTAIN_CRATER_CENTRAL,    "Death Mountain Crater Lower",      {
+    { AST_IS_ADULT }, { AST_AND },
+    { AST_GROUP_OPEN },
+    { AST_HAS, ITEM_BOOTS_HOVER }, { AST_OR }, { AST_HAS, ITEM_HOOKSHOT }, { AST_OR }, { AST_CAN_REACH, ZORA_RIVER, LINK_AGE_CHILD }/* beans */,
+    { AST_GROUP_CLOSE},
+    { AST_END }
+} },
+{ DEATH_MOUNTAIN_CRATER_CENTRAL,    "Fire Temple Lobby",                {
+    { AST_IS_ADULT }, { AST_END }
+} },
+{ DEATH_MOUNTAIN_CRATER_CENTRAL,    "Death Mountain Crater Upper",                  {
+    { AST_IS_ADULT }, { AST_AND }, { AST_CAN_REACH, ZORA_RIVER, LINK_AGE_CHILD }/* beans */, { AST_END }
+} },
\ No newline at end of file
diff --git a/src/overlays/gamestates/ovl_randomizer/logic/hyrule_region.logic.c b/src/overlays/gamestates/ovl_randomizer/logic/hyrule_region.logic.c
new file mode 100644
index 000000000..a46b0bbfe
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/logic/hyrule_region.logic.c
@@ -0,0 +1,83 @@
+/*
+REGION                      NAME
+    AST COMMANDS
+total = 26
+*/
+{ HYRULE_FIELD,             "Lost Woods Bridge", {
+    { AST_END }
+} },
+{ HYRULE_FIELD,             "Lake Hylia", {
+    { AST_END }
+} },
+{ HYRULE_FIELD,             "Gerudo Valley", {
+    { AST_END }
+} },
+{ HYRULE_FIELD,             "Market", {
+    { AST_END }
+} },
+{ HYRULE_FIELD,             "Kakariko Village", {
+    { AST_END }
+} },
+{ HYRULE_FIELD,             "Zora River Front", {
+    { AST_END }
+} },
+{ HYRULE_FIELD,             "Lon Lon Ranch", {
+    { AST_END }
+} },
+{ LAKE_HYLIA,               "Hyrule Field", {
+    { AST_END }
+} },
+{ LAKE_HYLIA,               "Zora's Domain", {
+    { AST_CAN_REACH, ZORAS_DOMAIN, LINK_AGE_CHILD }, { AST_OR }, { AST_CAN_USE, ITEM_BOOTS_IRON }, { AST_END }
+} },
+{ LAKE_HYLIA,               "Water Temple Lobby", {
+    { AST_IS_ADULT }, { AST_AND }, { AST_CAN_USE, ITEM_HOOKSHOT }, { AST_AND }, { AST_CAN_USE, ITEM_BOOTS_IRON }, { AST_END }
+} },
+{ CASTLE_TOWN,              "Hyrule Field", {
+    { AST_END }
+} },
+{ CASTLE_TOWN,              "Temple of Time", {
+    { AST_END }
+} },
+{ CASTLE_TOWN,              "Hyrule Castle Grounds", {
+    { AST_IS_CHILD }, { AST_END }
+} },
+{ CASTLE_TOWN,              "Outside Ganon's Castle", {
+    { AST_IS_ADULT }, { AST_END }
+} },
+{ TEMPLE_OF_TIME,           "Market", {
+    { AST_END }
+} },
+{ TEMPLE_OF_TIME,           "Beyond Door of Time", {
+    { AST_CAN_TIME_TRAVEL }, { AST_END }
+} },
+{ BEYOND_DOOR_OF_TIME,      "Temple of Time", {
+    { AST_END }
+} },
+{ HYRULE_CASTLE_GROUNDS,    "Market", {
+    { AST_END }
+} },
+{ GANONS_CASTLE_GROUNDS,    "Market", {
+    { AST_END }
+} },
+{ GANONS_CASTLE_GROUNDS,    "Ganon's Castle Lobby", {
+    { AST_CAN_MAKE_RAINBOW_BRIDGE }, { AST_END }
+ } },
+{ KAKARIKO_VILLAGE,         "Hyrule Field", {
+    { AST_END }
+} },
+{ KAKARIKO_VILLAGE,         "Bottom of the Well Lobby", {
+    { AST_IS_CHILD }, { AST_AND }, { AST_CAN_PLAY, ITEM_SONG_STORMS }, { AST_END }
+} },
+{ KAKARIKO_VILLAGE,         "Graveyard", {
+    { AST_END }
+} },
+{ KAKARIKO_VILLAGE,         "Death Mountain Trail", {
+    { AST_END }
+} },
+{ GRAVEYARD,                "Kakariko Village", {
+    { AST_END }
+} },
+{ LON_LON_RANCH,            "Hyrule Field", {
+    { AST_END }
+} },
\ No newline at end of file
diff --git a/src/overlays/gamestates/ovl_randomizer/logic/kokiri_forest_region.logic.c b/src/overlays/gamestates/ovl_randomizer/logic/kokiri_forest_region.logic.c
new file mode 100644
index 000000000..879171c5e
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/logic/kokiri_forest_region.logic.c
@@ -0,0 +1,44 @@
+/*
+REGION                          NAME
+    AST COMMANDS
+total = 13
+*/
+{ KOKIRI_FOREST,                "Deku Tree Lobby", {
+    { AST_IS_CHILD }, { AST_AND }, { AST_HAS, ITEM_SWORD_KOKIRI }, { AST_END }
+} },
+{ KOKIRI_FOREST,                "Lost Woods", {
+    { AST_END }
+} },
+{ KOKIRI_FOREST,                "Lost Woods Bridge", {
+    { AST_CAN_LEAVE_FOREST },{ AST_END }
+} },
+{ LOST_WOODS,                   "Kokiri Forest", {
+    { AST_END }
+} },
+{ LOST_WOODS,                   "Sacred Forest Meadow Entry", {
+    { AST_END }
+} },
+{ LOST_WOODS,                   "Goron City Woods Warp", {
+    { AST_END }
+} },
+{ LOST_WOODS,                   "Zora River", {
+    { AST_CAN_REACH, ZORAS_DOMAIN, LINK_AGE_CHILD }, { AST_OR }, { AST_CAN_USE, ITEM_BOOTS_IRON },{ AST_END }
+} },
+{ SACRED_FOREST_MEADOW_ENTRY,   "Lost Woods", {
+    { AST_END }
+} },
+{ SACRED_FOREST_MEADOW_ENTRY,   "Sacred Forest Meadow", {
+    { AST_END }
+} },
+{ SACRED_FOREST_MEADOW,         "Sacred Forest Meadow Entry", {
+    { AST_END }
+} },
+{ SACRED_FOREST_MEADOW,         "Forest Temple Lobby", {
+    { AST_IS_ADULT }, { AST_AND }, { AST_CAN_USE, ITEM_HOOKSHOT }, { AST_END }
+} },
+{ LOST_WOODS_BRIDGE,            "Kokiri Forest", {
+    { AST_END }
+} },
+{ LOST_WOODS_BRIDGE,            "Hyrule Field", {
+    { AST_END }
+} },
\ No newline at end of file
diff --git a/src/overlays/gamestates/ovl_randomizer/logic/root_region.logic.c b/src/overlays/gamestates/ovl_randomizer/logic/root_region.logic.c
new file mode 100644
index 000000000..7bd5fc659
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/logic/root_region.logic.c
@@ -0,0 +1,22 @@
+/*
+REGION  NAME
+    AST COMMANDS
+total = 4
+*/
+{ ROOT, "Kokiri Forest", {
+    { AST_IS_CHILD }, { AST_END }
+} },
+{ ROOT, "Temple of Time", {
+    { AST_IS_ADULT }, { AST_CAN_TIME_TRAVEL }, { AST_END }
+} },
+{ ROOT, "Shadow Temple Lobby", {
+    { AST_IS_ADULT }, { AST_CAN_TIME_TRAVEL }, { AST_AND },{ AST_AND }, { AST_CAN_PLAY, ITEM_SONG_NOCTURNE }, { AST_AND },
+    { AST_GROUP_OPEN },
+    { AST_HAS, ITEM_HOOKSHOT }, { AST_OR }, { AST_HAS, ITEM_BOOTS_HOVER },
+    { AST_GROUP_CLOSE },
+    { AST_AND }, { AST_CAN_USE, ITEM_LENS_OF_TRUTH },
+    { AST_END }
+} },
+{ ROOT, "Desert Colossus", {
+    { AST_CAN_PLAY, ITEM_SONG_REQUIEM }, { AST_AND }, { AST_GROUP_OPEN }, { AST_IS_CHILD }, { AST_OR }, { AST_CAN_TIME_TRAVEL }, { AST_GROUP_CLOSE }, { AST_END }
+} },
\ No newline at end of file
diff --git a/src/overlays/gamestates/ovl_randomizer/logic/zora_region.logic.c b/src/overlays/gamestates/ovl_randomizer/logic/zora_region.logic.c
new file mode 100644
index 000000000..f49757736
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/logic/zora_region.logic.c
@@ -0,0 +1,35 @@
+/*
+REGION              NAME
+    AST COMMANDS
+total = 10
+*/
+{ ZORA_RIVER_FRONT, "Zora River", {
+    { AST_CAN_BLAST_OR_SMASH }, { AST_END }
+} },
+{ ZORA_RIVER,       "Zora's Domain", {
+    { AST_CAN_PLAY, ITEM_SONG_LULLABY }, { AST_END }
+} },
+{ ZORA_RIVER,       "Zora River Front", {
+    { AST_END }
+} },
+{ ZORA_RIVER,       "Lost Woods", {
+    { AST_END }
+} },
+{ ZORAS_DOMAIN,     "Zora River", {
+    { AST_END }
+} },
+{ ZORAS_DOMAIN,     "Zora's Fountain", {
+    { AST_END }
+} },
+{ ZORAS_DOMAIN,     "Lake Hylia", {
+    { AST_END }
+} },
+{ ZORAS_FOUNTAIN,   "Zora's Domain", {
+    { AST_END }
+} },
+{ ZORAS_FOUNTAIN,   "Jabu-Jabu's Belly Lobby", {
+    { AST_IS_CHILD }, { AST_END }
+} },
+{ ZORAS_FOUNTAIN,   "Ice Cavern Lobby", {
+    { AST_IS_ADULT }, { AST_END }
+} },
\ No newline at end of file
diff --git a/src/overlays/gamestates/ovl_randomizer/r_ast.c b/src/overlays/gamestates/ovl_randomizer/r_ast.c
new file mode 100644
index 000000000..49edf8c4b
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_ast.c
@@ -0,0 +1,431 @@
+#include "r_ast.h"
+
+#include "fault.h"
+#include "printf.h"
+#include "r_entrance.h"
+#include "r_item_info.h"
+#include "r_location.h"
+#include "r_tables.h"
+#include "zelda_arena.h"
+
+Ast *Ast_Init(Ast ast) {
+    Ast *ptr = ZELDA_ARENA_MALLOC(sizeof(Ast), __FILE_NAME__, __LINE__);
+    if (ptr) {
+        *ptr = ast;
+    }
+    return ptr;
+}
+
+bool initialIteration = true;
+bool initialIteration2 = true;
+
+bool has(Search* search, ItemID item, u8 count) {
+    unsigned solverId = itemIdToSolverId[item];
+    if (solverId == UINT32_MAX) { return false; }
+    return search->state->solvItems[solverId] >= count;
+}
+
+bool isAdult(Search* search, LinkAge age) {
+    bool result = age == LINK_AGE_ADULT;
+    result = result && has(search, EVENT_DEFEAT_GOHMA, 1);
+    result = result && has(search, EVENT_DEFEAT_KING_DODONGO, 1);
+    return result && has(search, EVENT_DEFEAT_BARINADE, 1);
+}
+
+bool isAdultItem(ItemID item) {
+    return (item == ITEM_BOW || item == ITEM_HAMMER || item == ITEM_BOOTS_IRON || item == ITEM_HOOKSHOT
+        || item == ITEM_LONGSHOT || item == ITEM_STRENGTH_SILVER_GAUNTLETS || item == ITEM_STRENGTH_GOLD_GAUNTLETS
+        || item == ITEM_SHIELD_MIRROR);
+}
+bool isChildItem(ItemID item) {
+    return item == ITEM_SLINGSHOT || item == ITEM_BOOMERANG || item == ITEM_SWORD_KOKIRI;
+}
+
+bool canLeaveForest(Search* search) {
+    return has(search, EVENT_DEFEAT_GOHMA, 1);
+}
+
+bool canPlay(Search* search, LinkAge age, ItemID song)
+{
+    bool result = canLeaveForest(search) || age == LINK_AGE_ADULT; // ocarina access
+    switch (song) {
+        case ITEM_SONG_LULLABY: {
+            result = result && Search_CanReach(search, regionTable[HYRULE_CASTLE_GROUNDS].name, LINK_AGE_CHILD);
+        } break;
+        case ITEM_SONG_STORMS: {
+            result = result && Search_CanReach(search, regionTable[KAKARIKO_VILLAGE].name, LINK_AGE_ADULT);
+        } break;
+        case ITEM_SONG_NOCTURNE: {
+            result = result && has(search, EVENT_DEFEAT_PHANTOM_GANON, 1);
+            result = result && has(search, EVENT_DEFEAT_VOLVAGIA, 1);
+            result = result && has(search, EVENT_DEFEAT_MORPHA, 1);
+        } break;
+        case ITEM_SONG_REQUIEM: {
+            result = result && Search_CanReach(search, regionTable[DESERT_COLOSSUS].name, LINK_AGE_EITHER);
+        } break;
+        default:
+            break;
+    }
+    return result;
+}
+
+bool canUse(Search* search, LinkAge age, ItemID item)
+{
+    if (isAdultItem(item)) {
+        return age == LINK_AGE_ADULT && search->state->solvItems[itemIdToSolverId[item]];
+    }
+    if (item == ITEM_LENS_OF_TRUTH) {
+        // has magic && item
+        return canPlay(search, age, ITEM_SONG_LULLABY) && Search_CanReach(search, regionTable[DEATH_MOUNTAIN_CRATER_UPPER].name, LINK_AGE_EITHER) && search->state->solvItems[itemIdToSolverId[item]];
+    }
+    return age == LINK_AGE_CHILD && search->state->solvItems[itemIdToSolverId[item]];
+}
+
+bool evaluateGroup_Entrance(Ast** ptr, Search* search, Entrance spot, LinkAge age, size_t* offset) {
+    PRINTF("\n");
+    const Ast* astArr = *ptr;
+
+    unsigned nRules = 1;
+    while (true) {
+        // PRINTF("Found tag %u\n", astArr[*offset + nRules].tag);
+        if (astArr[*offset + nRules].tag == AST_GROUP_CLOSE) { break; }
+        nRules++;
+    }
+    if (nRules) {
+        Ast subAst[nRules];
+        for (size_t i = 0; i < nRules; i++) {
+            // PRINTF("Adding tag %u to subexpression\n", astArr[*offset + i + 1]);
+            subAst[i] = astArr[*offset + i + 1];
+        }
+        Ast* subAstArr[1] = { subAst };
+        bool result = Ast_Eval_Entrance(subAstArr, search, spot, age);
+        *offset += nRules;
+        // PRINTF("Next tag to process %u offset %u\n", astArr[*offset].tag, *offset);
+        return result;
+    }
+    return true;
+}
+
+bool evaluateGroup_Location(Ast** ptr, Search* search, Location spot, LinkAge age, size_t* offset) {
+    // PRINTF("\n");
+    const Ast* astArr = *ptr;
+
+    unsigned nRules = 1;
+    while (true) {
+        // PRINTF("Found tag %u\n", astArr[*offset + nRules].tag);
+        if (astArr[*offset + nRules].tag == AST_GROUP_CLOSE) { break; }
+        nRules++;
+    }
+    if (nRules) {
+        Ast subAst[nRules];
+        for (size_t i = 0; i < nRules; i++) {
+            // PRINTF("Adding tag %u to subexpression\n", astArr[*offset + i + 1]);
+            subAst[i] = astArr[*offset + i + 1];
+        }
+        Ast* subAstArr[1] = { subAst };
+        bool result = Ast_Eval_Location(subAstArr, search, spot, age);
+        *offset += nRules;
+        // PRINTF("Next tag to process %u offset %u\n", astArr[*offset].tag, *offset);
+        return result;
+    }
+    return true;
+}
+
+bool Ast_Eval_Entrance(Ast** ptr, Search* search, Entrance spot, LinkAge age) {
+    const Ast* astArr = *ptr;
+    bool wasInitialIteration = initialIteration;
+    initialIteration = false;
+
+    if (wasInitialIteration) {
+        PRINTF("ENTRANCE: Evaluating %s access as %s\n", spot.name, age == LINK_AGE_ADULT ? "Adult" : "Child");
+    }
+
+    bool result = true;
+    bool eval = false;
+    bool compound = false;
+    for (size_t i = 0; astArr[i].tag != AST_END; i++) {
+        eval = true;
+        Ast ast = astArr[i];
+        int count = 1;
+
+        switch (ast.tag) {
+            case AST_AND: {
+                compound = true;
+                PRINTF("AND ");
+                i++;
+                if (astArr[i].tag == AST_GROUP_OPEN) {
+                    PRINTF("\nGROUP_OPEN (by AND) ");
+                    result = evaluateGroup_Entrance(ptr, search, spot, age, &i);
+                } else {
+                    Ast subAst[2] = { astArr[i], AST_END };
+                    Ast* subAstArr[1] = { subAst };
+                    result = Ast_Eval_Entrance(subAstArr, search, spot, age);
+                }
+            } break;
+            case AST_OR: {
+                compound = true;
+                PRINTF("OR ");
+                i++;
+                if (astArr[i].tag == AST_GROUP_OPEN) {
+                    PRINTF("\nGROUP_OPEN (by OR) ");
+                    bool tempResult = evaluateGroup_Entrance(ptr, search, spot, age, &i);
+                    result = result || tempResult;
+                } else {
+                    Ast subAst[2] = { astArr[i], AST_END };
+                    Ast* subAstArr[1] = { subAst };
+                    /* Short-circuits */
+                    result = result || Ast_Eval_Entrance(subAstArr, search, spot, age);
+                }
+            } break;
+            case AST_GROUP_OPEN: {
+                compound = true;
+                PRINTF("GROUP_OPEN ");
+                result = evaluateGroup_Entrance(ptr, search, spot, age, &i);
+            } break;
+            case AST_GROUP_CLOSE: {
+                return result;
+                PRINTF("GROUP_CLOSE ");
+            } break;
+            case AST_CAN_REACH: {
+                struct AST_CAN_REACH data = ast.data.AST_CAN_REACH;
+                PRINTF("CAN_REACH %s ", regionTable[data.region].name);
+                result = Search_CanReach(search, regionTable[data.region].name, data.age);
+            } break;
+            case AST_IS_CHILD: {
+                PRINTF("IS_CHILD ");
+                result = age == LINK_AGE_CHILD;
+            } break;
+            case AST_IS_ADULT: {
+                PRINTF("IS_ADULT ");
+                result = isAdult(search, age);
+            } break;
+            case AST_NAME: {
+                struct AST_NAME data = ast.data.AST_NAME;
+                PRINTF("NAME IS %s ", data.name);
+                result = strcmp(data.name, spot.name) == 0;
+            } break;
+            case AST_AT: {
+                struct AST_AT data = ast.data.AST_AT;
+                PRINTF("AT %s ", regionTable[data.region].name);
+                result = Ast_Eval_Entrance(&data.subRule, search, spot, age);
+            } break;
+            case AST_HAS_COUNT: {
+                struct AST_HAS_COUNT data = ast.data.AST_HAS_COUNT;
+                count = data.count;
+            } FALLTHROUGH;
+            case AST_HAS: {
+                struct AST_HAS data = ast.data.AST_HAS;
+                PRINTF("HAS %s %u ", itemTable[data.item].name, count);
+                result = has(search, data.item, count);
+            } break;
+            case AST_CAN_BLAST_OR_SMASH: {
+                PRINTF("CAN_BLAST_OR_SMASH ");
+                unsigned bombBagSolverId = itemIdToSolverId[ITEM_BOMB_BAG_20];
+                result = search->state->solvItems[bombBagSolverId] || canUse(search, age, ITEM_HAMMER);
+            } break;
+            case AST_CAN_PLAY: {
+                struct AST_CAN_PLAY data = ast.data.AST_CAN_PLAY;
+                PRINTF("CAN_PLAY %d ", data.song);
+                result = canPlay(search, age, data.song);
+            } break;
+            case AST_CAN_TIME_TRAVEL: {
+                PRINTF("CAN_TIME_TRAVEL ");
+                result = has(search, EVENT_DEFEAT_GOHMA, 1);
+                result = result && has(search, EVENT_DEFEAT_KING_DODONGO, 1);
+                result = result && has(search, EVENT_DEFEAT_BARINADE, 1);
+            } break;
+            case AST_CAN_USE: {
+                struct AST_CAN_USE data = ast.data.AST_CAN_USE;
+                PRINTF("CAN_USE %s ", itemTable[data.item].name);
+                result = canUse(search, age, data.item);
+            } break;
+            case AST_CAN_LEAVE_FOREST: {
+                PRINTF("CAN_LEAVE_FOREST ");
+                result = canLeaveForest(search);
+            } break;
+            case AST_CAN_MAKE_RAINBOW_BRIDGE: {
+                PRINTF("CAN_MAKE_RAINBOW_BRIDGE ");
+                result = Search_CanReach(search, regionTable[SHADOW_TEMPLE_BOSS].name, LINK_AGE_ADULT);
+                result = result && Search_CanReach(search, regionTable[SPIRIT_TEMPLE_BOSS].name, LINK_AGE_ADULT);
+            } break;
+            default:
+                result = true;
+        }
+
+        if (!compound) {
+            PRINTF("%s ", result ? "true" : "false");
+        }
+        if (!result && astArr[i+1].tag != AST_OR) { break; }
+    }
+    if (eval && !compound) {
+        PRINTF("\n(%s)\n", result ? "true" : "false");
+    }
+    if (wasInitialIteration) {
+        initialIteration = true;
+        PRINTF("-==-\n");
+    }
+    return result;
+}
+
+bool Ast_Eval_Location(Ast** ptr, Search* search, Location spot, LinkAge age) {
+    const Ast* astArr = *ptr;
+    bool wasInitialIteration = initialIteration2;
+    initialIteration2 = false;
+
+    if (wasInitialIteration) {
+        PRINTF("LOCATION: Evaluating %s access as %s\n", spot.name, age == LINK_AGE_ADULT ? "Adult" : "Child");
+    }
+
+    bool result = true;
+    bool eval = false;
+    bool compound = false;
+    for (size_t i = 0; astArr[i].tag != AST_END; i++) {
+        eval = true;
+        Ast ast = astArr[i];
+        int count = 1;
+
+        switch (ast.tag) {
+            case AST_AND: {
+                compound = true;
+                PRINTF("AND ");
+                i++;
+                if (astArr[i].tag == AST_GROUP_OPEN) {
+                    PRINTF("\nGROUP_OPEN (by AND) ");
+                    result = evaluateGroup_Location(ptr, search, spot, age, &i);
+                } else {
+                    Ast subAst[2] = { astArr[i], AST_END };
+                    Ast* subAstArr[1] = { subAst };
+                    result = Ast_Eval_Location(subAstArr, search, spot, age);
+                }
+            } break;
+            case AST_OR: {
+                compound = true;
+                PRINTF("OR ");
+                i++;
+                if (astArr[i].tag == AST_GROUP_OPEN) {
+                    PRINTF("\nGROUP_OPEN (by OR) ");
+                    bool tempResult = evaluateGroup_Location(ptr, search, spot, age, &i);
+                    result = result || tempResult;
+                } else {
+                    Ast subAst[2] = { astArr[i], AST_END };
+                    Ast* subAstArr[1] = { subAst };
+                    /* Short-circuits */
+                    result = result || Ast_Eval_Location(subAstArr, search, spot, age);
+                }
+            } break;
+            case AST_GROUP_OPEN: {
+                PRINTF("GROUP_OPEN ");
+                result = evaluateGroup_Location(ptr, search, spot, age, &i);
+            } break;
+            case AST_GROUP_CLOSE: {
+                return result;
+                PRINTF("GROUP_CLOSE ");
+            } break;
+            case AST_CAN_REACH: {
+                struct AST_CAN_REACH data = ast.data.AST_CAN_REACH;
+                PRINTF("CAN_REACH %s ", regionTable[data.region].name);
+                result = Search_CanReach(search, regionTable[data.region].name, data.age);
+            } break;
+            case AST_IS_CHILD: {
+                PRINTF("IS_CHILD ");
+                result = age == LINK_AGE_CHILD;
+            } break;
+            case AST_IS_ADULT: {
+                PRINTF("IS_ADULT ");
+                result = isAdult(search, age);
+            } break;
+            case AST_NAME: {
+                struct AST_NAME data = ast.data.AST_NAME;
+                PRINTF("NAME IS %s ", data.name);
+                result = strcmp(data.name, spot.name) == 0;
+            } break;
+            case AST_AT: {
+                struct AST_AT data = ast.data.AST_AT;
+                PRINTF("AT %s ", regionTable[data.region].name);
+                result = Ast_Eval_Location(&data.subRule, search, spot, age);
+            } break;
+            case AST_HAS_COUNT: {
+                struct AST_HAS_COUNT data = ast.data.AST_HAS_COUNT;
+                count = data.count;
+            } FALLTHROUGH;
+            case AST_HAS: {
+                struct AST_HAS data = ast.data.AST_HAS;
+                PRINTF("HAS %s %u ", itemTable[data.item].name, count);
+                result = has(search, data.item, count);
+            } break;
+            case AST_CAN_BLAST_OR_SMASH: {
+                PRINTF("CAN_BLAST_OR_SMASH ");
+                unsigned bombBagSolverId = itemIdToSolverId[ITEM_BOMB_BAG_20];
+                result = search->state->solvItems[bombBagSolverId] || canUse(search, age, ITEM_HAMMER);
+            } break;
+            case AST_CAN_PLAY: {
+                struct AST_CAN_PLAY data = ast.data.AST_CAN_PLAY;
+                PRINTF("CAN_PLAY %d ", data.song);
+                result = canPlay(search, age, data.song);
+            } break;
+            case AST_CAN_TIME_TRAVEL: {
+                PRINTF("CAN_TIME_TRAVEL ");
+                result = has(search, EVENT_DEFEAT_GOHMA, 1);
+                result = result && has(search, EVENT_DEFEAT_KING_DODONGO, 1);
+                result = result && has(search, EVENT_DEFEAT_BARINADE, 1);
+            } break;
+            case AST_CAN_USE: {
+                struct AST_CAN_USE data = ast.data.AST_CAN_USE;
+                PRINTF("CAN_USE %s ", itemTable[data.item].name);
+                result = canUse(search, age, data.item);
+            } break;
+            case AST_CAN_LEAVE_FOREST: {
+                PRINTF("CAN_LEAVE_FOREST ");
+                result = canLeaveForest(search);
+            } break;
+            case AST_CAN_MAKE_RAINBOW_BRIDGE: {
+                PRINTF("CAN_MAKE_RAINBOW_BRIDGE ");
+                result = Search_CanReach(search, regionTable[SHADOW_TEMPLE_BOSS].name, LINK_AGE_ADULT);
+                result = result && Search_CanReach(search, regionTable[SPIRIT_TEMPLE_BOSS].name, LINK_AGE_ADULT);
+            } break;
+            default:
+                result = true;
+        }
+
+        if (!compound) {
+            PRINTF("%s ", result ? "true" : "false");
+        }
+        if (!result && astArr[i+1].tag != AST_OR) { break; }
+    }
+    if (eval && !compound) {
+        PRINTF("\n(%s)\n", result ? "true" : "false");
+    }
+    if (wasInitialIteration) {
+        initialIteration2 = true;
+        PRINTF("-==-\n");
+    }
+    return result;
+}
+
+bool Ast_Eval_Item(Location location, Item item) {
+    bool result = true;
+
+    VECTOR_FOR_EACH(&location.itemRules, rules) {
+        Ast_v container = ITERATOR_GET_AS(Ast_v, &rules);
+        switch (container.data->tag) {
+            case AST_END:
+                return result;
+            case AST_NAME: {
+                struct AST_NAME data = container.data->data.AST_NAME;
+                result = strcmp(data.name, item.name) == 0;
+            } break;
+            case AST_NAME_NOT: {
+                struct AST_NAME data = container.data->data.AST_NAME;
+                result = strcmp(data.name, item.name) != 0;
+            } break;
+            default:
+                result = true;
+        }
+    }
+
+    return result;
+}
+
+void Ast_Free(Ast* ptr) {
+    ZELDA_ARENA_FREE(ptr, __FILE_NAME__, __LINE__);
+}
diff --git a/src/overlays/gamestates/ovl_randomizer/r_ast.h b/src/overlays/gamestates/ovl_randomizer/r_ast.h
new file mode 100644
index 000000000..f22ccd6ee
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_ast.h
@@ -0,0 +1,76 @@
+#ifndef R_AST_H
+#define R_AST_H 1
+#include "r_containers.h"
+#include "r_search.h"
+#include "z64item.h"
+#include "z64save.h"
+
+typedef struct Location Location;
+typedef struct Entrance Entrance;
+typedef struct Ast Ast;
+
+extern bool initialIteration;
+
+struct Ast {
+    enum {
+        AST_END,
+        AST_AND,
+        AST_OR,
+        AST_GROUP_OPEN,
+        AST_GROUP_CLOSE,
+        AST_CAN_REACH,
+        AST_IS_CHILD,
+        AST_IS_ADULT,
+        AST_NAME,       // item rule
+        AST_NAME_NOT,       // item rule
+        AST_AT,
+        AST_HAS_COUNT,
+        AST_HAS,
+        AST_CAN_BLAST_OR_SMASH,
+        AST_CAN_PLAY,
+        AST_CAN_TIME_TRAVEL,
+        AST_CAN_USE,
+        AST_CAN_LEAVE_FOREST,
+        AST_CAN_MAKE_RAINBOW_BRIDGE,
+    } tag;
+    union {
+        struct AST_END { int null; int null2; } AST_END;
+        struct AST_AND { int null; } AST_AND;
+        struct AST_OR { int null; } AST_OR;
+        struct AST_GROUP_OPEN { int null; } AST_GROUP_OPEN;
+        struct AST_GROUP_CLOSE { int null; } AST_GROUP_CLOSE;
+        struct AST_CAN_REACH { RegionEnum region; LinkAge age; } AST_CAN_REACH;
+        struct AST_IS_CHILD { int null; } AST_IS_CHILD;
+        struct AST_IS_ADULT { int null; } AST_IS_ADULT;
+        struct AST_NAME { const char* name; } AST_NAME;
+        struct AST_NAME_NOT { const char* name; } AST_NAME_NOT;
+        struct AST_AT { RegionEnum region; Ast* subRule; } AST_AT;
+        struct AST_HAS_COUNT { ItemID item; unsigned count; } AST_HAS_COUNT;
+        struct AST_HAS { ItemID item; } AST_HAS;
+        struct AST_CAN_BLAST_OR_SMASH { int null; } AST_CAN_BLAST_OR_SMASH;
+        struct AST_CAN_PLAY { ItemID song; } AST_CAN_PLAY;
+        struct AST_CAN_TIME_TRAVEL { int null; } AST_CAN_TIME_TRAVEL;
+        struct AST_CAN_USE { ItemID item; } AST_CAN_USE;
+        struct AST_CAN_LEAVE_FOREST { int null; } AST_CAN_LEAVE_FOREST;
+        struct AST_CAN_MAKE_RAINBOW_BRIDGE { int null; } AST_CAN_MAKE_RAINBOW_BRIDGE;
+    } data;
+};
+
+struct Ast_v {
+    Ast* data;
+};
+
+struct AstVector_v {
+    AstVector* data;
+};
+
+Ast *Ast_Init(Ast ast);
+bool Ast_Eval_Entrance(Ast **ptr, Search* search, Entrance spot, LinkAge age);
+bool Ast_Eval_Location(Ast **ptr, Search* search, Location spot, LinkAge age);
+bool Ast_Eval_Item(Location location, Item item);
+void Ast_Free(Ast *ptr);
+
+#define AST_NEW(tag, ...) \
+Ast_Init((Ast){tag, {.tag=(struct tag){__VA_ARGS__}}})
+
+#endif
diff --git a/src/overlays/gamestates/ovl_randomizer/r_containers.h b/src/overlays/gamestates/ovl_randomizer/r_containers.h
new file mode 100644
index 000000000..9bf33c196
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_containers.h
@@ -0,0 +1,37 @@
+#ifndef R_CONTAINERS_H
+#define R_CONTAINERS_H 1
+
+#include "hashtable.h"
+#include "vector.h"
+
+typedef HashTable IntHashTable;
+typedef HashTable ItemHashTable;
+typedef HashTable ItemInfoHashTable;
+typedef HashTable LocationHashTable;
+typedef HashTable RegionHashTable;
+
+typedef Vector IntVector;
+typedef Vector AstVector;
+typedef Vector EntranceVector;
+typedef Vector ItemVector;
+typedef Vector ItemInfoVector;
+typedef Vector LocationVector;
+typedef Vector RegionVector;
+typedef Vector StringVector;
+
+typedef struct Ast_v Ast_v;
+typedef struct AstVector_v AstVector_v;
+typedef struct Entrance_v Entrance_v;
+typedef struct Item_v Item_v;
+typedef struct ItemInfo_v ItemInfo_v;
+typedef struct Location_v Location_v;
+typedef struct Region_v Region_v;
+typedef struct String_v String_v;
+
+struct String_v {
+    char const* data;
+};
+
+extern char hashKeyBuffer[0x60];
+
+#endif
diff --git a/src/overlays/gamestates/ovl_randomizer/r_entrance.c b/src/overlays/gamestates/ovl_randomizer/r_entrance.c
new file mode 100644
index 000000000..3825474f1
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_entrance.c
@@ -0,0 +1,22 @@
+#include "r_entrance.h"
+
+#include "r_region.h"
+
+#include "zelda_arena.h"
+
+Entrance* Entrance_Init(char const* name) {
+    if (name == NULL) {
+        return NULL;
+    }
+
+    Entrance* entrance = ZELDA_ARENA_MALLOC(sizeof(Entrance), __FILE_NAME__, __LINE__);
+    memset(entrance, 0, sizeof(Entrance));
+
+    entrance->name = name;
+
+    return entrance;
+}
+
+void Entrance_Connect(Entrance* entrance, Region* region) {
+    entrance->connectedRegion = region;
+}
diff --git a/src/overlays/gamestates/ovl_randomizer/r_entrance.h b/src/overlays/gamestates/ovl_randomizer/r_entrance.h
new file mode 100644
index 000000000..d5ee82692
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_entrance.h
@@ -0,0 +1,23 @@
+#ifndef R_ENTRANCE_H
+#define R_ENTRANCE_H 1
+#include "randomizer.h"
+
+#include "r_ast.h"
+#include "r_region.h"
+
+typedef struct Entrance Entrance;
+struct Entrance {
+    char const* name;
+    Region* parentRegion;
+    Region* connectedRegion;
+    Ast* accessRule[MAX_AST_EVENTS];
+};
+
+struct Entrance_v {
+    Entrance* data;
+};
+
+Entrance* Entrance_Init(char const* name);
+void Entrance_Connect(Entrance* entrance, Region* region);
+
+#endif
diff --git a/src/overlays/gamestates/ovl_randomizer/r_fill.c b/src/overlays/gamestates/ovl_randomizer/r_fill.c
new file mode 100644
index 000000000..ec5866233
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_fill.c
@@ -0,0 +1,234 @@
+#include "r_fill.h"
+#include "randomizer.h"
+
+#include "vector.h"
+
+#include "r_ast.h"
+#include "r_item_info.h"
+#include "r_location.h"
+#include "r_search.h"
+
+
+#include "fault.h"
+#include "printf.h"
+#include "randomizer_state.h"
+#include "z64game.h"
+#include "zelda_arena.h"
+#include "libc64/sprintf.h"
+
+void FillDungeonItemsRestrictive(GameState* gameState, World* world, Search* search, LocationVector* fillLocations, ItemVector* dungeonItems, ItemVector* itemPool);
+void FillRestrictive(GameState* gameState, World* world, Search* baseSearch, LocationVector* locations, ItemVector* itemPool, signed count);
+void FastFill(LocationVector* locations, ItemVector* itemPool);
+
+void DistributeItemsRestrictive(GameState* gameState, World* world) {
+    RandomizerState* this = (RandomizerState*)gameState;
+
+    LocationVector fillLocations = fillLocations = World_GetUnfilledLocations(world);
+
+    /* Start a search cache here */
+    Search search = Search_Init(world);
+    Search_CollectProgressionLocations(world, &search);
+
+    ItemVector dungeonItems = World_GetRestrictedDungeonItems(world);
+    FillDungeonItemsRestrictive(&this->state, world, &search, &fillLocations, &dungeonItems, &world->itemPool);
+    VECTOR_FOR_EACH(&dungeonItems, items) {
+        Item_v container = ITERATOR_GET_AS(Item_v, &items);
+        ZELDA_ARENA_FREE(container.data, __FILE_NAME__, __LINE__);
+    }
+    vector_destroy(&dungeonItems);
+
+    if (this->mode == RM_ERROR) { return; }
+
+    Search_CollectProgressionLocations(world, &search);
+
+    ItemVector progItemPool;
+    vector_setup(&progItemPool, VECTOR_MINIMUM_CAPACITY, sizeof(Item_v));
+    VECTOR_FOR_EACH(&world->itemPool, items) {
+        Item_v item = ITERATOR_GET_AS(Item_v, &items);
+        if (item.data->info->advancement == TRUE) {
+            vector_push_back(&progItemPool, &item);
+        }
+    }
+    vector_shuffle(&progItemPool);
+
+    ItemVector restItemPool;
+    vector_setup(&restItemPool, VECTOR_MINIMUM_CAPACITY, sizeof(Item_v));
+    VECTOR_FOR_EACH(&world->itemPool, items) {
+        Item_v item = ITERATOR_GET_AS(Item_v, &items);
+        if (item.data->info->advancement == NONE) {
+            vector_push_back(&restItemPool, &item);
+        }
+    }
+    vector_shuffle(&restItemPool);
+
+    FillRestrictive(&this->state, world, &search, &fillLocations, &progItemPool, -1);
+
+    if (this->mode == RM_ERROR) { return; }
+
+    vector_destroy(&progItemPool);
+    Search_Destroy(&search);
+
+    FastFill(&fillLocations, &restItemPool);
+
+    vector_destroy(&restItemPool);
+    vector_destroy(&fillLocations);
+}
+
+void FillDungeonItemsRestrictive(GameState* gameState, World* world, Search* search, LocationVector* fillLocations, ItemVector* dungeonItems, ItemVector* itemPool) {
+    RandomizerState* this = (RandomizerState*)gameState;
+
+    Search baseSearch = Search_Copy(search);
+    Search_CollectAll(&baseSearch, *itemPool);
+    Search_CollectProgressionLocations(world, &baseSearch);
+
+    Vector bossKeys;
+    vector_setup(&bossKeys, VECTOR_MINIMUM_CAPACITY, dungeonItems->element_size);
+
+    Vector smallKeys;
+    vector_setup(&smallKeys, VECTOR_MINIMUM_CAPACITY, dungeonItems->element_size);
+
+    size_t counter = 0;
+    unsigned eraseIndexes[50] = { };
+
+    VECTOR_FOR_EACH(dungeonItems, items) {
+        Item_v item = ITERATOR_GET_AS(Item_v, &items);
+        if (item.data->info->type == BOSS_KEY) {
+            vector_push_front(&bossKeys, &item);
+            eraseIndexes[counter++] = iterator_index(dungeonItems, &items);
+        } else if (item.data->info->type == SMALL_KEY) {
+            vector_push_front(&smallKeys, &item);
+            eraseIndexes[counter++] = iterator_index(dungeonItems, &items);
+        }
+    }
+
+    for (size_t i = counter; i > 0; i--) {
+        vector_erase(dungeonItems, eraseIndexes[i - 1]);
+    }
+
+    /* Sort small keys before maps/compasses */
+    VECTOR_FOR_EACH(&smallKeys, keys) {
+        Item_v key = ITERATOR_GET_AS(Item_v, &keys);
+        vector_push_front(dungeonItems, &key);
+    }
+
+    /* Sort boss keys before other items */
+    VECTOR_FOR_EACH(&bossKeys, keys) {
+        Item_v key = ITERATOR_GET_AS(Item_v, &keys);
+        vector_push_front(dungeonItems, &key);
+    }
+
+    vector_destroy(&bossKeys);
+    vector_destroy(&smallKeys);
+
+    FillRestrictive(&this->state, world, &baseSearch, fillLocations, dungeonItems, -1);
+
+    Search_Destroy(&baseSearch);
+}
+
+void FillRestrictive(GameState* gameState, World* world, Search* baseSearch, LocationVector* locations, ItemVector* itemPool, signed count) {
+    RandomizerState* this = (RandomizerState*)gameState;
+
+    ItemVector unplacedItems;
+    vector_setup(&unplacedItems, VECTOR_MINIMUM_CAPACITY, sizeof(Item_v));
+
+    Search itemSearch = Search_Copy(baseSearch);
+    Search_CollectAll(&itemSearch, *itemPool);
+
+    while (itemPool->size && locations->size) {
+        if (count == 0) {
+            break;
+        }
+
+        Item_v itemToPlace = *(Item_v*)vector_get(itemPool, 0);
+        vector_pop_front(itemPool);
+
+        vector_shuffle(locations);
+
+        Search_Uncollect(&itemSearch, *itemToPlace.data);
+        Search maxSearch = Search_Copy(&itemSearch);
+        Search_CollectProgressionLocations(world, &maxSearch);
+
+        PRINTF("Trying to place %u %s\n", itemToPlace.data->scene, itemToPlace.data->name);
+        size_t spotToFill = UINT32_MAX;
+        // PRINTF("Trying to place %s for dungeon %d\n", itemToPlace.data->name, itemToPlace.data->scene);
+        VECTOR_FOR_EACH(locations, locs) {
+            Location_v location = ITERATOR_GET_AS(Location_v, &locs);
+            if (Location_CanFill(*location.data, &maxSearch, *itemToPlace.data, true)) {
+                PRINTF("Placed at %s\n", location.data->name);
+                spotToFill = iterator_index(locations, &locs);
+                break;
+            }
+        }
+
+        if (spotToFill == UINT32_MAX) {
+            if (count > 0) {
+                vector_push_back(&unplacedItems, &itemToPlace);
+                Search_Collect(&itemSearch, *itemToPlace.data);
+                continue;
+            }
+#if RANDOMIZER_ERROR_ON_RETRY
+            char msg[0x100];
+            sprintf(msg, "Game unbeatable: Can't place %s", itemToPlace.data->name);
+            PRINTF("Randomizer error! %s\n", msg);
+            Fault_AddHungupAndCrashImpl(" RANDOMIZER ERROR", msg);
+#else
+            this->mode = RM_ERROR;
+            return;
+#endif
+        }
+
+        Search_Destroy(&maxSearch);
+
+        //World_PushItem
+        Location* location = ((Location_v*)vector_get(locations, spotToFill))->data;
+        location->item = *itemToPlace.data;
+        vector_erase(locations, spotToFill);
+        --count;
+
+        ZELDA_ARENA_FREE(itemToPlace.data, __FILE_NAME__, __LINE__);
+    }
+
+    Search_Destroy(&itemSearch);
+
+    if (count > 0) {
+#if RANDOMIZER_ERROR_ON_RETRY
+        char msg[0x100];
+        sprintf(msg, "Number of items not placed: %i", count);
+        PRINTF("Randomizer error! %s\n", msg);
+        Fault_AddHungupAndCrashImpl(" RANDOMIZER ERROR", msg);
+#else
+        this->mode = RM_ERROR;
+        return;
+#endif
+    }
+     if (count < 0 && 0 < itemPool->size) {
+#if RANDOMIZER_ERROR_ON_RETRY
+        char msg[0x100];
+        sprintf(msg, "Items remaining to place %zu", itemPool->size);
+        PRINTF("Randomizer error! %s\n", msg);
+        Fault_AddHungupAndCrashImpl(" RANDOMIZER ERROR", msg);
+#else
+         this->mode = RM_ERROR;
+        return;
+#endif
+    }
+
+    VECTOR_FOR_EACH(&unplacedItems, unplaced) {
+        Item_v item = ITERATOR_GET_AS(Item_v, &unplaced);
+        vector_push_back(itemPool, &item);
+    }
+
+    vector_destroy(&unplacedItems);
+}
+
+void FastFill(LocationVector* locations, ItemVector* itemPool) {
+    vector_shuffle(locations);
+    while (itemPool->size && locations->size) {
+        Location* location = ((Location_v*)vector_front(locations))->data;
+        Item* item = ((Item_v*)vector_front(itemPool))->data;
+        location->item = *item;
+        vector_pop_front(locations);
+        vector_pop_front(itemPool);
+        ZELDA_ARENA_FREE(item, __FILE_NAME__, __LINE__);
+    }
+}
diff --git a/src/overlays/gamestates/ovl_randomizer/r_fill.h b/src/overlays/gamestates/ovl_randomizer/r_fill.h
new file mode 100644
index 000000000..2a2359e16
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_fill.h
@@ -0,0 +1,9 @@
+#ifndef R_FILL_H
+#define R_FILL_H 1
+
+#include "r_world.h"
+#include "z64game.h"
+
+void DistributeItemsRestrictive(GameState* gameState, World* world);
+
+#endif
diff --git a/src/overlays/gamestates/ovl_randomizer/r_graph.c b/src/overlays/gamestates/ovl_randomizer/r_graph.c
new file mode 100644
index 000000000..a1f2fe8d3
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_graph.c
@@ -0,0 +1,187 @@
+#include "alloca.h"
+#include "fault.h"
+#include "gfx.h"
+#include "gfx_setupdl.h"
+#include "printf.h"
+#if DEBUG_FEATURES
+#include "map_select_state.h"
+#endif
+#include "randomizer.h"
+#include "randomizer_state.h"
+#include "seqcmd.h"
+#include "sfx.h"
+#include "stack.h"
+#include "stackcheck.h"
+#include "z64game.h"
+#include "z64play.h"
+#include "z64save.h"
+#include "z64thread.h"
+#include "libu64/gfxprint.h"
+
+OSThread sRandomizerThread;
+STACK(sRandomizerStack, 0x1800);
+StackEntry sRandomizerStackInfo;
+
+int sDelayTimer = 0;
+
+void Randomizer_Finish(GameState *gameState) {
+    RandomizerState* this = (RandomizerState*)gameState;
+
+    sDelayTimer--;
+
+    if (sDelayTimer <= 0) {
+#if DEBUG_FEATURES
+        if (gSaveContext.fileNum == 0) {
+            SET_NEXT_GAMESTATE(&this->state, MapSelect_Init, MapSelectState);
+        } else
+#endif
+        {
+            SET_NEXT_GAMESTATE(&this->state, Play_Init, PlayState);
+        }
+
+        this->state.running = false;
+
+        if (this->threadStarted) {
+            osDestroyThread(&sRandomizerThread);
+        }
+    }
+}
+
+int sCounter = 0;
+
+void Randomizer_Draw(GameState *gameState) {
+    RandomizerState* this = (RandomizerState*)gameState;
+    GraphicsContext* gfxCtx = this->state.gfxCtx;
+
+    sCounter++;
+
+    OPEN_DISPS(gfxCtx, __FILE_NAME__, __LINE__);
+
+    gSPSegment(POLY_OPA_DISP++, 0x00, NULL);
+    Gfx_SetupFrame(gfxCtx, 0, 0, 0);
+    SET_FULLSCREEN_VIEWPORT(&this->view);
+    View_Apply(&this->view, VIEW_ALL);
+    Gfx_SetupDL_28Opa(gfxCtx);
+
+    GfxPrint* printer = alloca(sizeof(GfxPrint));
+    GfxPrint_Init(printer);
+    GfxPrint_Open(printer, POLY_OPA_DISP);
+
+    GfxPrint_SetPos(printer, 12, 15);
+    GfxPrint_SetColor(printer, 255, 255, 255, 255);
+
+    switch ((sCounter / 20) % 3) {
+        case 0:
+            GfxPrint_Printf(printer, "Generating .");
+            break;
+        case 1:
+            GfxPrint_Printf(printer, "Generating . .");
+            break;
+        case 2:
+            GfxPrint_Printf(printer, "Generating . . .");
+            break;
+        default:
+            GfxPrint_Printf(printer, "Generating . . ?");
+    }
+
+    if (sCounter % 40 == 0) {
+        Audio_PlaySfxGeneral(NA_SE_VO_KZ_MOVE, &gSfxDefaultPos, 4, &gSfxDefaultFreqAndVolScale,
+                                 &gSfxDefaultFreqAndVolScale, &gSfxDefaultReverb);
+    }
+
+    POLY_OPA_DISP = GfxPrint_Close(printer);
+    GfxPrint_Destroy(printer);
+
+    CLOSE_DISPS(gfxCtx, __FILE_NAME__, __LINE__);
+}
+
+void Randomizer_DrawError(GameState *gameState) {
+    RandomizerState* this = (RandomizerState*)gameState;
+    GraphicsContext* gfxCtx = this->state.gfxCtx;
+
+    OPEN_DISPS(gfxCtx, __FILE_NAME__, __LINE__);
+
+    gSPSegment(POLY_OPA_DISP++, 0x00, NULL);
+    Gfx_SetupFrame(gfxCtx, 0, 0, 0);
+    SET_FULLSCREEN_VIEWPORT(&this->view);
+    View_Apply(&this->view, VIEW_ALL);
+    Gfx_SetupDL_28Opa(gfxCtx);
+
+    GfxPrint* printer = alloca(sizeof(GfxPrint));
+    GfxPrint_Init(printer);
+    GfxPrint_Open(printer, POLY_OPA_DISP);
+
+    GfxPrint_SetPos(printer, 12, 15);
+    GfxPrint_SetColor(printer, 255, 255, 255, 255);
+    GfxPrint_Printf(printer, "Failed to generate");
+
+    GfxPrint_SetPos(printer, 1, 16);
+    GfxPrint_Printf(printer, "Reset, erase file to generate new seed");
+
+    POLY_OPA_DISP = GfxPrint_Close(printer);
+    GfxPrint_Destroy(printer);
+
+    CLOSE_DISPS(gfxCtx, __FILE_NAME__, __LINE__);
+}
+
+void Randomizer_Main(GameState *gameState) {
+    RandomizerState* this = (RandomizerState*)gameState;
+    // If generation thread fails, graph thread will keep looping which resets the frame buffer. This causes flickering
+    // of the fault display. It may also overwrite the fault display preventing it from ever displaying. To prevent
+    // these, check if there is a global fault message active and lock the graph thread in an infinite loop. The pad and
+    // fault threads will still be running so the debug screen can still be paged through.
+    while (gFaultMsgId != 0) {}
+
+    switch (this->mode) {
+        case RM_FINISHING: {
+            Sram_WriteSave(&this->sramCtx);
+            sDelayTimer = 20;
+            this->mode = RM_FINISHED;
+        } FALLTHROUGH;
+        case RM_FINISHED: {
+            Randomizer_Finish(&this->state);
+        } break;
+        case RM_FINISHED_ERROR:
+            Randomizer_DrawError(&this->state);
+            break;
+        default:
+            Randomizer_Draw(&this->state);
+    }
+}
+
+void Randomizer_Destroy(GameState *gameState) {
+    RandomizerState* this = (RandomizerState*)gameState;
+}
+
+void Randomizer_Init(GameState *gameState) {
+    PRINTF(VT_COL(BLUE, WHITE) "Randomizer overlay loaded" VT_RST "\n");
+    RandomizerState* this = (RandomizerState*)gameState;
+
+    this->state.main = Randomizer_Main;
+    this->state.destroy = Randomizer_Destroy;
+    View_Init(&this->view, this->state.gfxCtx);
+
+    this->threadStarted = false;
+
+    if (gSaveContext.save.randomizer.initialized && !gSaveContext.save.randomizer.shuffleChests) {
+        PRINTF("No randomization selected\n");
+        Randomizer_Finish(&this->state);
+        return;
+    }
+
+    if (gSaveContext.save.randomizer.generated) {
+        PRINTF("Already randomized\n");
+        Randomizer_Finish(&this->state);
+        return;
+    }
+
+    Sram_Alloc(&this->state, &this->sramCtx);
+
+    /* Remove locked door to Boss Key Chest in Fire Temple */
+    gSaveContext.save.info.sceneFlags[SCENE_FIRE_TEMPLE].swch |= (1 << 0x17);
+
+    osCreateThread(&sRandomizerThread, THREAD_ID_RANDOMIZER, Randomizer_ThreadEntry, &this->state, STACK_TOP(sRandomizerStack), THREAD_PRI_MAIN_INIT);
+    osStartThread(&sRandomizerThread);
+    this->threadStarted = true;
+    SEQCMD_RESET_AUDIO_HEAP(0, 10);
+}
\ No newline at end of file
diff --git a/src/overlays/gamestates/ovl_randomizer/r_item.c b/src/overlays/gamestates/ovl_randomizer/r_item.c
new file mode 100644
index 000000000..591e17d08
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_item.c
@@ -0,0 +1,57 @@
+#include "r_item.h"
+
+#include "r_item_info.h"
+
+#include "fault.h"
+#include "printf.h"
+#include "z64item.h"
+#include "zelda_arena.h"
+#include "libc64/sprintf.h"
+
+Item* Item_Init(char const* name, bool event) {
+    Item* item = ZELDA_ARENA_MALLOC(sizeof(Item), __FILE_NAME__, __LINE__);
+    memset(item, 0, sizeof(Item));
+
+    item->name = name;
+    item->scene = SCENE_ID_MAX;
+
+    memset(hashKeyBuffer, 0, sizeof(hashKeyBuffer));
+    strcpy(hashKeyBuffer, name);
+
+    if (event) {
+        if (!ht_contains(&ItemInfo_Events, hashKeyBuffer)) {
+            ItemInfo_v infoContainer = { ItemInfo_Init(ITEM_NONE, true) };
+            ht_insert(&ItemInfo_Events, hashKeyBuffer, &infoContainer);
+        }
+
+        item->info = ((ItemInfo_v*)ht_lookup(&ItemInfo_Events, hashKeyBuffer))->data;
+    } else {
+        item->info = ((ItemInfo_v*)ht_lookup(&ItemInfo_Items, hashKeyBuffer))->data;
+    }
+
+    return item;
+}
+
+ItemVector Item_Factory(StringVector itemNames) {
+    ItemVector ret;
+    vector_setup(&ret, VECTOR_MINIMUM_CAPACITY, sizeof(Item_v));
+
+    VECTOR_FOR_EACH(&itemNames, names) {
+        String_v container = ITERATOR_GET_AS(String_v, &names);
+
+        memset(hashKeyBuffer, 0, sizeof(hashKeyBuffer));
+        strcpy(hashKeyBuffer, container.data);
+
+        if (!ht_contains(&ItemInfo_Items, hashKeyBuffer)) {
+            char msg[0x100];
+            sprintf(msg, "Unknown item: %s", container.data);
+            PRINTF("Randomizer error! %s\n", msg);
+            Fault_AddHungupAndCrashImpl(" RANDOMIZER ERROR", msg);
+        }
+
+        Item_v itemContainer = { Item_Init(container.data, false) };
+        vector_push_back(&ret, &itemContainer);
+    }
+
+    return ret;
+}
diff --git a/src/overlays/gamestates/ovl_randomizer/r_item.h b/src/overlays/gamestates/ovl_randomizer/r_item.h
new file mode 100644
index 000000000..02b425d91
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_item.h
@@ -0,0 +1,23 @@
+#ifndef R_ITEM_H
+#define R_ITEM_H 1
+#include "r_containers.h"
+
+#include "z64scene.h"
+
+typedef struct ItemInfo ItemInfo;
+
+typedef struct Item Item;
+struct Item {
+    char const* name;
+    ItemInfo* info;
+    SceneID scene;
+};
+
+struct Item_v {
+    Item* data;
+};
+
+ItemVector Item_Factory(StringVector itemNames);
+Item* Item_Init(char const* name, bool event);
+
+#endif
diff --git a/src/overlays/gamestates/ovl_randomizer/r_item_info.c b/src/overlays/gamestates/ovl_randomizer/r_item_info.c
new file mode 100644
index 000000000..60441b1bd
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_item_info.c
@@ -0,0 +1,90 @@
+#include "randomizer.h"
+
+#include "r_item_info.h"
+
+#include "array_count.h"
+#include "printf.h"
+#include "r_tables.h"
+#include "zelda_arena.h"
+
+u32 itemIdToSolverId[ITEM_NONE];
+IntHashTable allowedGlobals;
+ItemInfoHashTable ItemInfo_Items;
+ItemInfoHashTable ItemInfo_Events;
+IntHashTable ItemInfo_SolverIds;
+
+ItemInfo* ItemInfo_Init(ItemID item, bool event) {
+    ItemInfo* itemInfo = ZELDA_ARENA_MALLOC(sizeof(ItemInfo), __FILE_NAME__, __LINE__);
+    memset(itemInfo, 0, sizeof(ItemInfo));
+
+    if (event) {
+        itemInfo->type = EVENT_ITEM;
+        itemInfo->index = item;
+    } else {
+        ItemTableRow row = itemTable[item];
+        itemInfo->index = item;
+        itemInfo->giIndex = row.id;
+        itemInfo->name = row.name;
+        itemInfo->type = row.type;
+        itemInfo->advancement = row.advancement;
+        itemInfo->junk = row.junk;
+    }
+
+    if (itemInfo->name != NULL && !itemInfo->junk) {
+        memset(hashKeyBuffer, 0, sizeof(hashKeyBuffer));
+        strcpy(hashKeyBuffer, itemInfo->name);
+
+        if (!ht_contains(&ItemInfo_SolverIds, hashKeyBuffer)) {
+            unsigned length = ItemInfo_SolverIds.size;
+            ht_insert(&ItemInfo_SolverIds, hashKeyBuffer, &length);
+            ht_insert(&allowedGlobals, hashKeyBuffer, &length);
+            itemInfo->solverId = length;
+        }
+    }
+
+    return itemInfo;
+}
+
+void ItemInfo_InitAll() {
+    for (size_t i = 0; i < ARRAY_COUNT(itemIdToSolverId); i++) {
+        itemIdToSolverId[i] = UINT32_MAX;
+    }
+
+    ht_setup(&allowedGlobals, sizeof(hashKeyBuffer), sizeof(unsigned), HT_MINIMUM_CAPACITY);
+    ht_setup(&ItemInfo_SolverIds, sizeof(hashKeyBuffer), sizeof(unsigned), HT_MINIMUM_CAPACITY);
+    ht_setup(&ItemInfo_Items, sizeof(hashKeyBuffer), sizeof(ItemInfo_v), HT_MINIMUM_CAPACITY);
+    ht_setup(&ItemInfo_Events, sizeof(hashKeyBuffer), sizeof(ItemInfo_v), HT_MINIMUM_CAPACITY);
+
+    for (size_t itemIndex = 0; itemIndex < ARRAY_COUNT(itemTable); itemIndex++) {
+        if (itemTable[itemIndex].name == NULL) {
+            continue;
+        }
+
+        ItemInfo* itemInfo = ItemInfo_Init(itemIndex, false);
+        itemIdToSolverId[itemIndex] = itemInfo->solverId;
+
+        memset(hashKeyBuffer, 0, sizeof(hashKeyBuffer));
+        strcpy(hashKeyBuffer, itemInfo->name);
+
+        ItemInfo_v container = { itemInfo };
+        ht_insert(&ItemInfo_Items, hashKeyBuffer, &container);
+    }
+}
+
+void ht_free_itemInfo(void* key, void* value) {
+    if (key == NULL) {
+        return;
+    }
+    ZELDA_ARENA_FREE(((ItemInfo_v*)value)->data, __FILE_NAME__, __LINE__);
+}
+
+void ItemInfo_DestroyAll() {
+    ht_iterate(&allowedGlobals, ht_free);
+    ht_destroy(&allowedGlobals);
+    ht_iterate(&ItemInfo_SolverIds, ht_free);
+    ht_destroy(&ItemInfo_SolverIds);
+    ht_iterate(&ItemInfo_Items, ht_free_itemInfo);
+    ht_destroy(&ItemInfo_Items);
+    ht_iterate(&ItemInfo_Events, ht_free);
+    ht_destroy(&ItemInfo_Events);
+}
\ No newline at end of file
diff --git a/src/overlays/gamestates/ovl_randomizer/r_item_info.h b/src/overlays/gamestates/ovl_randomizer/r_item_info.h
new file mode 100644
index 000000000..eca50f15b
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_item_info.h
@@ -0,0 +1,35 @@
+#ifndef R_ITEM_INFO_H
+#define R_ITEM_INFO_H 1
+#include "randomizer.h"
+
+#include "r_containers.h"
+
+#include "z64item.h"
+#include "ultra64/ultratypes.h"
+
+extern u32 itemIdToSolverId[ITEM_NONE];
+extern IntHashTable allowedGlobals;
+extern IntHashTable ItemInfo_SolverIds;
+extern ItemInfoHashTable ItemInfo_Items;
+extern ItemInfoHashTable ItemInfo_Events;
+
+typedef struct ItemInfo ItemInfo;
+struct ItemInfo {
+    char const* name;
+    TriState advancement;
+    ItemType type;
+    ItemID index;
+    GetItemID giIndex;
+    bool junk;
+    unsigned solverId;
+};
+
+struct ItemInfo_v {
+    ItemInfo* data;
+};
+
+ItemInfo* ItemInfo_Init(ItemID item, bool event);
+void ItemInfo_InitAll();
+void ItemInfo_DestroyAll();
+
+#endif
\ No newline at end of file
diff --git a/src/overlays/gamestates/ovl_randomizer/r_location.c b/src/overlays/gamestates/ovl_randomizer/r_location.c
new file mode 100644
index 000000000..4f4b4faef
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_location.c
@@ -0,0 +1,51 @@
+#include "r_location.h"
+
+#include "r_tables.h"
+#include "zelda_arena.h"
+
+Location* Location_Init(char const* name, LocationType const type, SceneID const scene, unsigned const flag, ItemID vanillaItem) {
+    Location* location = ZELDA_ARENA_MALLOC(sizeof(Location), __FILE_NAME__, __LINE__);
+    memset(location, 0, sizeof(Location));
+
+    Location const temp = {
+        .name = name,
+        .type = type,
+        .scene = scene,
+        .flag = flag,
+        .vanillaItem = vanillaItem,
+    };
+    *location = temp;
+
+    return location;
+}
+
+Location* Location_Factory(const size_t locationTableIndex) {
+    if (locationTable[locationTableIndex].name == NULL) {
+        return NULL;
+    }
+    Location* location = Location_Init(
+        locationTable[locationTableIndex].name,
+        locationTable[locationTableIndex].type,
+        locationTable[locationTableIndex].scene,
+        locationTable[locationTableIndex].flag,
+        locationTable[locationTableIndex].vanillaItem
+    );
+
+    return location;
+}
+
+bool CanFillFast(Location location, Item item) {
+    if (location.parentRegion == NULL) {
+        return false;
+    }
+
+    bool result = Region_CanFill(*location.parentRegion, item);
+    if (location.itemRules.size) {
+        result = result && Ast_Eval_Item(location, item);
+    }
+    return result;
+}
+
+bool Location_CanFill(Location location, Search* search, Item item, bool checkAccess) {
+    return CanFillFast(location, item) && (!checkAccess || Search_LocationAccess(search, location, LINK_AGE_EITHER));
+}
diff --git a/src/overlays/gamestates/ovl_randomizer/r_location.h b/src/overlays/gamestates/ovl_randomizer/r_location.h
new file mode 100644
index 000000000..95fd913a6
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_location.h
@@ -0,0 +1,30 @@
+#ifndef R_LOCATION_H
+#define R_LOCATION_H 1
+#include "randomizer.h"
+
+#include "r_containers.h"
+#include "r_item.h"
+#include "r_search.h"
+#include "r_ast.h"
+
+typedef struct Location Location;
+struct Location {
+    char const* name;
+    Region* parentRegion;
+    LocationType type;
+    SceneID scene;
+    unsigned flag;
+    ItemID vanillaItem;
+    Ast* accessRule[MAX_AST_EVENTS];
+    AstVector itemRules;
+    Item item;
+};
+
+struct Location_v {
+    Location* data;
+};
+
+Location *Location_Factory(size_t locationTableIndex);
+bool Location_CanFill(Location location, Search* search, Item item, bool checkAccess);
+
+#endif
diff --git a/src/overlays/gamestates/ovl_randomizer/r_region.c b/src/overlays/gamestates/ovl_randomizer/r_region.c
new file mode 100644
index 000000000..81bc6380a
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_region.c
@@ -0,0 +1,107 @@
+#include "r_region.h"
+
+#include "r_item.h"
+#include "r_item_info.h"
+#include "r_tables.h"
+
+#include "array_count.h"
+#include "r_entrance.h"
+#include "r_location.h"
+#include "zelda_arena.h"
+
+Region* Region_Init(RegionEnum regionTableIndex) {
+    if (regionTable[regionTableIndex].name == NULL) {
+        return NULL;
+    }
+
+    Region* region = ZELDA_ARENA_MALLOC(sizeof(Region), __FILE_NAME__, __LINE__);
+    memset(region, 0, sizeof(Region));
+
+    region->name = regionTable[regionTableIndex].name;
+    region->dungeon = regionTable[regionTableIndex].dungeon;
+
+    vector_setup(&region->locations, VECTOR_MINIMUM_CAPACITY, sizeof(Location_v));
+    for (size_t locationTableIndex = 0; locationTableIndex < ARRAY_COUNT(locationTable); locationTableIndex++) {
+        if (locationTable[locationTableIndex].regionKey != regionTableIndex) {
+            continue;
+        }
+        Location* location = Location_Factory(locationTableIndex);
+        if (location == NULL) {
+            continue;
+        }
+
+        location->parentRegion = region;
+        for (size_t ruleIndex = 0; ruleIndex < ARRAY_COUNT(locationTable[locationTableIndex].accessRule); ruleIndex++) {
+            location->accessRule[ruleIndex] = &locationTable[locationTableIndex].accessRule[ruleIndex];
+            if (location->accessRule[ruleIndex]->tag == AST_END) {
+                break;
+            }
+        }
+
+        Location_v container = { location };
+        vector_push_back(&region->locations, &container);
+    }
+
+    vector_setup(&region->exits, VECTOR_MINIMUM_CAPACITY, sizeof(Entrance_v));
+    for (size_t exitTableIndex = 0; exitTableIndex < ARRAY_COUNT(exitTable); exitTableIndex++) {
+        if (exitTable[exitTableIndex].regionKey != regionTableIndex) {
+            continue;
+        }
+        Entrance* exit = Entrance_Init(exitTable[exitTableIndex].name);
+        if (exit == NULL) {
+            continue;
+        }
+
+        exit->parentRegion = region;
+        for (size_t ruleIndex = 0; ruleIndex < ARRAY_COUNT(exitTable[exitTableIndex].accessRule); ruleIndex++) {
+            exit->accessRule[ruleIndex] = &exitTable[exitTableIndex].accessRule[ruleIndex];
+            if (exit->accessRule[ruleIndex]->tag == AST_END) {
+                break;
+            }
+        }
+
+        Entrance_v container = { exit };
+        vector_push_back(&region->exits, &container);
+    }
+
+    return region;
+}
+
+bool Region_CanFill(Region region, Item item) {
+    bool isSelfDungeonRestricted = false;
+
+    if (item.info->type >= BOSS_KEY && item.info->type <= SMALL_KEY) {
+        isSelfDungeonRestricted = true;
+    }
+
+    if (isSelfDungeonRestricted) {
+        return region.dungeon == item.scene;
+    }
+
+    return true;
+}
+
+void Region_Destroy(Region* region) {
+    if (region == NULL) { return; }
+
+    VECTOR_FOR_EACH(&region->locations, locations) {
+        Location_v locationContainer = ITERATOR_GET_AS(Location_v, &locations);
+        if (locationContainer.data == NULL) {
+            continue;
+        }
+        VECTOR_FOR_EACH(&locationContainer.data->itemRules, rules) {
+            Ast_v astContainer = ITERATOR_GET_AS(Ast_v, &rules);
+            ZELDA_ARENA_FREE(astContainer.data, __FILE_NAME__, __LINE__);
+        }
+        ZELDA_ARENA_FREE(locationContainer.data, __FILE_NAME__, __LINE__);
+    }
+    vector_destroy(&region->locations);
+
+    VECTOR_FOR_EACH(&region->exits, exits) {
+        Entrance_v exitContainer = ITERATOR_GET_AS(Entrance_v, &exits);
+        ZELDA_ARENA_FREE(exitContainer.data, __FILE_NAME__, __LINE__);
+    }
+    vector_destroy(&region->exits);
+
+    ZELDA_ARENA_FREE(region, __FILE_NAME__, __LINE__);
+}
diff --git a/src/overlays/gamestates/ovl_randomizer/r_region.h b/src/overlays/gamestates/ovl_randomizer/r_region.h
new file mode 100644
index 000000000..aa4a415e5
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_region.h
@@ -0,0 +1,25 @@
+#ifndef R_REGION_H
+#define R_REGION_H 1
+
+#include "randomizer.h"
+#include "r_containers.h"
+#include "r_item.h"
+
+typedef struct Region Region;
+struct Region {
+    char const* name;
+    EntranceVector entrances;
+    EntranceVector exits;
+    LocationVector locations;
+    SceneID dungeon;
+};
+
+struct Region_v {
+    Region* data;
+};
+
+Region* Region_Init(RegionEnum regionTableIndex);
+void Region_Destroy(Region* region);
+bool Region_CanFill(Region region, Item item);
+
+#endif
diff --git a/src/overlays/gamestates/ovl_randomizer/r_search.c b/src/overlays/gamestates/ovl_randomizer/r_search.c
new file mode 100644
index 000000000..3042b21f6
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_search.c
@@ -0,0 +1,267 @@
+#include "r_search.h"
+
+#include "hashtable.h"
+#include "printf.h"
+#include "r_containers.h"
+#include "r_entrance.h"
+#include "r_item_info.h"
+#include "r_location.h"
+#include "r_region.h"
+#include "r_state.h"
+#include "r_world.h"
+#include "string.h"
+#include "vector.h"
+#include "z64save.h"
+#include "zelda_arena.h"
+
+void NextSphere(Search* search);
+void ExpandRegions(Search* search, EntranceVector* failed, LinkAge age);
+
+void Search_InitWithoutIteration(Search* search) {
+    vector_setup(&search->childQueue, VECTOR_MINIMUM_CAPACITY, sizeof(Entrance_v));
+    vector_setup(&search->adultQueue, VECTOR_MINIMUM_CAPACITY, sizeof(Entrance_v));
+
+    ht_setup(&search->childRegions, sizeof(hashKeyBuffer), sizeof(Region_v), HT_MINIMUM_CAPACITY);
+    ht_setup(&search->adultRegions, sizeof(hashKeyBuffer), sizeof(Region_v), HT_MINIMUM_CAPACITY);
+}
+
+Search Search_Init(World* world) {
+    Search search = { };
+    search.state = State_Init();
+
+    Search_InitWithoutIteration(&search);
+
+    Region* rootRegion = World_GetRegion(world, "Root");
+
+    VECTOR_FOR_EACH(&rootRegion->exits, exits) {
+        Entrance_v exit = ITERATOR_GET_AS(Entrance_v, &exits);
+        vector_push_back(&search.childQueue, &exit);
+        vector_push_back(&search.adultQueue, &exit);
+    }
+
+    Region_v container = { rootRegion };
+    memset(hashKeyBuffer, 0, sizeof(hashKeyBuffer));
+    strcpy(hashKeyBuffer, rootRegion->name);
+
+    ht_insert(&search.childRegions, hashKeyBuffer, &container);
+    ht_insert(&search.adultRegions, hashKeyBuffer, &container);
+
+    NextSphere(&search);
+
+    return search;
+}
+
+void Search_Destroy(Search* search) {
+    ht_iterate(&search->adultRegions, ht_free);
+    ht_destroy(&search->adultRegions);
+    ht_iterate(&search->childRegions, ht_free);
+    ht_destroy(&search->childRegions);
+    if (ht_is_initialized(&search->visitedLocations) && !ht_is_empty(&search->visitedLocations)) {
+        ht_iterate(&search->visitedLocations, ht_free);
+        ht_destroy(&search->visitedLocations);
+    }
+    vector_destroy(&search->adultQueue);
+    vector_destroy(&search->childQueue);
+
+    ZELDA_ARENA_FREE(search->state, __FILE_NAME__, __LINE__);
+}
+
+Search Search_Copy(Search* search) {
+    Search newSearch = { };
+    newSearch.state = State_Init();
+    memcpy(newSearch.state->solvItems, search->state->solvItems, 0xff * sizeof(int));
+
+    vector_copy(&newSearch.childQueue, &search->childQueue);
+    vector_copy(&newSearch.adultQueue, &search->adultQueue);
+    if (ht_is_initialized(&search->visitedLocations) && !ht_is_empty(&search->visitedLocations)) {
+        ht_copy(&newSearch.visitedLocations, &search->visitedLocations);
+    }
+    ht_copy(&newSearch.childRegions, &search->childRegions);
+    ht_copy(&newSearch.adultRegions, &search->adultRegions);
+
+    NextSphere(&newSearch);
+
+    return newSearch;
+}
+
+void NextSphere(Search* search) {
+    EntranceVector temp;
+    vector_setup(&temp, search->adultQueue.size, sizeof(Entrance_v));
+
+    ExpandRegions(search, &temp, LINK_AGE_ADULT);
+    vector_swap(&search->adultQueue, &temp);
+
+    vector_clear(&temp);
+
+    ExpandRegions(search, &temp, LINK_AGE_CHILD);
+    vector_swap(&search->childQueue, &temp);
+
+    vector_destroy(&temp);
+}
+
+void ExpandRegions(Search* search, EntranceVector* failed, LinkAge age) {
+    EntranceVector* exitQueue;
+    RegionHashTable* regions;
+
+    if (age == LINK_AGE_ADULT) {
+        exitQueue = &search->adultQueue;
+        regions = &search->adultRegions;
+    } else {
+        exitQueue = &search->childQueue;
+        regions = &search->childRegions;
+    }
+
+    /* Can't change exitQueue while iterating on it */
+    EntranceVector currentExits;
+    currentExits.data = NULL;
+    vector_copy(&currentExits, exitQueue);
+    EntranceVector newExits;
+    vector_setup(&newExits, VECTOR_MINIMUM_CAPACITY, sizeof(Entrance_v));
+    do {
+        PRINTF("REGIONS EXPANDING\n");
+        /* Clear out new exits added to currentExits from the previous iteration */
+        vector_clear(&newExits);
+
+        VECTOR_FOR_EACH(&currentExits, queued) {
+            Entrance_v queuedContainer = ITERATOR_GET_AS(Entrance_v, &queued);
+            Entrance exit = *queuedContainer.data;
+            // PRINTF("Searching queued exit: %s\n", exit.name);
+
+            if (age == LINK_AGE_ADULT && exit.accessRule[0][0].tag == AST_IS_CHILD) {
+                continue;
+            }
+            if (age == LINK_AGE_CHILD && exit.accessRule[0][0].tag == AST_IS_ADULT) {
+                continue;
+            }
+
+            memset(hashKeyBuffer, 0, sizeof(hashKeyBuffer));
+            strcpy(hashKeyBuffer, exit.connectedRegion->name);
+
+            if (exit.connectedRegion != NULL && !ht_contains(regions, hashKeyBuffer)) {
+                // PRINTF("Region %s is new!\n", hashKeyBuffer);
+                if (Ast_Eval_Entrance(exit.accessRule, search, exit, age)) {
+                    Region_v regionContainer = { exit.connectedRegion };
+                    memset(hashKeyBuffer, 0, sizeof(hashKeyBuffer));
+                    strcpy(hashKeyBuffer, exit.connectedRegion->name);
+                    ht_insert(regions, hashKeyBuffer, &regionContainer);
+                    VECTOR_FOR_EACH(&exit.connectedRegion->exits, exits) {
+                        Entrance_v exitContainer = ITERATOR_GET_AS(Entrance_v, &exits);
+                        // PRINTF("Queuing exit %s\n", exitContainer.data->name);
+                        vector_push_back(&newExits, &exitContainer);
+                    }
+                } else {
+                    // PRINTF("Cannot access exit!\n");
+                    vector_push_back(failed, &queuedContainer);
+                }
+            }
+        }
+
+        vector_clear(&currentExits);
+
+        VECTOR_FOR_EACH(&newExits, itr) {
+            Entrance_v container = ITERATOR_GET_AS(Entrance_v, &itr);
+            vector_push_back(&currentExits, &container);
+        }
+
+    } while (newExits.size);
+    vector_destroy(&newExits);
+    vector_destroy(&currentExits);
+}
+
+void Search_CollectAll(Search* search, ItemVector itemPool) {
+    VECTOR_FOR_EACH(&itemPool, items) {
+        Item_v item = ITERATOR_GET_AS(Item_v, &items);
+        State_Collect(search->state, *item.data);
+    }
+}
+
+void Search_Collect(Search* search, Item item) {
+    State_Collect(search->state, item);
+}
+
+void Search_Uncollect(Search* search, Item item) {
+    State_Remove(search->state, item);
+}
+
+bool Search_CanReach(Search* search, char const* regionName, LinkAge age) {
+    memset(hashKeyBuffer, 0, sizeof(hashKeyBuffer));
+    strcpy(hashKeyBuffer, regionName);
+
+    if (age == LINK_AGE_ADULT) {
+        return ht_contains(&search->adultRegions, hashKeyBuffer);
+    }
+    if (age == LINK_AGE_CHILD) {
+        return ht_contains(&search->childRegions, hashKeyBuffer);
+    }
+    if (age == LINK_AGE_BOTH) {
+        return ht_contains(&search->adultRegions, hashKeyBuffer)
+            && ht_contains(&search->childRegions, hashKeyBuffer);
+    }
+    return ht_contains(&search->adultRegions, hashKeyBuffer)
+        || ht_contains(&search->childRegions, hashKeyBuffer);
+}
+
+bool Search_LocationAccess(Search* search, Location location, LinkAge age) {
+    if (age == LINK_AGE_ADULT || age == LINK_AGE_CHILD) {
+        return Search_CanReach(search, location.parentRegion->name, age) && Ast_Eval_Location(location.accessRule, search, location, age);
+    }
+    if (age == LINK_AGE_BOTH) {
+        return (Search_CanReach(search, location.parentRegion->name, age) && Ast_Eval_Location(location.accessRule, search, location, LINK_AGE_ADULT))
+               && (Ast_Eval_Location(location.accessRule, search, location, LINK_AGE_CHILD));
+    }
+    return (Search_CanReach(search, location.parentRegion->name, LINK_AGE_ADULT) && Ast_Eval_Location(location.accessRule, search, location, LINK_AGE_ADULT))
+           || (Search_CanReach(search, location.parentRegion->name, LINK_AGE_CHILD) && Ast_Eval_Location(location.accessRule, search, location, LINK_AGE_CHILD));
+}
+
+void CollectReachableLocations(Search* search, LocationVector itemLocations) {
+    bool hadReachableLocations = true;
+
+    if (!ht_is_initialized(&search->visitedLocations)) {
+        ht_setup(&search->visitedLocations, sizeof(hashKeyBuffer), sizeof(Location_v), HT_MINIMUM_CAPACITY);
+    }
+
+    while (hadReachableLocations) {
+        NextSphere(search);
+        hadReachableLocations = false;
+
+        VECTOR_FOR_EACH(&itemLocations, locs) {
+            Location_v loc = ITERATOR_GET_AS(Location_v, &locs);
+            memset(hashKeyBuffer, 0, sizeof(hashKeyBuffer));
+            strcpy(hashKeyBuffer, loc.data->name);
+            if (ht_contains(&search->visitedLocations, hashKeyBuffer)) {
+                continue;
+            }
+
+            memset(hashKeyBuffer, 0, sizeof(hashKeyBuffer));
+            strcpy(hashKeyBuffer, loc.data->parentRegion->name);
+            if (ht_contains(&search->adultRegions, hashKeyBuffer) && Ast_Eval_Location(loc.data->accessRule, search, *loc.data, LINK_AGE_ADULT)) {
+                hadReachableLocations = true;
+                memset(hashKeyBuffer, 0, sizeof(hashKeyBuffer));
+                strcpy(hashKeyBuffer, loc.data->name);
+                ht_insert(&search->visitedLocations, hashKeyBuffer, &loc);
+                Search_Collect(search, loc.data->item);
+            } else if (ht_contains(&search->childRegions, hashKeyBuffer) && Ast_Eval_Location(loc.data->accessRule, search, *loc.data, LINK_AGE_CHILD)) {
+                hadReachableLocations = true;
+                memset(hashKeyBuffer, 0, sizeof(hashKeyBuffer));
+                strcpy(hashKeyBuffer, loc.data->name);
+                ht_insert(&search->visitedLocations, hashKeyBuffer, &loc);
+                Search_Collect(search, loc.data->item);
+            }
+        }
+    }
+}
+
+void Search_CollectProgressionLocations(World* world, Search* search) {
+    LocationVector itemLocations;
+    vector_setup(&itemLocations, VECTOR_MINIMUM_CAPACITY, sizeof(Location_v));
+
+    LocationVector allLocations = World_GetLocations(world);
+    VECTOR_FOR_EACH(&allLocations, locs) {
+        Location_v loc = ITERATOR_GET_AS(Location_v, &locs);
+        if (loc.data->item.info != NULL && loc.data->item.info->advancement == TRUE) {
+            vector_push_back(&itemLocations, &loc);
+        }
+    }
+    CollectReachableLocations(search, itemLocations);
+    vector_destroy(&itemLocations);
+}
diff --git a/src/overlays/gamestates/ovl_randomizer/r_search.h b/src/overlays/gamestates/ovl_randomizer/r_search.h
new file mode 100644
index 000000000..0c0519ee5
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_search.h
@@ -0,0 +1,34 @@
+#ifndef R_SEARCH_H
+#define R_SEARCH_H 1
+
+#include "r_region.h"
+#include "r_state.h"
+#include "r_world.h"
+
+#include "z64save.h"
+
+typedef struct World World;
+typedef struct Region Region;
+typedef struct Location Location;
+
+typedef struct Search Search;
+struct Search {
+    EntranceVector childQueue;
+    EntranceVector adultQueue;
+    LocationHashTable visitedLocations;
+    RegionHashTable childRegions;
+    RegionHashTable adultRegions;
+    State* state;
+};
+
+Search Search_Init(World* world);
+void Search_Destroy(Search* search);
+Search Search_Copy(Search* search);
+void Search_Collect(Search* search, Item item);
+void Search_CollectAll(Search* search, ItemVector itemPool);
+void Search_CollectProgressionLocations(World* world, Search* search);
+void Search_Uncollect(Search* search, Item item);
+bool Search_CanReach(Search* search, char const* regionName, LinkAge age);
+bool Search_LocationAccess(Search* search, Location location, LinkAge age);
+
+#endif
diff --git a/src/overlays/gamestates/ovl_randomizer/r_state.c b/src/overlays/gamestates/ovl_randomizer/r_state.c
new file mode 100644
index 000000000..c3d393f02
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_state.c
@@ -0,0 +1,28 @@
+#include "r_state.h"
+
+#include "fault.h"
+#include "hashtable.h"
+#include "r_ast.h"
+#include "r_item_info.h"
+#include "zelda_arena.h"
+
+State* State_Init() {
+    State* state = ZELDA_ARENA_MALLOC(sizeof(State), __FILE_NAME__, __LINE__);
+    memset(state, 0, sizeof(State));
+
+    for (size_t i = 0; i < ItemInfo_SolverIds.size; i++) {
+        state->solvItems[i] = 0;
+    }
+
+    return state;
+}
+
+void State_Collect(State* state, Item item) {
+    state->solvItems[item.info->solverId] += 1;
+}
+
+void State_Remove(State* state, Item item) {
+    if (state->solvItems[item.info->solverId] > 0) {
+        state->solvItems[item.info->solverId] -= 1;
+    }
+}
diff --git a/src/overlays/gamestates/ovl_randomizer/r_state.h b/src/overlays/gamestates/ovl_randomizer/r_state.h
new file mode 100644
index 000000000..a8a6f8af8
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_state.h
@@ -0,0 +1,14 @@
+#ifndef R_STATE_H
+#define R_STATE_H 1
+#include "r_item.h"
+
+typedef struct State State;
+struct State {
+    int solvItems[0xff];
+};
+
+State* State_Init();
+void State_Collect(State* state, Item item);
+void State_Remove(State* state, Item item);
+
+#endif
diff --git a/src/overlays/gamestates/ovl_randomizer/r_tables.c b/src/overlays/gamestates/ovl_randomizer/r_tables.c
new file mode 100644
index 000000000..60ac13db2
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_tables.c
@@ -0,0 +1,712 @@
+#include "randomizer.h"
+#include "randomizer_state.h"
+
+#include "r_ast.h"
+#include "r_tables.h"
+
+#include "array_count.h"
+#include "z64item.h"
+
+LocationTableRow locationTable[] = {
+    { KOKIRI_FOREST, "KF Mido's Top Left Chest",                                 CHEST_LOCATION,          SCENE_MIDOS_HOUSE,                  0x00, ITEM_RUPEE_BLUE, {
+        { AST_END }
+    }},
+    { KOKIRI_FOREST, "KF Mido's Top Right Chest",                                CHEST_LOCATION,          SCENE_MIDOS_HOUSE,                  0x01, ITEM_RUPEE_BLUE, {
+        { AST_END }
+    }},
+    { KOKIRI_FOREST, "KF Mido's Bottom Left Chest",                              CHEST_LOCATION,          SCENE_MIDOS_HOUSE,                  0x02, ITEM_RUPEE_GREEN, {
+        { AST_END }
+    }},
+    { KOKIRI_FOREST, "KF Mido's Bottom Right Chest",                             CHEST_LOCATION,          SCENE_MIDOS_HOUSE,                  0x03, ITEM_RECOVERY_HEART, {
+        { AST_END }
+    }},
+    { KOKIRI_FOREST, "KF Kokiri Sword Chest",                                    CHEST_LOCATION,          SCENE_KOKIRI_FOREST,                0x00, ITEM_SWORD_KOKIRI, {
+        { AST_IS_CHILD }, { AST_END }
+    }},
+    { CASTLE_TOWN, "Market Treasure Chest Game Reward",                        CHEST_LOCATION,          SCENE_TREASURE_BOX_SHOP,            0x0A, ITEM_HEART_PIECE_2, {
+        { AST_IS_CHILD }, { AST_AND }, { AST_CAN_USE, ITEM_LENS_OF_TRUTH }, { AST_END }
+    }},
+    { GRAVEYARD, "Graveyard Shield Grave Chest",                             CHEST_LOCATION,          SCENE_GRAVE_WITH_FAIRYS_FOUNTAIN,   0x00, ITEM_SHIELD_HYLIAN, {
+        { AST_END }
+    }},
+    { GRAVEYARD, "Graveyard Heart Piece Grave Chest",                        CHEST_LOCATION,          SCENE_REDEAD_GRAVE,                 0x00, ITEM_HEART_PIECE, {
+        { AST_CAN_PLAY, ITEM_SONG_LULLABY }, { AST_END }
+    }},
+    { GRAVEYARD, "Graveyard Royal Family's Tomb Chest",                      CHEST_LOCATION,          SCENE_ROYAL_FAMILYS_TOMB,           0x00, ITEM_BOMBS_5, {
+        { AST_CAN_PLAY, ITEM_SONG_LULLABY }, { AST_END }
+    }},
+    { GRAVEYARD, "Graveyard Damp Race Hookshot Chest",                      CHEST_LOCATION,          SCENE_WINDMILL_AND_DAMPES_GRAVE,    0x00, ITEM_HOOKSHOT, {
+        { AST_IS_ADULT }, { AST_END }
+    }},
+    { DEATH_MOUNTAIN, "DMT Chest",                                                CHEST_LOCATION,          SCENE_DEATH_MOUNTAIN_TRAIL,         0x01, ITEM_RUPEE_PURPLE, {
+        { AST_CAN_BLAST_OR_SMASH }, { AST_END }
+    }},
+    { GORON_CITY, "GC Maze Left Chest",                                       CHEST_LOCATION,          SCENE_GORON_CITY,                   0x00, ITEM_RUPEE_GOLD, {
+        { AST_CAN_USE, ITEM_HAMMER }, { AST_OR }, { AST_CAN_USE, ITEM_STRENGTH_SILVER_GAUNTLETS }, { AST_END }
+    }},
+    { GORON_CITY, "GC Maze Right Chest",                                      CHEST_LOCATION,          SCENE_GORON_CITY,                   0x01, ITEM_RUPEE_PURPLE, {
+        { AST_CAN_BLAST_OR_SMASH }, { AST_END }
+    }},
+    { GORON_CITY, "GC Maze Center Chest",                                     CHEST_LOCATION,          SCENE_GORON_CITY,                   0x02, ITEM_RUPEE_PURPLE, {
+        { AST_CAN_BLAST_OR_SMASH }, { AST_END }
+    }},
+    { ZORAS_DOMAIN, "ZD Chest",                                                 CHEST_LOCATION,          SCENE_ZORAS_DOMAIN,                 0x00, ITEM_HEART_PIECE, {
+        { AST_IS_CHILD }, { AST_END }
+    }},
+    { GERUDO_VALLEY_FAR_SIDE, "GV Chest",                                                 CHEST_LOCATION,          SCENE_GERUDO_VALLEY,                0x00, ITEM_RUPEE_PURPLE, {
+        { AST_HAS, ITEM_HAMMER }, { AST_END }
+    }},
+    { GERUDO_FORTRESS, "GF Chest",                                                 CHEST_LOCATION,          SCENE_GERUDOS_FORTRESS,             0x00, ITEM_HEART_PIECE, {
+        { AST_HAS, ITEM_HOOKSHOT }, { AST_END }
+    }},
+    { HAUNTED_WASTELAND, "Wasteland Chest",                                          CHEST_LOCATION,          SCENE_HAUNTED_WASTELAND,            0x00, ITEM_RUPEE_PURPLE, {
+        { AST_CAN_REACH, DEATH_MOUNTAIN_CRATER_UPPER, LINK_AGE_EITHER }, { AST_END }
+    }},
+    { HYRULE_FIELD, "HF Near Market Grotto Chest",                              CHEST_LOCATION,          SCENE_GROTTOS,                      0x00, ITEM_RUPEE_BLUE, {
+        { AST_CAN_BLAST_OR_SMASH }, { AST_END }
+    }},
+    { HYRULE_FIELD, "HF Southeast Grotto Chest",                                CHEST_LOCATION,          SCENE_GROTTOS,                      0x02, ITEM_RUPEE_RED, {
+        { AST_CAN_BLAST_OR_SMASH }, { AST_END }
+    }},
+    { HYRULE_FIELD, "HF Open Grotto Chest",                                     CHEST_LOCATION,          SCENE_GROTTOS,                      0x03, ITEM_RUPEE_BLUE, {
+        { AST_END }
+    }},
+    { KAKARIKO_VILLAGE, "Kak Open Grotto Chest",                                    CHEST_LOCATION,          SCENE_GROTTOS,                      0x08, ITEM_RUPEE_RED, {
+        { AST_END }
+    }},
+    { ZORA_RIVER, "ZR Open Grotto Chest",                                     CHEST_LOCATION,          SCENE_GROTTOS,                      0x09, ITEM_RUPEE_RED, {
+        { AST_END }
+    }},
+    { KAKARIKO_VILLAGE, "Kak Redead Grotto Chest",                                  CHEST_LOCATION,          SCENE_GROTTOS,                      0x0A, ITEM_RUPEE_GOLD, {
+        { AST_CAN_BLAST_OR_SMASH }, { AST_END }
+    }},
+    { KOKIRI_FOREST, "KF Storms Grotto Chest",                                   CHEST_LOCATION,          SCENE_GROTTOS,                      0x0C, ITEM_RUPEE_RED, {
+        { AST_CAN_PLAY, ITEM_SONG_STORMS }, { AST_END }
+    }},
+    { SACRED_FOREST_MEADOW_ENTRY, "SFM Wolfos Grotto Chest",                                  CHEST_LOCATION,          SCENE_GROTTOS,                      0x11, ITEM_RUPEE_PURPLE, {
+        { AST_CAN_BLAST_OR_SMASH }, { AST_END }
+    }},
+    { LOST_WOODS, "LW Near Shortcuts Grotto Chest",                           CHEST_LOCATION,          SCENE_GROTTOS,                      0x14, ITEM_RUPEE_BLUE, {
+        { AST_CAN_BLAST_OR_SMASH }, { AST_END }
+    }},
+    { DEATH_MOUNTAIN, "DMT Storms Grotto Chest",                                  CHEST_LOCATION,          SCENE_GROTTOS,                      0x17, ITEM_RUPEE_GOLD, {
+        { AST_CAN_PLAY, ITEM_SONG_STORMS }, { AST_END }
+    }},
+    { DEATH_MOUNTAIN_CRATER_UPPER, "DMC Upper Grotto Chest",                                   CHEST_LOCATION,          SCENE_GROTTOS,                      0x1A, ITEM_BOMBS_20, {
+        { AST_CAN_BLAST_OR_SMASH }, { AST_END }
+    }},
+    { DEKU_TREE_LOBBY, "Deku Tree Map Chest",                                      CHEST_LOCATION,          SCENE_DEKU_TREE,                0x03, ITEM_DUNGEON_MAP, {
+        { AST_END }
+    }},
+    { DEKU_TREE_LOBBY, "Deku Tree Slingshot Room Side Chest",                      CHEST_LOCATION,          SCENE_DEKU_TREE, 0x05, ITEM_RECOVERY_HEART, {
+        { AST_END }
+    }},
+    { DEKU_TREE_LOBBY, "Deku Tree Slingshot Chest",                                CHEST_LOCATION,          SCENE_DEKU_TREE, 0x01, ITEM_SLINGSHOT, {
+        { AST_END }
+    }},
+    { DEKU_TREE_LOBBY, "Deku Tree Compass Chest",                                  CHEST_LOCATION,          SCENE_DEKU_TREE, 0x02, ITEM_DUNGEON_COMPASS, {
+        { AST_END }
+    }},
+    { DEKU_TREE_LOBBY, "Deku Tree Compass Room Side Chest",                        CHEST_LOCATION,          SCENE_DEKU_TREE, 0x06, ITEM_RECOVERY_HEART, {
+        { AST_END }
+    }},
+    { DEKU_TREE_LOBBY, "Deku Tree Basement Chest",                                 CHEST_LOCATION,          SCENE_DEKU_TREE, 0x04, ITEM_RECOVERY_HEART, {
+        { AST_END }
+    }},
+    { DEKU_TREE_BOSS, "Defeat Gohma", EVENT_LOCATION, SCENE_DEKU_TREE_BOSS, 0, EVENT_DEFEAT_GOHMA, {
+        { AST_END }
+    }},
+    { DODONGOS_CAVERN_LOBBY, "Dodongo's Cavern Map Chest",                               CHEST_LOCATION,          SCENE_DODONGOS_CAVERN,0x08, ITEM_DUNGEON_MAP, {
+        { AST_END }
+    }},
+    { DODONGOS_CAVERN_LOBBY, "Dodongo's Cavern Compass Chest",                           CHEST_LOCATION,          SCENE_DODONGOS_CAVERN,0x05, ITEM_DUNGEON_COMPASS, {
+        { AST_END }
+    }},
+    { DODONGOS_CAVERN_LOBBY, "Dodongo's Cavern Bomb Flower Platform Chest",              CHEST_LOCATION,          SCENE_DODONGOS_CAVERN, 0x06, ITEM_RUPEE_RED, {
+        { AST_END }
+    }},
+    { DODONGOS_CAVERN_LOBBY, "Dodongo's Cavern Bomb Bag Chest",                          CHEST_LOCATION,          SCENE_DODONGOS_CAVERN, 0x04, ITEM_BOMB_BAG_20, {
+        { AST_CAN_BLAST_OR_SMASH }, { AST_AND }, { AST_HAS, ITEM_SLINGSHOT }, { AST_END }
+    }},
+    { DODONGOS_CAVERN_LOBBY, "Dodongo's Cavern End of Bridge Chest",                     CHEST_LOCATION,          SCENE_DODONGOS_CAVERN,0x0A,  ITEM_SHIELD_DEKU, {
+        { AST_CAN_BLAST_OR_SMASH }, { AST_AND }, { AST_HAS, ITEM_SLINGSHOT }, { AST_END }
+    }},
+    { DODONGOS_CAVERN_LOBBY, "Dodongo's Cavern Boss Room Chest",                         CHEST_LOCATION,          SCENE_DODONGOS_CAVERN_BOSS, 0x00, ITEM_BOMBS_5, {
+        { AST_CAN_BLAST_OR_SMASH }, { AST_AND }, { AST_HAS, ITEM_SLINGSHOT }, { AST_END }
+    }},
+    { DODONGOS_CAVERN_BOSS, "Defeat King Dodongo", EVENT_LOCATION, SCENE_DODONGOS_CAVERN_BOSS, 0, EVENT_DEFEAT_KING_DODONGO, {
+        { AST_END }
+    }},
+    { JABU_JABUS_BELLY_LOBBY, "Jabu Jabu's Belly Boomerang Chest",                        CHEST_LOCATION,          SCENE_JABU_JABU, 0x01, ITEM_BOOMERANG, {
+        { AST_END }
+    }},
+    { JABU_JABUS_BELLY_LOBBY, "Jabu Jabu's Belly Map Chest",                              CHEST_LOCATION,          SCENE_JABU_JABU, 0x02, ITEM_DUNGEON_MAP, {
+        { AST_HAS, ITEM_BOOMERANG }, { AST_END }
+    }},
+    { JABU_JABUS_BELLY_LOBBY, "Jabu Jabu's Belly Compass Chest",                          CHEST_LOCATION,          SCENE_JABU_JABU, 0x04, ITEM_DUNGEON_COMPASS, {
+        { AST_HAS, ITEM_BOOMERANG }, { AST_END }
+    }},
+    { JABU_JABUS_BELLY_BOSS, "Defeat Barinade", EVENT_LOCATION, SCENE_JABU_JABU_BOSS, 0, EVENT_DEFEAT_BARINADE, {
+        { AST_END }
+    }},
+    { BOTTOM_OF_THE_WELL_LOBBY, "Bottom of the Well Front Left Fake Wall Chest",            CHEST_LOCATION,          SCENE_BOTTOM_OF_THE_WELL, 0x08, ITEM_SMALL_KEY_BOTTOM_OF_THE_WELL, {
+        { AST_CAN_USE, ITEM_LENS_OF_TRUTH }, { AST_END }
+    }},
+    { BOTTOM_OF_THE_WELL_LOBBY, "Bottom of the Well Front Center Bombable Chest",           CHEST_LOCATION,          SCENE_BOTTOM_OF_THE_WELL, 0x02, ITEM_BOMBCHU, {
+        { AST_HAS, ITEM_BOMB_BAG_20 }, { AST_END }
+    }},
+    { BOTTOM_OF_THE_WELL_LOBBY, "Bottom of the Well Back Left Bombable Chest",              CHEST_LOCATION,          SCENE_BOTTOM_OF_THE_WELL, 0x04, ITEM_DEKU_NUTS_10, {
+        { AST_CAN_USE, ITEM_LENS_OF_TRUTH }, { AST_AND }, { AST_HAS, ITEM_BOMB_BAG_20 }, { AST_END }
+    }},
+    { BOTTOM_OF_THE_WELL_LOBBY, "Bottom of the Well Underwater Left Chest",                 CHEST_LOCATION,          SCENE_BOTTOM_OF_THE_WELL, 0x09, ITEM_RECOVERY_HEART, {
+        { AST_END }
+    }},
+    { BOTTOM_OF_THE_WELL_LOBBY, "Bottom of the Well Compass Chest",                         CHEST_LOCATION,          SCENE_BOTTOM_OF_THE_WELL, 0x01, ITEM_DUNGEON_COMPASS, {
+        { AST_CAN_USE, ITEM_LENS_OF_TRUTH }, { AST_END }
+    }},
+    { BOTTOM_OF_THE_WELL_LOBBY, "Bottom of the Well Center Skulltula Chest",                CHEST_LOCATION,          SCENE_BOTTOM_OF_THE_WELL, 0x0E, ITEM_DEKU_NUTS_5, {
+        { AST_CAN_USE, ITEM_LENS_OF_TRUTH }, { AST_END }
+    }},
+    { BOTTOM_OF_THE_WELL_LOBBY, "Bottom of the Well Right Bottom Fake Wall Chest",          CHEST_LOCATION,          SCENE_BOTTOM_OF_THE_WELL, 0x05, ITEM_SMALL_KEY_BOTTOM_OF_THE_WELL, {
+        { AST_CAN_USE, ITEM_LENS_OF_TRUTH }, { AST_END }
+    }},
+    { BOTTOM_OF_THE_WELL_LOBBY, "Bottom of the Well Fire Keese Chest",                      CHEST_LOCATION,          SCENE_BOTTOM_OF_THE_WELL, 0x0A, ITEM_SHIELD_DEKU, {
+        { AST_HAS_COUNT, ITEM_SMALL_KEY_BOTTOM_OF_THE_WELL, 2 }, { AST_END }
+    }},
+    { BOTTOM_OF_THE_WELL_LOBBY, "Bottom of the Well Like-Like Chest",                       CHEST_LOCATION,          SCENE_BOTTOM_OF_THE_WELL, 0x0C, ITEM_SHIELD_HYLIAN, {
+        { AST_HAS_COUNT, ITEM_SMALL_KEY_BOTTOM_OF_THE_WELL, 2 }, { AST_END }
+    }},
+    { BOTTOM_OF_THE_WELL_LOBBY, "Bottom of the Well Map Chest",                             CHEST_LOCATION,          SCENE_BOTTOM_OF_THE_WELL, 0x07, ITEM_DUNGEON_MAP, {
+        { AST_HAS, ITEM_BOMB_BAG_20 }, { AST_OR }, { AST_CAN_REACH, DEATH_MOUNTAIN_CRATER_UPPER, LINK_AGE_EITHER }, { AST_END }
+    }},
+    { BOTTOM_OF_THE_WELL_LOBBY, "Bottom of the Well Underwater Front Chest",                CHEST_LOCATION,          SCENE_BOTTOM_OF_THE_WELL, 0x10, ITEM_BOMBS_10, {
+        { AST_END }
+    }},
+    { BOTTOM_OF_THE_WELL_LOBBY, "Bottom of the Well Invisible Chest",                       CHEST_LOCATION,          SCENE_BOTTOM_OF_THE_WELL, 0x14, ITEM_RUPEE_GOLD, {
+        { AST_CAN_USE, ITEM_LENS_OF_TRUTH }, { AST_AND }, { AST_HAS, ITEM_SWORD_KOKIRI },  { AST_END }
+    }},
+    { BOTTOM_OF_THE_WELL_LOBBY, "Bottom of the Well Lens of Truth Chest",                   CHEST_LOCATION,          SCENE_BOTTOM_OF_THE_WELL, 0x03, ITEM_LENS_OF_TRUTH, {
+        { AST_HAS, ITEM_SWORD_KOKIRI },  { AST_END }
+    }},
+    { FOREST_TEMPLE_LOBBY, "Forest Temple First Room Chest",                           CHEST_LOCATION,          SCENE_FOREST_TEMPLE, 0x03, ITEM_SMALL_KEY_FOREST_TEMPLE, {
+        { AST_END }
+    }},
+    { FOREST_TEMPLE_LOBBY, "Forest Temple First Stalfos Chest",                        CHEST_LOCATION,          SCENE_FOREST_TEMPLE, 0x00, ITEM_SMALL_KEY_FOREST_TEMPLE, {
+        { AST_END }
+    }},
+    { FOREST_TEMPLE_LOBBY, "Forest Temple Raised Island Courtyard Chest",              CHEST_LOCATION,          SCENE_FOREST_TEMPLE, 0x05, ITEM_RECOVERY_HEART, {
+        { AST_CAN_USE, ITEM_BOW }, {AST_OR}, {AST_HAS_COUNT, ITEM_SMALL_KEY_FOREST_TEMPLE, 5}, { AST_GROUP_CLOSE }, { AST_END }
+    }},
+    { FOREST_TEMPLE_LOBBY, "Forest Temple Map Chest",                                  CHEST_LOCATION,          SCENE_FOREST_TEMPLE, 0x01, ITEM_DUNGEON_MAP, {
+        { AST_END }
+    }},
+    { FOREST_TEMPLE_LOBBY, "Forest Temple Well Chest",                                 CHEST_LOCATION,          SCENE_FOREST_TEMPLE, 0x09, ITEM_SMALL_KEY_FOREST_TEMPLE, {
+        { AST_END }
+    }},
+    { FOREST_TEMPLE_BLOCK_PUSH_ROOM, "Forest Temple Eye Switch Chest",                           CHEST_LOCATION,          SCENE_FOREST_TEMPLE, 0x04, ITEM_ARROWS_30, {
+        { AST_CAN_USE, ITEM_BOW }, { AST_END }
+    }},
+    { FOREST_TEMPLE_STRAIGHT_HALL, "Forest Temple Boss Key Chest",                             CHEST_LOCATION,          SCENE_FOREST_TEMPLE, 0x0E, ITEM_DUNGEON_BOSS_KEY_FOREST_TEMPLE, {
+        { AST_END }
+    }},
+    { FOREST_TEMPLE_OUTSIDE_UPPER, "Forest Temple Floormaster Chest",                          CHEST_LOCATION,          SCENE_FOREST_TEMPLE, 0x02, ITEM_SMALL_KEY_FOREST_TEMPLE, {
+        { AST_END }
+    }},
+    { FOREST_TEMPLE_BOW_REGION, "Forest Temple Red Poe Chest",                              CHEST_LOCATION,          SCENE_FOREST_TEMPLE, 0x0D, ITEM_SMALL_KEY_FOREST_TEMPLE, {
+        { AST_CAN_USE, ITEM_BOW }, { AST_END }
+    }},
+    { FOREST_TEMPLE_BOW_REGION, "Forest Temple Bow Chest",                                  CHEST_LOCATION,          SCENE_FOREST_TEMPLE, 0x0C, ITEM_BOW, {
+        { AST_END }
+    }},
+    { FOREST_TEMPLE_BOW_REGION, "Forest Temple Blue Poe Chest",                             CHEST_LOCATION,          SCENE_FOREST_TEMPLE, 0x0F, ITEM_DUNGEON_COMPASS, {
+        { AST_CAN_USE, ITEM_BOW }, { AST_END }
+    }},
+    { FOREST_TEMPLE_FROZEN_EYE, "Forest Temple Falling Ceiling Room Chest",                 CHEST_LOCATION,          SCENE_FOREST_TEMPLE, 0x07, ITEM_ARROWS_10, {
+        { AST_END }
+    }},
+    { FOREST_TEMPLE_FROZEN_EYE, "Forest Temple Basement Chest",                             CHEST_LOCATION,          SCENE_FOREST_TEMPLE, 0x0B, ITEM_ARROWS_5, {
+        { AST_END }
+    }},
+    { FOREST_TEMPLE_BOSS, "Defeat Phantom Ganon", EVENT_LOCATION, SCENE_FOREST_TEMPLE_BOSS, 0, EVENT_DEFEAT_PHANTOM_GANON, {
+        { AST_END }
+    }},
+    { FIRE_TEMPLE_LOBBY, "Fire Temple Near Boss Chest",                              CHEST_LOCATION,          SCENE_FIRE_TEMPLE, 0x01, ITEM_SMALL_KEY_FIRE_TEMPLE, {
+        { AST_END }
+    }},
+    { FIRE_TEMPLE_LOBBY, "Fire Temple Flare Dancer Chest",                           CHEST_LOCATION,          SCENE_FIRE_TEMPLE, 0x00, ITEM_BOMBS_10, {
+        { AST_HAS, ITEM_HAMMER }, { AST_END }
+    }},
+    { FIRE_TEMPLE_LOBBY, "Fire Temple Boss Key Chest",                               CHEST_LOCATION,          SCENE_FIRE_TEMPLE, 0x0C, ITEM_DUNGEON_BOSS_KEY_FIRE_TEMPLE, {
+        { AST_HAS, ITEM_HAMMER }, { AST_END }
+    }},
+    { FIRE_TEMPLE_BIG_LAVA_ROOM, "Fire Temple Big Lava Room Lower Open Door Chest",          CHEST_LOCATION,          SCENE_FIRE_TEMPLE, 0x04, ITEM_SMALL_KEY_FIRE_TEMPLE, {
+        { AST_END }
+    }},
+    { FIRE_TEMPLE_BIG_LAVA_ROOM, "Fire Temple Big Lava Room Blocked Door Chest",             CHEST_LOCATION,          SCENE_FIRE_TEMPLE, 0x02, ITEM_SMALL_KEY_FIRE_TEMPLE, {
+        { AST_END }
+    }},
+    { FIRE_TEMPLE_MAZE_LOWER, "Fire Temple Boulder Maze Lower Chest",                     CHEST_LOCATION,          SCENE_FIRE_TEMPLE, 0x03, ITEM_SMALL_KEY_FIRE_TEMPLE, {
+        { AST_END }
+    }},
+    { FIRE_TEMPLE_MAZE_LOWER, "Fire Temple Boulder Maze Side Room Chest",                 CHEST_LOCATION,          SCENE_FIRE_TEMPLE, 0x08, ITEM_SMALL_KEY_FIRE_TEMPLE, {
+        { AST_END }
+    }},
+    { FIRE_TEMPLE_NARROW_PATH, "Fire Temple Map Chest",                                    CHEST_LOCATION,          SCENE_FIRE_TEMPLE, 0x0A, ITEM_DUNGEON_MAP, {
+        { AST_HAS, ITEM_BOW }, { AST_OR }, { AST_HAS_COUNT, ITEM_SMALL_KEY_FIRE_TEMPLE, 6 }, { AST_END }
+    }},
+    { FIRE_TEMPLE_MAZE_UPPER, "Fire Temple Boulder Maze Shortcut Chest",                  CHEST_LOCATION,          SCENE_FIRE_TEMPLE, 0x0B, ITEM_SMALL_KEY_FIRE_TEMPLE, {
+        { AST_END }
+    }},
+    { FIRE_TEMPLE_MAZE_UPPER, "Fire Temple Boulder Maze Upper Chest",                     CHEST_LOCATION,          SCENE_FIRE_TEMPLE, 0x06, ITEM_SMALL_KEY_FIRE_TEMPLE, {
+    { AST_END }
+    }},
+    { FIRE_TEMPLE_MAZE_UPPER, "Fire Temple Scarecrow Chest",                              CHEST_LOCATION,          SCENE_FIRE_TEMPLE, 0x0D, ITEM_RUPEE_GOLD, {
+        { AST_HAS, ITEM_HOOKSHOT }, { AST_END }
+    }},
+    { FIRE_TEMPLE_FLAME_MAZE, "Fire Temple Compass Chest",                                CHEST_LOCATION,          SCENE_FIRE_TEMPLE, 0x07, ITEM_DUNGEON_COMPASS, {
+        { AST_END }
+    }},
+    { FIRE_TEMPLE_UPPER, "Fire Temple Megaton Hammer Chest",                         CHEST_LOCATION,          SCENE_FIRE_TEMPLE, 0x05, ITEM_HAMMER, {
+        { AST_END }
+    }},
+    { FIRE_TEMPLE_UPPER, "Fire Temple Highest Goron Chest",                          CHEST_LOCATION,          SCENE_FIRE_TEMPLE, 0x09, ITEM_SMALL_KEY_FIRE_TEMPLE, {
+        { AST_HAS, ITEM_HAMMER }, { AST_END }
+    }},
+    { FIRE_TEMPLE_BOSS, "Defeat Volvagia", EVENT_LOCATION, SCENE_FIRE_TEMPLE_BOSS, 0, EVENT_DEFEAT_VOLVAGIA, {
+        { AST_END }
+    }},
+    { WATER_TEMPLE_LOBBY, "Water Temple Compass Chest",                               CHEST_LOCATION,          SCENE_WATER_TEMPLE, 0x09, ITEM_DUNGEON_COMPASS, {
+        { AST_END }
+    }},
+    { WATER_TEMPLE_LOBBY, "Water Temple Map Chest",                                   CHEST_LOCATION,          SCENE_WATER_TEMPLE, 0x02, ITEM_DUNGEON_MAP, {
+        { AST_HAS, ITEM_HOOKSHOT }, { AST_OR }, { AST_HAS, ITEM_BOOTS_HOVER }, { AST_OR }, { AST_HAS, ITEM_BOW }, { AST_END }
+    }},
+    { WATER_TEMPLE_LOBBY, "Water Temple Cracked Wall Chest",                          CHEST_LOCATION,          SCENE_WATER_TEMPLE, 0x00, ITEM_SMALL_KEY_WATER_TEMPLE, {
+        { AST_HAS, ITEM_HOOKSHOT }, { AST_OR }, { AST_HAS, ITEM_BOOTS_HOVER }, { AST_OR }, { AST_HAS, ITEM_BOW }, { AST_END }
+    }},
+    { WATER_TEMPLE_LOBBY, "Water Temple Torches Chest",                               CHEST_LOCATION,          SCENE_WATER_TEMPLE, 0x01, ITEM_SMALL_KEY_WATER_TEMPLE, {
+        { AST_END }
+    }},
+    { WATER_TEMPLE_LOBBY, "Water Temple Boss Key Chest",                              CHEST_LOCATION,          SCENE_WATER_TEMPLE, 0x05, ITEM_DUNGEON_BOSS_KEY_WATER_TEMPLE, {
+        { AST_HAS_COUNT, ITEM_SMALL_KEY_WATER_TEMPLE, 6 }, { AST_END }
+    }},
+    { WATER_TEMPLE_LOBBY, "Water Temple Central Pillar Chest",                        CHEST_LOCATION,          SCENE_WATER_TEMPLE, 0x06, ITEM_SMALL_KEY_WATER_TEMPLE, {
+        { AST_END }
+    }},
+    { WATER_TEMPLE_LOBBY, "Water Temple Central Bow Target Chest",                    CHEST_LOCATION,          SCENE_WATER_TEMPLE, 0x08, ITEM_SMALL_KEY_WATER_TEMPLE, {
+        { AST_HAS, ITEM_BOW }, { AST_END }
+    }},
+    { WATER_TEMPLE_LOBBY, "Water Temple Longshot Chest",                              CHEST_LOCATION,          SCENE_WATER_TEMPLE, 0x07, ITEM_LONGSHOT, {
+        { AST_HAS, ITEM_HOOKSHOT }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_WATER_TEMPLE, 6 }, { AST_END }
+    }},
+    { WATER_TEMPLE_LOBBY, "Water Temple River Chest",                                 CHEST_LOCATION,          SCENE_WATER_TEMPLE, 0x03, ITEM_SMALL_KEY_WATER_TEMPLE, {
+        { AST_HAS, ITEM_BOW }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_WATER_TEMPLE, 6 }, { AST_END }
+    }},
+    { WATER_TEMPLE_BOSS, "Defeat Morpha", EVENT_LOCATION, SCENE_WATER_TEMPLE_BOSS, 0, EVENT_DEFEAT_MORPHA, {
+        { AST_END }
+    }},
+    { WATER_TEMPLE_LOBBY, "Water Temple Dragon Chest",                                CHEST_LOCATION,          SCENE_WATER_TEMPLE, 0x0A, ITEM_SMALL_KEY_WATER_TEMPLE, {
+        { AST_END }
+    }},
+    { SHADOW_TEMPLE_LOBBY, "Shadow Temple Map Chest",                                  CHEST_LOCATION,          SCENE_SHADOW_TEMPLE, 0x01, ITEM_DUNGEON_MAP, {
+        { AST_END }
+    }},
+    { SHADOW_TEMPLE_LOBBY, "Shadow Temple Hover Boots Chest",                          CHEST_LOCATION,          SCENE_SHADOW_TEMPLE, 0x07, ITEM_BOOTS_HOVER, {
+        { AST_END }
+    }},
+    { SHADOW_TEMPLE_LOBBY, "Shadow Temple Compass Chest",                              CHEST_LOCATION,          SCENE_SHADOW_TEMPLE, 0x03, ITEM_DUNGEON_COMPASS, {
+        { AST_HAS, ITEM_BOOTS_HOVER }, { AST_END }
+    }},
+    { SHADOW_TEMPLE_LOBBY, "Shadow Temple Early Silver Rupee Chest",                   CHEST_LOCATION,          SCENE_SHADOW_TEMPLE, 0x02, ITEM_SMALL_KEY_SHADOW_TEMPLE, {
+        { AST_HAS, ITEM_BOOTS_HOVER }, { AST_END }
+    }},
+    { SHADOW_TEMPLE_LOBBY, "Shadow Temple Invisible Blades Visible Chest",             CHEST_LOCATION,          SCENE_SHADOW_TEMPLE, 0x0C, ITEM_RUPEE_BLUE, {
+        { AST_HAS, ITEM_BOOTS_HOVER }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SHADOW_TEMPLE, 1 }, { AST_END }
+    }},
+    { SHADOW_TEMPLE_LOBBY, "Shadow Temple Invisible Blades Invisible Chest",           CHEST_LOCATION,          SCENE_SHADOW_TEMPLE, 0x16, ITEM_ARROWS_30, {
+        { AST_HAS, ITEM_BOOTS_HOVER }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SHADOW_TEMPLE, 1 }, { AST_END }
+    }},
+    { SHADOW_TEMPLE_LOBBY, "Shadow Temple Falling Spikes Lower Chest",                 CHEST_LOCATION,          SCENE_SHADOW_TEMPLE, 0x05, ITEM_ARROWS_10, {
+        { AST_HAS, ITEM_BOOTS_HOVER }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SHADOW_TEMPLE, 1 },  { AST_END }
+    }},
+    { SHADOW_TEMPLE_LOBBY, "Shadow Temple Falling Spikes Upper Chest",                 CHEST_LOCATION,          SCENE_SHADOW_TEMPLE, 0x06, ITEM_RUPEE_BLUE, {
+        { AST_HAS, ITEM_BOOTS_HOVER }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SHADOW_TEMPLE, 1 }, { AST_END }
+    }},
+    { SHADOW_TEMPLE_LOBBY, "Shadow Temple Falling Spikes Switch Chest",                CHEST_LOCATION,          SCENE_SHADOW_TEMPLE, 0x04, ITEM_SMALL_KEY_SHADOW_TEMPLE, {
+        { AST_HAS, ITEM_BOOTS_HOVER }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SHADOW_TEMPLE, 1 }, { AST_END }
+    }},
+    { SHADOW_TEMPLE_LOBBY, "Shadow Temple Invisible Spikes Chest",                     CHEST_LOCATION,          SCENE_SHADOW_TEMPLE, 0x09, ITEM_RUPEE_BLUE, {
+        { AST_HAS, ITEM_BOOTS_HOVER }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SHADOW_TEMPLE, 2 }, { AST_AND }, { AST_CAN_USE, ITEM_LENS_OF_TRUTH }, { AST_END }
+    }},
+    { SHADOW_TEMPLE_LOBBY, "Shadow Temple Wind Hint Chest",                            CHEST_LOCATION,          SCENE_SHADOW_TEMPLE, 0x15, ITEM_ARROWS_10, {
+        { AST_HAS, ITEM_BOOTS_HOVER }, { AST_AND }, { AST_HAS, ITEM_HOOKSHOT }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SHADOW_TEMPLE, 3 }, { AST_END }
+    }},
+    { SHADOW_TEMPLE_LOBBY, "Shadow Temple After Wind Enemy Chest",                     CHEST_LOCATION,          SCENE_SHADOW_TEMPLE, 0x08, ITEM_RUPEE_BLUE, {
+        { AST_HAS, ITEM_BOOTS_HOVER }, { AST_AND }, { AST_HAS, ITEM_HOOKSHOT }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SHADOW_TEMPLE, 3 }, { AST_END }
+    }},
+    { SHADOW_TEMPLE_LOBBY, "Shadow Temple After Wind Hidden Chest",                    CHEST_LOCATION,          SCENE_SHADOW_TEMPLE, 0x14, ITEM_SMALL_KEY_SHADOW_TEMPLE, {
+        { AST_HAS, ITEM_BOOTS_HOVER }, { AST_AND }, { AST_HAS, ITEM_HOOKSHOT }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SHADOW_TEMPLE, 3 }, { AST_END }
+    }},
+    { SHADOW_TEMPLE_LOBBY, "Shadow Temple Spike Walls Left Chest",                     CHEST_LOCATION,          SCENE_SHADOW_TEMPLE, 0x0A, ITEM_RUPEE_BLUE, {
+        { AST_HAS, ITEM_BOOTS_HOVER }, { AST_AND }, { AST_HAS, ITEM_HOOKSHOT }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SHADOW_TEMPLE, 3 }, { AST_END }
+    }},
+    { SHADOW_TEMPLE_LOBBY, "Shadow Temple Boss Key Chest",                             CHEST_LOCATION,          SCENE_SHADOW_TEMPLE, 0x0B, ITEM_DUNGEON_BOSS_KEY_SHADOW_TEMPLE, {
+        { AST_HAS, ITEM_BOOTS_HOVER }, { AST_AND }, { AST_HAS, ITEM_HOOKSHOT }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SHADOW_TEMPLE, 3 }, { AST_END }
+    }},
+    { SHADOW_TEMPLE_LOBBY, "Shadow Temple Invisible Floormaster Chest",                CHEST_LOCATION,          SCENE_SHADOW_TEMPLE, 0x0D, ITEM_SMALL_KEY_SHADOW_TEMPLE, {
+        { AST_HAS, ITEM_BOOTS_HOVER }, { AST_AND }, { AST_HAS, ITEM_HOOKSHOT }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SHADOW_TEMPLE, 3 }, { AST_END }
+    }},
+    { SHADOW_TEMPLE_BOSS, "Defeat Bongo-Bongo", EVENT_LOCATION, SCENE_SHADOW_TEMPLE_BOSS, 0, EVENT_DEFEAT_BONGO_BONGO, {
+        { AST_END }
+    }},
+    { SPIRIT_TEMPLE_LOBBY, "Spirit Temple Child Bridge Chest",                         CHEST_LOCATION,          SCENE_SPIRIT_TEMPLE, 0x08, ITEM_SHIELD_DEKU, {
+        { AST_IS_CHILD }, { AST_END }
+    }},
+    { SPIRIT_TEMPLE_LOBBY, "Spirit Temple Child Early Torches Chest",                  CHEST_LOCATION,          SCENE_SPIRIT_TEMPLE, 0x00, ITEM_SMALL_KEY_SPIRIT_TEMPLE, {
+        { AST_IS_CHILD }, { AST_END }
+    }},
+    { SPIRIT_TEMPLE_LOBBY, "Spirit Temple Child Climb North Chest",                    CHEST_LOCATION,          SCENE_SPIRIT_TEMPLE, 0x06, ITEM_BOMBCHU, {
+        { AST_GROUP_OPEN },
+        { AST_IS_CHILD }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SPIRIT_TEMPLE, 5},
+        { AST_GROUP_CLOSE }, { AST_OR },
+        { AST_GROUP_OPEN },
+        { AST_IS_ADULT }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SPIRIT_TEMPLE, 3 },
+        { AST_GROUP_CLOSE },
+        { AST_END }
+    }},
+    { SPIRIT_TEMPLE_LOBBY, "Spirit Temple Child Climb East Chest",                     CHEST_LOCATION,          SCENE_SPIRIT_TEMPLE, 0x0C, ITEM_SHIELD_DEKU, {
+        { AST_GROUP_OPEN },
+        { AST_IS_CHILD }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SPIRIT_TEMPLE, 5},
+        { AST_GROUP_CLOSE }, { AST_OR },
+        { AST_GROUP_OPEN },
+        { AST_IS_ADULT }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SPIRIT_TEMPLE, 3 },
+        { AST_GROUP_CLOSE },
+        { AST_END }
+    }},
+    { SPIRIT_TEMPLE_LOBBY, "Spirit Temple Map Chest",                                  CHEST_LOCATION,          SCENE_SPIRIT_TEMPLE, 0x03, ITEM_DUNGEON_MAP, {
+        { AST_GROUP_OPEN },
+        { AST_IS_CHILD }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SPIRIT_TEMPLE, 5},
+        { AST_GROUP_CLOSE }, { AST_OR },
+        { AST_GROUP_OPEN },
+        { AST_IS_ADULT }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SPIRIT_TEMPLE, 3 },
+        { AST_GROUP_CLOSE },
+        { AST_END }
+    }},
+    { SPIRIT_TEMPLE_LOBBY, "Spirit Temple Sun Block Room Chest",                       CHEST_LOCATION,          SCENE_SPIRIT_TEMPLE, 0x01, ITEM_SMALL_KEY_SPIRIT_TEMPLE, {
+        { AST_GROUP_OPEN },
+        { AST_IS_CHILD }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SPIRIT_TEMPLE, 5},
+        { AST_GROUP_CLOSE }, { AST_OR },
+        { AST_GROUP_OPEN },
+        { AST_IS_ADULT }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SPIRIT_TEMPLE, 3 },
+        { AST_GROUP_CLOSE },
+        { AST_END }
+    }},
+    { SPIRIT_TEMPLE_HANDS, "Spirit Temple Silver Gauntlets Chest",                     CHEST_LOCATION,          SCENE_DESERT_COLOSSUS, 0x0B, ITEM_STRENGTH_SILVER_GAUNTLETS, {
+        { AST_END }
+    }},
+    { SPIRIT_TEMPLE_LOBBY, "Spirit Temple Compass Chest",                              CHEST_LOCATION,          SCENE_SPIRIT_TEMPLE, 0x04, ITEM_DUNGEON_COMPASS,   {
+        { AST_HAS, ITEM_STRENGTH_SILVER_GAUNTLETS }, { AST_AND }, { AST_HAS, ITEM_HOOKSHOT}, { AST_END }
+    }},
+    { SPIRIT_TEMPLE_LOBBY, "Spirit Temple Early Adult Right Chest",                    CHEST_LOCATION,          SCENE_SPIRIT_TEMPLE, 0x07, ITEM_SMALL_KEY_SPIRIT_TEMPLE, {
+        { AST_HAS, ITEM_STRENGTH_SILVER_GAUNTLETS }, { AST_AND }, { AST_HAS, ITEM_HOOKSHOT}, { AST_END }
+    }},
+    { SPIRIT_TEMPLE_LOBBY, "Spirit Temple First Mirror Left Chest",                    CHEST_LOCATION,          SCENE_SPIRIT_TEMPLE, 0x0D, ITEM_INVALID_1, { // Ice trap
+        { AST_HAS, ITEM_STRENGTH_SILVER_GAUNTLETS }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SPIRIT_TEMPLE, 3 }, { AST_END }
+    }},
+    { SPIRIT_TEMPLE_LOBBY, "Spirit Temple First Mirror Right Chest",                   CHEST_LOCATION,          SCENE_SPIRIT_TEMPLE, 0x0E, ITEM_RECOVERY_HEART, {
+        { AST_HAS, ITEM_STRENGTH_SILVER_GAUNTLETS }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SPIRIT_TEMPLE, 3 }, { AST_END }
+    }},
+    { SPIRIT_TEMPLE_LOBBY, "Spirit Temple Statue Room Northeast Chest",                CHEST_LOCATION,          SCENE_SPIRIT_TEMPLE, 0x0F, ITEM_RUPEE_BLUE, {
+        { AST_HAS, ITEM_STRENGTH_SILVER_GAUNTLETS }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SPIRIT_TEMPLE, 3 }, { AST_END }
+    }},
+    { SPIRIT_TEMPLE_LOBBY, "Spirit Temple Statue Room Hand Chest",                     CHEST_LOCATION,          SCENE_SPIRIT_TEMPLE, 0x02, ITEM_SMALL_KEY_SPIRIT_TEMPLE, {
+        { AST_HAS, ITEM_STRENGTH_SILVER_GAUNTLETS }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SPIRIT_TEMPLE, 3 }, { AST_END }
+    }},
+    { SPIRIT_TEMPLE_LOBBY, "Spirit Temple Near Four Armos Chest",                      CHEST_LOCATION,          SCENE_SPIRIT_TEMPLE, 0x05, ITEM_SMALL_KEY_SPIRIT_TEMPLE, {
+        { AST_HAS, ITEM_STRENGTH_SILVER_GAUNTLETS }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SPIRIT_TEMPLE, 4 }, { AST_AND }, { AST_HAS, ITEM_SHIELD_MIRROR }, { AST_END }
+    }},
+    { SPIRIT_TEMPLE_LOBBY, "Spirit Temple Hallway Right Invisible Chest",              CHEST_LOCATION,          SCENE_SPIRIT_TEMPLE, 0x14, ITEM_RECOVERY_HEART, {
+        { AST_HAS, ITEM_STRENGTH_SILVER_GAUNTLETS }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SPIRIT_TEMPLE, 4 }, { AST_AND }, { AST_CAN_USE, ITEM_LENS_OF_TRUTH }, { AST_END }
+    }},
+    { SPIRIT_TEMPLE_LOBBY, "Spirit Temple Hallway Left Invisible Chest",               CHEST_LOCATION,          SCENE_SPIRIT_TEMPLE, 0x15, ITEM_RECOVERY_HEART, {
+        { AST_HAS, ITEM_STRENGTH_SILVER_GAUNTLETS }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SPIRIT_TEMPLE, 4 }, { AST_AND }, { AST_CAN_USE, ITEM_LENS_OF_TRUTH }, { AST_END }
+    }},
+    { SPIRIT_TEMPLE_HANDS, "Spirit Temple Mirror Shield Chest",                        CHEST_LOCATION,          SCENE_DESERT_COLOSSUS, 0x09, ITEM_SHIELD_MIRROR, {
+        { AST_HAS, ITEM_STRENGTH_SILVER_GAUNTLETS }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SPIRIT_TEMPLE, 4 }, { AST_END }
+    }},
+    { SPIRIT_TEMPLE_LOBBY, "Spirit Temple Boss Key Chest",                             CHEST_LOCATION,          SCENE_SPIRIT_TEMPLE, 0x0A, ITEM_DUNGEON_BOSS_KEY_SPIRIT_TEMPLE, {
+        { AST_HAS, ITEM_STRENGTH_SILVER_GAUNTLETS }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SPIRIT_TEMPLE, 5 }, { AST_AND }, { AST_HAS, ITEM_SHIELD_MIRROR }, { AST_END }
+    }},
+    { SPIRIT_TEMPLE_LOBBY, "Spirit Temple Topmost Chest",                              CHEST_LOCATION,          SCENE_SPIRIT_TEMPLE, 0x12, ITEM_BOMBS_20, {
+        { AST_HAS, ITEM_STRENGTH_SILVER_GAUNTLETS }, { AST_AND }, { AST_HAS_COUNT, ITEM_SMALL_KEY_SPIRIT_TEMPLE, 5 }, { AST_AND }, { AST_HAS, ITEM_SHIELD_MIRROR }, { AST_END }
+    }},
+    { SPIRIT_TEMPLE_BOSS, "Defeat Twinrova", EVENT_LOCATION, SCENE_SPIRIT_TEMPLE_BOSS, 0, EVENT_DEFEAT_TWINROVA, {
+        { AST_END }
+    }},
+    { ICE_CAVERN_LOBBY, "Ice Cavern Map Chest",                                     CHEST_LOCATION,          SCENE_ICE_CAVERN, 0x00, ITEM_DUNGEON_MAP, {
+        { AST_END }
+    }},
+    { ICE_CAVERN_LOBBY, "Ice Cavern Compass Chest",                                 CHEST_LOCATION,          SCENE_ICE_CAVERN, 0x01, ITEM_DUNGEON_COMPASS, {
+        { AST_END }
+    }},
+    { ICE_CAVERN_LOBBY, "Ice Cavern Iron Boots Chest",                              CHEST_LOCATION,          SCENE_ICE_CAVERN, 0x02, ITEM_BOOTS_IRON, {
+        { AST_END }
+    }},
+    { GERUDO_TRAINING_GROUND_LOBBY, "Gerudo Training Ground Lobby Left Chest",                  CHEST_LOCATION,          SCENE_GERUDO_TRAINING_GROUND, 0x13, ITEM_RUPEE_BLUE, {
+        { AST_CAN_USE, ITEM_BOW }, { AST_END }
+    }},
+    { GERUDO_TRAINING_GROUND_LOBBY, "Gerudo Training Ground Lobby Right Chest",                 CHEST_LOCATION,          SCENE_GERUDO_TRAINING_GROUND, 0x07, ITEM_ARROWS_10, {
+        { AST_CAN_USE, ITEM_BOW }, { AST_END }
+    }},
+    { GERUDO_TRAINING_GROUND_LOBBY, "Gerudo Training Ground Stalfos Chest",                     CHEST_LOCATION,          SCENE_GERUDO_TRAINING_GROUND, 0x00, ITEM_SMALL_KEY_GERUDO_TRAINING_GROUND, {
+        { AST_END }
+    }},
+    { GERUDO_TRAINING_GROUND_LOBBY, "Gerudo Training Ground Before Heavy Block Chest",          CHEST_LOCATION,          SCENE_GERUDO_TRAINING_GROUND, 0x11, ITEM_ARROWS_10, {
+        { AST_HAS, ITEM_HOOKSHOT }, { AST_END }
+    }},
+    { GERUDO_TRAINING_GROUND_LOBBY, "Gerudo Training Ground Heavy Block First Chest",           CHEST_LOCATION,          SCENE_GERUDO_TRAINING_GROUND, 0x0F, ITEM_RUPEE_GOLD, {
+        { AST_HAS, ITEM_STRENGTH_SILVER_GAUNTLETS }, { AST_END }
+    }},
+    { GERUDO_TRAINING_GROUND_LOBBY, "Gerudo Training Ground Heavy Block Second Chest",          CHEST_LOCATION,          SCENE_GERUDO_TRAINING_GROUND, 0x0E, ITEM_RUPEE_BLUE, {
+        { AST_HAS, ITEM_STRENGTH_SILVER_GAUNTLETS }, { AST_END }
+    }},
+    { GERUDO_TRAINING_GROUND_LOBBY, "Gerudo Training Ground Heavy Block Third Chest",           CHEST_LOCATION,          SCENE_GERUDO_TRAINING_GROUND, 0x14, ITEM_SMALL_KEY_GERUDO_TRAINING_GROUND, {
+        { AST_HAS, ITEM_STRENGTH_SILVER_GAUNTLETS }, { AST_END }
+    }},
+    { GERUDO_TRAINING_GROUND_LOBBY, "Gerudo Training Ground Heavy Block Fourth Chest",          CHEST_LOCATION,          SCENE_GERUDO_TRAINING_GROUND, 0x02, ITEM_INVALID_1, {
+        { AST_HAS, ITEM_STRENGTH_SILVER_GAUNTLETS }, { AST_END }
+    }},
+    { GERUDO_TRAINING_GROUND_LOBBY, "Gerudo Training Ground Eye Statue Chest",                  CHEST_LOCATION,          SCENE_GERUDO_TRAINING_GROUND, 0x03, ITEM_SMALL_KEY_GERUDO_TRAINING_GROUND, {
+        { AST_HAS, ITEM_BOW }, { AST_END }
+    }},
+    { GERUDO_TRAINING_GROUND_LOBBY, "Gerudo Training Ground Near Scarecrow Chest",              CHEST_LOCATION,          SCENE_GERUDO_TRAINING_GROUND, 0x04, ITEM_SMALL_KEY_GERUDO_TRAINING_GROUND, {
+        { AST_HAS, ITEM_BOW }, { AST_END }
+    }},
+    { GERUDO_TRAINING_GROUND_LOBBY, "Gerudo Training Ground Hammer Room Clear Chest",           CHEST_LOCATION,          SCENE_GERUDO_TRAINING_GROUND, 0x12, ITEM_ARROWS_10, {
+        { AST_END }
+    }},
+    { GERUDO_TRAINING_GROUND_LOBBY, "Gerudo Training Ground Hammer Room Switch Chest",          CHEST_LOCATION,          SCENE_GERUDO_TRAINING_GROUND, 0x10, ITEM_SMALL_KEY_GERUDO_TRAINING_GROUND, {
+        { AST_HAS, ITEM_HAMMER }, { AST_END }
+    }},
+    { GERUDO_TRAINING_GROUND_LOBBY, "Gerudo Training Ground Maze Right Central Chest",          CHEST_LOCATION,          SCENE_GERUDO_TRAINING_GROUND, 0x05, ITEM_BOMBCHUS_5, {
+        { AST_END }
+    }},
+    { GERUDO_TRAINING_GROUND_LOBBY, "Gerudo Training Ground Maze Right Side Chest",             CHEST_LOCATION,          SCENE_GERUDO_TRAINING_GROUND, 0x08, ITEM_ARROWS_30, {
+        { AST_END }
+    }},
+    { GERUDO_TRAINING_GROUND_LOBBY, "Gerudo Training Ground Underwater Silver Rupee Chest",     CHEST_LOCATION,          SCENE_GERUDO_TRAINING_GROUND, 0x0D, ITEM_SMALL_KEY_GERUDO_TRAINING_GROUND, {
+        { AST_CAN_USE, ITEM_BOOTS_IRON }, { AST_END }
+    }},
+    { GERUDO_TRAINING_GROUND_LOBBY, "Gerudo Training Ground Beamos Chest",                      CHEST_LOCATION,          SCENE_GERUDO_TRAINING_GROUND, 0x01, ITEM_SMALL_KEY_GERUDO_TRAINING_GROUND, {
+        { AST_END }
+    }},
+    { GERUDO_TRAINING_GROUND_LOBBY, "Gerudo Training Ground Hidden Ceiling Chest",              CHEST_LOCATION,          SCENE_GERUDO_TRAINING_GROUND, 0x0B, ITEM_SMALL_KEY_GERUDO_TRAINING_GROUND, {
+        { AST_HAS_COUNT, ITEM_SMALL_KEY_GERUDO_TRAINING_GROUND, 2 }, { AST_AND }, { AST_CAN_USE, ITEM_LENS_OF_TRUTH }, { AST_END }
+    }},
+    { GERUDO_TRAINING_GROUND_LOBBY, "Gerudo Training Ground Maze Path First Chest",             CHEST_LOCATION,          SCENE_GERUDO_TRAINING_GROUND, 0x06, ITEM_RUPEE_PURPLE, {
+        { AST_HAS_COUNT, ITEM_SMALL_KEY_GERUDO_TRAINING_GROUND, 3 }, { AST_END }
+    }},
+    { GERUDO_TRAINING_GROUND_LOBBY, "Gerudo Training Ground Maze Path Second Chest",            CHEST_LOCATION,          SCENE_GERUDO_TRAINING_GROUND, 0x0A, ITEM_RUPEE_RED, {
+        { AST_HAS_COUNT, ITEM_SMALL_KEY_GERUDO_TRAINING_GROUND, 5 }, { AST_END }
+    }},
+    { GERUDO_TRAINING_GROUND_LOBBY, "Gerudo Training Ground Maze Path Third Chest",             CHEST_LOCATION,          SCENE_GERUDO_TRAINING_GROUND, 0x09, ITEM_ARROWS_30, {
+        { AST_HAS_COUNT, ITEM_SMALL_KEY_GERUDO_TRAINING_GROUND, 6 }, { AST_END }
+    }},
+    { GERUDO_TRAINING_GROUND_LOBBY, "Gerudo Training Ground Maze Path Fourth Chest",            CHEST_LOCATION,          SCENE_GERUDO_TRAINING_GROUND, 0x0C, ITEM_ARROW_ICE, {
+        { AST_HAS_COUNT, ITEM_SMALL_KEY_GERUDO_TRAINING_GROUND, 8 }, { AST_END }
+    }},
+    { GANONS_CASTLE_LOBBY, "Ganon's Castle Forest Trial Chest",                        CHEST_LOCATION,          SCENE_INSIDE_GANONS_CASTLE, 0x09, ITEM_RUPEE_BLUE, {
+        { AST_END }
+    }},
+    { GANONS_CASTLE_LOBBY, "Ganon's Castle Water Trial Left Chest",                    CHEST_LOCATION,          SCENE_INSIDE_GANONS_CASTLE, 0x07, ITEM_INVALID_1, {
+        { AST_END }
+    }},
+    { GANONS_CASTLE_LOBBY, "Ganon's Castle Water Trial Right Chest",                   CHEST_LOCATION,          SCENE_INSIDE_GANONS_CASTLE, 0x06, ITEM_RECOVERY_HEART, {
+        { AST_END }
+    }},
+    { GANONS_CASTLE_LOBBY, "Ganon's Castle Shadow Trial Front Chest",                  CHEST_LOCATION,          SCENE_INSIDE_GANONS_CASTLE, 0x08, ITEM_RUPEE_BLUE, {
+        { AST_END }
+    }},
+    { GANONS_CASTLE_LOBBY, "Ganon's Castle Shadow Trial Golden Gauntlets Chest",       CHEST_LOCATION,          SCENE_INSIDE_GANONS_CASTLE, 0x05, ITEM_STRENGTH_GOLD_GAUNTLETS, {
+        { AST_END }
+    }},
+    { GANONS_CASTLE_LOBBY, "Ganon's Castle Light Trial First Left Chest",              CHEST_LOCATION,          SCENE_INSIDE_GANONS_CASTLE, 0x0C, ITEM_RUPEE_BLUE, {
+        { AST_HAS, ITEM_STRENGTH_GOLD_GAUNTLETS }, { AST_END }
+    }},
+    { GANONS_CASTLE_LOBBY, "Ganon's Castle Light Trial Second Left Chest",             CHEST_LOCATION,          SCENE_INSIDE_GANONS_CASTLE, 0x0B, ITEM_INVALID_1, {
+        { AST_HAS, ITEM_STRENGTH_GOLD_GAUNTLETS }, { AST_END }
+    }},
+    { GANONS_CASTLE_LOBBY, "Ganon's Castle Light Trial Third Left Chest",              CHEST_LOCATION,          SCENE_INSIDE_GANONS_CASTLE, 0x0D, ITEM_RECOVERY_HEART, {
+        { AST_HAS, ITEM_STRENGTH_GOLD_GAUNTLETS }, { AST_END }
+    }},
+    { GANONS_CASTLE_LOBBY, "Ganon's Castle Light Trial First Right Chest",             CHEST_LOCATION,          SCENE_INSIDE_GANONS_CASTLE, 0x0E, ITEM_INVALID_1, {
+        { AST_HAS, ITEM_STRENGTH_GOLD_GAUNTLETS }, { AST_END }
+    }},
+    { GANONS_CASTLE_LOBBY, "Ganon's Castle Light Trial Second Right Chest",            CHEST_LOCATION,          SCENE_INSIDE_GANONS_CASTLE, 0x0A, ITEM_ARROWS_30, {
+        { AST_HAS, ITEM_STRENGTH_GOLD_GAUNTLETS }, { AST_END }
+    }},
+    { GANONS_CASTLE_LOBBY, "Ganon's Castle Light Trial Third Right Chest",             CHEST_LOCATION,          SCENE_INSIDE_GANONS_CASTLE, 0x0F, ITEM_INVALID_1, {
+        { AST_HAS, ITEM_STRENGTH_GOLD_GAUNTLETS }, { AST_END }
+    }},
+    { GANONS_CASTLE_LOBBY, "Ganon's Castle Light Trial Invisible Enemies Chest",       CHEST_LOCATION,          SCENE_INSIDE_GANONS_CASTLE, 0x10, ITEM_SMALL_KEY_GANONS_CASTLE, {
+        { AST_HAS, ITEM_STRENGTH_GOLD_GAUNTLETS }, { AST_END }
+    }},
+    { GANONS_CASTLE_LOBBY, "Ganon's Castle Light Trial Lullaby Chest",                 CHEST_LOCATION,          SCENE_INSIDE_GANONS_CASTLE, 0x11, ITEM_SMALL_KEY_GANONS_CASTLE, {
+        { AST_HAS, ITEM_SMALL_KEY_GANONS_CASTLE }, { AST_END }
+    }},
+    { GANONS_CASTLE_LOBBY, "Ganon's Castle Spirit Trial Crystal Switch Chest",         CHEST_LOCATION,          SCENE_INSIDE_GANONS_CASTLE, 0x12, ITEM_BOMBCHUS_20, {
+        { AST_END }
+    }},
+    { GANONS_CASTLE_LOBBY, "Ganon's Castle Spirit Trial Invisible Chest",              CHEST_LOCATION,          SCENE_INSIDE_GANONS_CASTLE, 0x14, ITEM_ARROWS_30, {
+        { AST_END }
+    }},
+    { GANONS_CASTLE_TOWER, "Ganon's Tower Boss Key Chest",                             CHEST_LOCATION,          SCENE_GANONS_TOWER, 0x0B, ITEM_DUNGEON_BOSS_KEY_GANONS_CASTLE, {
+        { AST_HAS, ITEM_STRENGTH_GOLD_GAUNTLETS }, { AST_END }
+    }},
+    { GANONS_CASTLE_TOWER, "Ganon",                                                    EVENT_LOCATION,         SCENE_GANONS_TOWER, 0x00, EVENT_TRIFORCE, {
+        { AST_END }
+    }},
+};
+
+ItemTableRow itemTable[] = {
+    [ITEM_BOW]                                  = { GI_BOW,                 "Bow",                                  ITEM,       TRUE,   false },
+    [ITEM_SLINGSHOT]                            = { GI_SLINGSHOT,           "Slingshot",                            ITEM,       TRUE,   false },
+    [ITEM_BOMBCHU]                              = { GI_BOMBCHUS_10,         "Bombchus (10)",                        ITEM,       TRUE,   false },
+    [ITEM_HOOKSHOT]                             = { GI_HOOKSHOT,            "Hookshot",                             ITEM,       TRUE,   false },
+    [ITEM_LONGSHOT]                             = { GI_LONGSHOT,            "Longshot",                             ITEM,       TRUE,   false },
+    [ITEM_ARROW_ICE]                            = { GI_ARROW_ICE,           "Ice Arrows",                           ITEM,       NONE,   false },
+    [ITEM_BOOMERANG]                            = { GI_BOOMERANG,           "Boomerang",                            ITEM,       TRUE,   false },
+    [ITEM_LENS_OF_TRUTH]                        = { GI_LENS_OF_TRUTH,       "Lens of Truth",                        ITEM,       TRUE,   false },
+    [ITEM_HAMMER]                               = { GI_HAMMER,              "Megaton Hammer",                       ITEM,       TRUE,   false },
+    [ITEM_SWORD_KOKIRI]                         = { GI_SWORD_KOKIRI,        "Kokiri Sword",                         ITEM,       TRUE,   false },
+    [ITEM_SHIELD_DEKU]                          = { GI_SHIELD_DEKU,         "Deku Shield",                          ITEM,       NONE,   false },
+    [ITEM_SHIELD_HYLIAN]                        = { GI_SHIELD_HYLIAN,       "Hylian Shield",                        ITEM,       NONE,   false },
+    [ITEM_SHIELD_MIRROR]                        = { GI_SHIELD_MIRROR,       "Mirror Shield",                        ITEM,       TRUE,   false },
+    [ITEM_BOOTS_IRON]                           = { GI_BOOTS_IRON,          "Iron Boots",                           ITEM,       TRUE,   false },
+    [ITEM_BOOTS_HOVER]                          = { GI_BOOTS_HOVER,         "Hover Boots",                          ITEM,       TRUE,   false },
+    [ITEM_BOMB_BAG_20]                          = { GI_BOMB_BAG_20,         "Bomb Bag",                             ITEM,       TRUE,   false },
+    [ITEM_STRENGTH_SILVER_GAUNTLETS]            = { GI_SILVER_GAUNTLETS,    "Silver Gauntlets",                     ITEM,       TRUE,   false },
+    [ITEM_STRENGTH_GOLD_GAUNTLETS]              = { GI_GOLD_GAUNTLETS,      "Gold Gauntlets",                       ITEM,       TRUE,   false },
+    [ITEM_HEART_PIECE]                          = { GI_HEART_PIECE,         "Heart Piece",                          ITEM,       TRUE,   false },
+    [ITEM_DUNGEON_COMPASS]                      = { GI_COMPASS,             "Compass",                              COMPASS,    NONE,   false },
+    [ITEM_DUNGEON_MAP]                          = { GI_DUNGEON_MAP,         "Dungeon Map",                          MAP,        NONE,   false },
+    [ITEM_HEART_PIECE_2]                        = { GI_HEART_PIECE_WIN,     "Winner Heart",                         ITEM,       NONE,   false },
+    [ITEM_INVALID_1]                            = { GI_ICE_TRAP,            "Ice Trap",                             ITEM,       NONE,   true },
+    [ITEM_RECOVERY_HEART]                       = { GI_RECOVERY_HEART,      "Recovery Heart",                       ITEM,       NONE,   true },
+    [ITEM_RUPEE_GREEN]                          = { GI_RUPEE_GREEN,         "Rupee (1)",                            ITEM,       NONE,   true },
+    [ITEM_RUPEE_BLUE]                           = { GI_RUPEE_BLUE,          "Rupees (5)",                           ITEM,       NONE,   true },
+    [ITEM_RUPEE_RED]                            = { GI_RUPEE_RED,           "Rupees (20)",                          ITEM,       NONE,   true },
+    [ITEM_RUPEE_PURPLE]                         = { GI_RUPEE_PURPLE,        "Rupees (50)",                          ITEM,       NONE,   true },
+    [ITEM_RUPEE_GOLD]                           = { GI_RUPEE_GOLD,          "Rupees (200)",                         ITEM,       NONE,   true },
+    [ITEM_DEKU_NUTS_5]                          = { GI_DEKU_NUTS_5,         "Deku Nuts (5)",                        ITEM,       NONE,   true },
+    [ITEM_DEKU_NUTS_10]                         = { GI_DEKU_NUTS_10,        "Deku Nuts (10)",                       ITEM,       NONE,   true },
+    [ITEM_BOMBS_5]                              = { GI_BOMBS_5,             "Bombs (5)",                            ITEM,       NONE,   true },
+    [ITEM_BOMBS_10]                             = { GI_BOMBS_10,            "Bombs (10)",                           ITEM,       NONE,   true },
+    [ITEM_BOMBS_20]                             = { GI_BOMBS_20,            "Bombs (20)",                           ITEM,       NONE,   true },
+    [ITEM_ARROWS_5]                             = { GI_ARROWS_5,            "Arrows (5)",                           ITEM,       NONE,   true },
+    [ITEM_ARROWS_10]                            = { GI_ARROWS_10,           "Arrows (10)",                          ITEM,       NONE,   true },
+    [ITEM_ARROWS_30]                            = { GI_ARROWS_30,           "Arrows (30)",                          ITEM,       NONE,   true },
+    [ITEM_BOMBCHUS_5]                           = { GI_BOMBCHUS_5,          "Bombchus (5)",                         ITEM,       TRUE,   false },
+    [ITEM_BOMBCHUS_20]                          = { GI_BOMBCHUS_20,         "Bombchus (20)",                        ITEM,       TRUE,   false },
+    [ITEM_SMALL_KEY_FOREST_TEMPLE]              = { GI_SMALL_KEY,           "Small Key (Forest Temple)",            SMALL_KEY,  TRUE,   false },
+    [ITEM_SMALL_KEY_FIRE_TEMPLE]                = { GI_SMALL_KEY,           "Small Key (Fire Temple)",              SMALL_KEY,  TRUE,   false },
+    [ITEM_SMALL_KEY_WATER_TEMPLE]               = { GI_SMALL_KEY,           "Small Key (Water Temple)",             SMALL_KEY,  TRUE,   false },
+    [ITEM_SMALL_KEY_SPIRIT_TEMPLE]              = { GI_SMALL_KEY,           "Small Key (Spirit Temple)",            SMALL_KEY,  TRUE,   false },
+    [ITEM_SMALL_KEY_SHADOW_TEMPLE]              = { GI_SMALL_KEY,           "Small Key (Shadow Temple)",            SMALL_KEY,  TRUE,   false },
+    [ITEM_SMALL_KEY_BOTTOM_OF_THE_WELL]         = { GI_SMALL_KEY,           "Small Key (Bottom of the Well)",       SMALL_KEY,  TRUE,   false },
+    [ITEM_SMALL_KEY_GERUDO_TRAINING_GROUND]     = { GI_SMALL_KEY,           "Small Key (Gerudo Training Ground)",   SMALL_KEY,  TRUE,   false },
+    [ITEM_SMALL_KEY_GANONS_CASTLE]              = { GI_SMALL_KEY,           "Small Key (Ganon's Castle)",           SMALL_KEY,  TRUE,   false },
+    [ITEM_DUNGEON_BOSS_KEY_FOREST_TEMPLE]       = { GI_BOSS_KEY,            "Boss Key (Forest Temple)",             BOSS_KEY,   TRUE,   false },
+    [ITEM_DUNGEON_BOSS_KEY_FIRE_TEMPLE]         = { GI_BOSS_KEY,            "Boss Key (Fire Temple)",               BOSS_KEY,   TRUE,   false },
+    [ITEM_DUNGEON_BOSS_KEY_WATER_TEMPLE]        = { GI_BOSS_KEY,            "Boss Key (Water Temple)",              BOSS_KEY,   TRUE,   false },
+    [ITEM_DUNGEON_BOSS_KEY_SPIRIT_TEMPLE]       = { GI_BOSS_KEY,            "Boss Key (Spirit Temple)",             BOSS_KEY,   TRUE,   false },
+    [ITEM_DUNGEON_BOSS_KEY_SHADOW_TEMPLE]       = { GI_BOSS_KEY,            "Boss Key (Shadow Temple)",             BOSS_KEY,   TRUE,   false },
+    [ITEM_DUNGEON_BOSS_KEY_GANONS_CASTLE]       = { GI_BOSS_KEY,            "Boss Key (Ganon's Castle)",            BOSS_KEY,   TRUE,   false },
+    [EVENT_DEFEAT_GOHMA]                        = { GI_NONE,                "Defeat Gohma",                         EVENT_ITEM, TRUE,   false },
+    [EVENT_DEFEAT_KING_DODONGO]                 = { GI_NONE,                "Defeat King Dodongo",                  EVENT_ITEM, TRUE,   false },
+    [EVENT_DEFEAT_BARINADE]                     = { GI_NONE,                "Defeat Barinade",                      EVENT_ITEM, TRUE,   false },
+    [EVENT_DEFEAT_PHANTOM_GANON]                = { GI_NONE,                "Defeat Phantom Ganon",                 EVENT_ITEM, TRUE,   false },
+    [EVENT_DEFEAT_VOLVAGIA]                     = { GI_NONE,                "Defeat Volvagia",                      EVENT_ITEM, TRUE,   false },
+    [EVENT_DEFEAT_MORPHA]                       = { GI_NONE,                "Defeat Morpha",                        EVENT_ITEM, TRUE,   false },
+    [EVENT_DEFEAT_TWINROVA]                     = { GI_NONE,                "Defeat Twinrova",                      EVENT_ITEM, TRUE,   false },
+    [EVENT_DEFEAT_BONGO_BONGO]                  = { GI_NONE,                "Defeat Bongo-Bongo",                   EVENT_ITEM, TRUE,   false },
+    [EVENT_TRIFORCE]                            = { GI_NONE,                "Triforce",                             EVENT_ITEM, TRUE,   false },
+};
+
+RegionTableRow regionTable[] = {
+    [ROOT]                          = { "Root",                                 SCENE_ID_MAX },
+    [KOKIRI_FOREST]                 = { "Kokiri Forest",                        SCENE_ID_MAX },
+    [DEKU_TREE_LOBBY]               = { "Deku Tree Lobby",                      SCENE_DEKU_TREE },
+    [DEKU_TREE_BOSS]                = { "Gohma",                                SCENE_DEKU_TREE },
+    [LOST_WOODS]                    = { "Lost Woods",                           SCENE_ID_MAX },
+    [LOST_WOODS_BRIDGE]             = { "Lost Woods Bridge",                    SCENE_ID_MAX },
+    [SACRED_FOREST_MEADOW_ENTRY]    = { "Sacred Forest Meadow Entry",           SCENE_ID_MAX },
+    [GORON_CITY_WOODS_WARP]         = { "Goron City Woods Warp",                SCENE_ID_MAX },
+    [ZORA_RIVER]                    = { "Zora River",                           SCENE_ID_MAX },
+    [SACRED_FOREST_MEADOW]          = { "Sacred Forest Meadow",                 SCENE_ID_MAX },
+    [HYRULE_FIELD]                  = { "Hyrule Field",                         SCENE_ID_MAX },
+    [LAKE_HYLIA]                    = { "Lake Hylia",                           SCENE_ID_MAX },
+    [GERUDO_VALLEY]                 = { "Gerudo Valley",                        SCENE_ID_MAX },
+    [CASTLE_TOWN]                   = { "Market",                               SCENE_ID_MAX },
+    [KAKARIKO_VILLAGE]              = { "Kakariko Village",                     SCENE_ID_MAX },
+    [ZORA_RIVER_FRONT]              = { "Zora River Front",                     SCENE_ID_MAX },
+    [LON_LON_RANCH]                 = { "Lon Lon Ranch",                        SCENE_ID_MAX },
+    [ZORAS_DOMAIN]                  = { "Zora's Domain",                        SCENE_ID_MAX },
+    [WATER_TEMPLE_LOBBY]            = { "Water Temple Lobby",                   SCENE_WATER_TEMPLE },
+    [WATER_TEMPLE_BOSS]             = { "Morpha",                               SCENE_WATER_TEMPLE },
+    [GERUDO_VALLEY_FAR_SIDE]        = { "Gerudo Valley Far Side",               SCENE_ID_MAX },
+    [GERUDO_FORTRESS]               = { "Gerudo Fortress",                      SCENE_ID_MAX },
+    [HAUNTED_WASTELAND]             = { "Haunted Wasteland",                    SCENE_ID_MAX },
+    [GERUDO_TRAINING_GROUND_LOBBY]  = { "Gerudo Training Ground Lobby",         SCENE_GERUDO_TRAINING_GROUND },
+    [DESERT_COLOSSUS]               = { "Desert Colossus",                      SCENE_ID_MAX },
+    [SPIRIT_TEMPLE_LOBBY]           = { "Spirit Temple Lobby",                  SCENE_SPIRIT_TEMPLE },
+    [SPIRIT_TEMPLE_HANDS]           = { "Spirit Temple Hands",                  SCENE_ID_MAX },
+    [SPIRIT_TEMPLE_BOSS]            = { "Twinrova",                             SCENE_SPIRIT_TEMPLE },
+    [TEMPLE_OF_TIME]                = { "Temple of Time",                       SCENE_ID_MAX },
+    [HYRULE_CASTLE_GROUNDS]         = { "Hyrule Castle Grounds",                SCENE_ID_MAX },
+    [GANONS_CASTLE_GROUNDS]         = { "Outside Ganon's Castle",               SCENE_ID_MAX },
+    [BEYOND_DOOR_OF_TIME]           = { "Beyond Door of Time",                  SCENE_ID_MAX },
+    [GANONS_CASTLE_LOBBY]           = { "Ganon's Castle Lobby",                 SCENE_GANONS_TOWER },
+    [BOTTOM_OF_THE_WELL_LOBBY]      = { "Bottom of the Well Lobby",             SCENE_BOTTOM_OF_THE_WELL },
+    [GRAVEYARD]                     = { "Graveyard",                            SCENE_ID_MAX },
+    [SHADOW_TEMPLE_LOBBY]           = { "Shadow Temple Lobby",                  SCENE_SHADOW_TEMPLE },
+    [SHADOW_TEMPLE_BOSS]            = { "Bongo-Bongo",                          SCENE_SHADOW_TEMPLE },
+    [DEATH_MOUNTAIN]                = { "Death Mountain Trail",                 SCENE_ID_MAX },
+    [GORON_CITY]                    = { "Goron City",                           SCENE_ID_MAX },
+    [DEATH_MOUNTAIN_CRATER_UPPER]   = { "Death Mountain Crater Upper",          SCENE_ID_MAX },
+    [DODONGOS_CAVERN_LOBBY]         = { "Dodongo's Cavern Lobby",               SCENE_DODONGOS_CAVERN },
+    [DODONGOS_CAVERN_BOSS]          = { "King Dodongo",                         SCENE_DODONGOS_CAVERN },
+    [DEATH_MOUNTAIN_CRATER_LOWER]   = { "Death Mountain Crater Lower",          SCENE_ID_MAX },
+    [DEATH_MOUNTAIN_CRATER_CENTRAL] = { "Death Mountain Crater Central",        SCENE_ID_MAX },
+    [FIRE_TEMPLE_LOBBY]             = { "Fire Temple Lobby",                    SCENE_FIRE_TEMPLE },
+    [FIRE_TEMPLE_BIG_LAVA_ROOM]     = { "Fire Temple Big Lava Room",            SCENE_FIRE_TEMPLE },
+    [FIRE_TEMPLE_ELEVATOR_ROOM]     = { "Fire Temple Elevator Room",            SCENE_FIRE_TEMPLE },
+    [FIRE_TEMPLE_MAZE_LOWER]        = { "Fire Temple Boulder Maze Lower",       SCENE_FIRE_TEMPLE },
+    [FIRE_TEMPLE_NARROW_PATH]       = { "Fire Temple Narrow Path Room",         SCENE_FIRE_TEMPLE },
+    [FIRE_TEMPLE_MAZE_UPPER]        = { "Fire Temple Boulder Maze Upper",       SCENE_FIRE_TEMPLE },
+    [FIRE_TEMPLE_FLAME_MAZE]        = { "Fire Temple Flame Maze",               SCENE_FIRE_TEMPLE },
+    [FIRE_TEMPLE_UPPER]             = { "Fire Temple Upper",                    SCENE_FIRE_TEMPLE },
+    [FIRE_TEMPLE_BOSS]              = { "Volvagia",                             SCENE_FIRE_TEMPLE },
+    [ZORAS_FOUNTAIN]                = { "Zora's Fountain",                      SCENE_ID_MAX },
+    [JABU_JABUS_BELLY_LOBBY]        = { "Jabu-Jabu's Belly Lobby",              SCENE_JABU_JABU },
+    [JABU_JABUS_BELLY_BOSS]         = { "Barinade",                             SCENE_JABU_JABU },
+    [ICE_CAVERN_LOBBY]              = { "Ice Cavern Lobby",                     SCENE_ICE_CAVERN },
+    [FOREST_TEMPLE_LOBBY]           = { "Forest Temple Lobby",                  SCENE_FOREST_TEMPLE },
+    [FOREST_TEMPLE_BLOCK_PUSH_ROOM] = { "Forest Temple Block Push Room",        SCENE_FOREST_TEMPLE },
+    [FOREST_TEMPLE_STRAIGHT_HALL]   = { "Forest Temple Straightened Hall",      SCENE_FOREST_TEMPLE },
+    [FOREST_TEMPLE_OUTSIDE_UPPER]   = { "Forest Temple Outside Upper Ledge",    SCENE_FOREST_TEMPLE },
+    [FOREST_TEMPLE_BOW_REGION]      = { "Forest Temple Bow Region",             SCENE_FOREST_TEMPLE },
+    [FOREST_TEMPLE_FROZEN_EYE]      = { "Forest Temple Frozen Eye Switch Room", SCENE_FOREST_TEMPLE },
+    [FOREST_TEMPLE_BOSS]            = { "Phantom Ganon",                        SCENE_FOREST_TEMPLE },
+    [GANONS_CASTLE_TOWER]           = { "Ganon's Castle Tower",                 SCENE_GANONS_TOWER },
+};
+
+ExitTableRow exitTable[] = {
+#include "logic/root_region.logic.c"
+#include "logic/dungeon_region.logic.c"
+#include "logic/kokiri_forest_region.logic.c"
+#include "logic/hyrule_region.logic.c"
+#include "logic/gerudo_region.logic.c"
+#include "logic/goron_region.logic.c"
+#include "logic/zora_region.logic.c"
+};
diff --git a/src/overlays/gamestates/ovl_randomizer/r_tables.h b/src/overlays/gamestates/ovl_randomizer/r_tables.h
new file mode 100644
index 000000000..70bf2a115
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_tables.h
@@ -0,0 +1,45 @@
+#ifndef R_RANDOMIZER_LOCATION_TABLE_H
+#define R_RANDOMIZER_LOCATION_TABLE_H 1
+#include "randomizer.h"
+
+#include "r_ast.h"
+#include "z64item.h"
+
+typedef struct LocationTableRow {
+    RegionEnum regionKey;
+    const char* name;
+    LocationType type;
+    SceneID scene;
+    u8 flag;
+    ItemID vanillaItem;
+    Ast accessRule[MAX_AST_EVENTS];
+} LocationTableRow;
+
+extern LocationTableRow locationTable[178];
+
+typedef struct ItemTableRow {
+    GetItemID id;
+    const char* name;
+    ItemType type;
+    TriState advancement;
+    bool junk;
+} ItemTableRow;
+
+extern ItemTableRow itemTable[ITEM_NONE];
+
+typedef struct RegionTableRow {
+    const char* name;
+    SceneID dungeon;
+} RegionTableRow;
+
+extern RegionTableRow regionTable[REGION_MAX];
+
+typedef struct ExitTableRow {
+    RegionEnum regionKey;
+    const char* name;
+    Ast accessRule[MAX_AST_EVENTS];
+} ExitTableRow;
+
+extern ExitTableRow exitTable[126];
+
+#endif
diff --git a/src/overlays/gamestates/ovl_randomizer/r_thread.c b/src/overlays/gamestates/ovl_randomizer/r_thread.c
new file mode 100644
index 000000000..308d52996
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_thread.c
@@ -0,0 +1,120 @@
+#include "r_thread.h"
+
+#include "fault.h"
+#include "printf.h"
+#include "randomizer_play.h"
+#include "randomizer_state.h"
+
+#include "r_containers.h"
+#include "r_item_info.h"
+#include "r_fill.h"
+#include "r_location.h"
+#include "r_region.h"
+#include "r_world.h"
+
+#include "translation.h"
+#include "z64save.h"
+#include "zelda_arena.h"
+#include "libc64/qrand.h"
+
+char hashKeyBuffer[0x60] = { };
+
+void Randomizer_PrintUsedMemory() {
+    u32 max = 0, free = 0, allocated = 0;
+    u32* maxPtr = &max;
+    u32* freePtr = &free;
+    u32* allocatedPtr = &allocated;
+    ZeldaArena_GetSizes(maxPtr, freePtr, allocatedPtr);
+    PRINTF(VT_BGCOL(RED) "Remaining Memory: %d -- %d maxFree %d allocated" VT_RST "\n", free, max, allocated);
+}
+
+void PlaceItems(GameState* gameState, World* world) {
+    RandomizerState* this = (RandomizerState*)gameState;
+
+    DistributeItemsRestrictive(&this->state, world);
+}
+
+void Randomizer_Generate(GameState *gameState) {
+    RandomizerState* this = (RandomizerState*)gameState;
+
+    ItemInfo_InitAll();
+    World world = World_BuildWorldGraph();
+    World_SetDungeonNames(&world);
+
+    PlaceItems(&this->state, &world);
+
+    if (this->mode == RM_ERROR) {
+        ItemInfo_DestroyAll();
+        World_Destroy(&world);
+        return;
+    }
+
+    VECTOR_FOR_EACH(&world.regions, regions) {
+        Region_v regionContainer = ITERATOR_GET_AS(Region_v, &regions);
+        VECTOR_FOR_EACH(&regionContainer.data->locations, locations) {
+            Location_v locationContainer = ITERATOR_GET_AS(Location_v, &locations);
+            if (locationContainer.data == NULL) {
+                continue;
+            }
+            PRINTF("Location: %s -- ", locationContainer.data->name);
+            if (locationContainer.data->item.info != NULL) {
+                if (locationContainer.data->type == CHEST_LOCATION) {
+                    /* Actually "place" the items */
+                    RandomizerChestID index = Randomizer_GetRandomizedChestContents(locationContainer.data->scene, locationContainer.data->flag);
+                    gSaveContext.save.randomizer.chestContents[index] = locationContainer.data->item.info->giIndex;
+                }
+                PRINTF("Placed Item: %s\n", locationContainer.data->item.info->name);
+            }
+        }
+    }
+
+    gSaveContext.save.randomizer.generated = true;
+
+    ItemInfo_DestroyAll();
+    World_Destroy(&world);
+    Randomizer_PrintUsedMemory();
+}
+
+void Randomizer_ThreadEntry(void *arg) {
+    RandomizerState* randomizer = arg;
+
+    PRINTF(VT_CLS);
+    unsigned retries = 0;
+    while (retries++ < 10) {
+        ZeldaArena_Cleanup();
+
+        PRINTF("ZELDA ALLOC SIZE=%x\n", THA_GetRemaining(&randomizer->state.tha));
+        size_t zAllocSize = THA_GetRemaining(&randomizer->state.tha);
+        size_t zAlloc = (uintptr_t)GAME_STATE_ALLOC(&randomizer->state, zAllocSize, __FILE_NAME__, __LINE__);
+        size_t zAllocAligned = (zAlloc + 8) & ~0xF;
+        ZeldaArena_Init((void*)zAllocAligned, zAllocSize - (zAllocAligned - zAlloc));
+        PRINTF(T(" %08x-%08x\n", "Zelda Heap %08x-%08x\n"), zAllocAligned,
+               (u8*)zAllocAligned + zAllocSize - (s32)(zAllocAligned - zAlloc));
+
+        Rand_Seed(gSaveContext.save.randomizer.seed + retries);
+        OSTime start = osGetTime();
+        Randomizer_Generate(&randomizer->state);
+        OSTime final = osGetTime() - start;
+        OSTime finalSec = OS_CYCLES_TO_USEC(final) / 1000000;
+        OSTime finalMsecPart = (OS_CYCLES_TO_USEC(final) / 1000) - (finalSec) * 1000;
+        if (randomizer->mode == RM_ERROR) {
+            PRINTF(VT_COL(YELLOW, WHITE) "Generation failed in %llu.%llumsec" VT_RST "\n", finalSec, finalMsecPart);
+            PRINTF("Retrying...\n");
+            THA_Reset(&randomizer->state.tha);
+        } else {
+            PRINTF(VT_COL(GREEN, WHITE) "Generated in %llu.%llumsec" VT_RST "\n", finalSec, finalMsecPart);
+            break;
+        }
+    }
+
+#ifdef DEBUG_FEATURES_MEM
+    PRINTF("Max allocated: %u\n", ZeldaArena_MaxAllocated());
+#endif
+    ZeldaArena_Cleanup();
+
+    if (randomizer->mode == RM_ERROR) {
+        randomizer->mode = RM_FINISHED_ERROR;
+    } else {
+        randomizer->mode = RM_FINISHING;
+    }
+}
diff --git a/src/overlays/gamestates/ovl_randomizer/r_thread.h b/src/overlays/gamestates/ovl_randomizer/r_thread.h
new file mode 100644
index 000000000..52c1497e2
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_thread.h
@@ -0,0 +1,9 @@
+#ifndef R_THREAD_H
+#define R_THREAD_H 1
+#include "stddef.h"
+
+extern size_t maxAllocated;
+
+void Randomizer_ThreadEntry(void *arg);
+
+#endif
diff --git a/src/overlays/gamestates/ovl_randomizer/r_world.c b/src/overlays/gamestates/ovl_randomizer/r_world.c
new file mode 100644
index 000000000..4d4f6b883
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_world.c
@@ -0,0 +1,319 @@
+#include "r_world.h"
+
+#include "fault.h"
+#include "hashtable.h"
+#include "printf.h"
+#include "randomizer.h"
+#include "r_ast.h"
+#include "r_containers.h"
+#include "r_entrance.h"
+#include "r_location.h"
+#include "r_region.h"
+#include "r_tables.h"
+#include "vector.h"
+#include "z64scene.h"
+#include "zelda_arena.h"
+#include "libc64/sprintf.h"
+
+LocationHashTable locationCache = { };
+RegionHashTable regionCache = { };
+EntranceVector allLocationsCache;
+
+void LoadRegionsFromTable(World* world);
+void SetRules(World* world);
+Location* GetLocation(World* world, char const* name);
+void GenerateItemPool(World* world);
+
+void World_SetDungeonNames(World* world) {
+    world->dungeons[SCENE_DEKU_TREE].name = "Deku Tree";
+    world->dungeons[SCENE_DODONGOS_CAVERN].name = "Dodongo's Cavern";
+    world->dungeons[SCENE_JABU_JABU].name = "Jabu Jabu";
+    world->dungeons[SCENE_FOREST_TEMPLE].name = "Forest Temple";
+    world->dungeons[SCENE_FIRE_TEMPLE].name = "Fire Temple";
+    world->dungeons[SCENE_WATER_TEMPLE].name = "Water Temple";
+    world->dungeons[SCENE_SPIRIT_TEMPLE].name = "Spirit Temple";
+    world->dungeons[SCENE_SHADOW_TEMPLE].name = "Shadow Temple";
+    world->dungeons[SCENE_BOTTOM_OF_THE_WELL].name = "Bottom of the Well";
+    world->dungeons[SCENE_ICE_CAVERN].name = "Ice Cavern";
+    world->dungeons[SCENE_GANONS_TOWER].name = "Ganon's Castle";
+    world->dungeons[SCENE_GERUDO_TRAINING_GROUND].name = "Gerudo Training Ground";
+}
+
+World World_BuildWorldGraph() {
+    World world = { };
+    ht_setup(&locationCache, sizeof(hashKeyBuffer), sizeof(Location_v), HT_MINIMUM_CAPACITY);
+    ht_setup(&regionCache, sizeof(hashKeyBuffer), sizeof(Region_v), HT_MINIMUM_CAPACITY);
+
+    LoadRegionsFromTable(&world);
+    World_InitializeEntrances(&world);
+    GenerateItemPool(&world);
+
+    return world;
+}
+
+void World_Destroy(World* world) {
+    vector_destroy(&world->itemPool);
+    VECTOR_FOR_EACH(&world->regions, regions) {
+        Region_v region = ITERATOR_GET_AS(Region_v, &regions);
+        Region_Destroy(region.data);
+    }
+    vector_destroy(&world->regions);
+    VECTOR_FOR_EACH(&allLocationsCache, locs) {
+        Location_v loc = ITERATOR_GET_AS(Location_v, &locs);
+        if (vector_is_initialized(&loc.data->itemRules)) {
+            VECTOR_FOR_EACH(&loc.data->itemRules, rules) {
+                Ast_v rule = ITERATOR_GET_AS(Ast_v, &rules);
+                Ast_Free(rule.data);
+            }
+            vector_destroy(&loc.data->itemRules);
+        }
+    }
+    vector_destroy(&allLocationsCache);
+    ht_iterate(&locationCache, ht_free);
+    ht_destroy(&locationCache);
+    ht_iterate(&locationCache, ht_free);
+    ht_destroy(&regionCache);
+}
+
+void LoadRegionsFromTable(World* world) {
+    vector_setup(&world->regions, REGION_MAX, sizeof(Region_v));
+    for (size_t i = 0; i < REGION_MAX; i++) {
+        Region* region = Region_Init(i);
+        if (region == NULL) {
+            continue;
+        }
+
+        Region_v container = { region };
+        vector_push_back(&world->regions, &container);
+    }
+}
+
+void SetRules(World* world) {
+    /* Ganon can only carry triforce */
+    Location* location = GetLocation(world, "Ganon");
+    vector_setup(&location->itemRules, VECTOR_MINIMUM_CAPACITY, sizeof(Ast_v));
+    Ast* rule = AST_NEW(AST_NAME, "Triforce");
+    Ast_v container = { rule };
+    vector_push_back(&location->itemRules, &container);
+    rule = AST_NEW(AST_END);
+    container.data = rule;
+    vector_push_back(&location->itemRules, &container);
+}
+
+Region* World_GetRegion(World* world, char const* name) {
+    memset(hashKeyBuffer, 0, sizeof(hashKeyBuffer));
+    strcpy(hashKeyBuffer, name);
+
+    Region* region = NULL;
+
+    if (!ht_is_empty(&regionCache)) {
+        region = ((Region_v*)ht_lookup(&regionCache, hashKeyBuffer))->data;
+    }
+
+    if (region != NULL) {
+        return region;
+    }
+
+    VECTOR_FOR_EACH(&world->regions, regions) {
+        Region_v regionContainer = ITERATOR_GET_AS(Region_v, &regions);
+        memset(hashKeyBuffer, 0, sizeof(hashKeyBuffer));
+        strcpy(hashKeyBuffer, regionContainer.data->name);
+        ht_insert(&regionCache, hashKeyBuffer, &regionContainer);
+    }
+    memset(hashKeyBuffer, 0, sizeof(hashKeyBuffer));
+    strcpy(hashKeyBuffer, name);
+
+    region = ((Region_v*)ht_lookup(&regionCache, hashKeyBuffer))->data;
+    if (region != NULL) {
+        return region;
+    }
+
+    char msg[0x100];
+    sprintf(msg, "No such region %s", name);
+    PRINTF("Randomizer error! %s\n", msg);
+    Fault_AddHungupAndCrashImpl(" RANDOMIZER ERROR", msg);
+}
+
+Location* GetLocation(World* world, char const* name) {
+    memset(hashKeyBuffer, 0, sizeof(hashKeyBuffer));
+    strcpy(hashKeyBuffer, name);
+
+    Location* location = NULL;
+
+    if (!ht_is_empty(&regionCache)) {
+        location = ((Location_v*)ht_lookup(&locationCache, hashKeyBuffer))->data;
+    }
+
+    if (location != NULL) {
+        return location;
+    }
+
+    VECTOR_FOR_EACH(&world->regions, regions) {
+        Region_v regionContainer = ITERATOR_GET_AS(Region_v, &regions);
+        VECTOR_FOR_EACH(&regionContainer.data->locations, locations) {
+            Location_v container = ITERATOR_GET_AS(Location_v, &locations);
+            memset(hashKeyBuffer, 0, sizeof(hashKeyBuffer));
+            strcpy(hashKeyBuffer, container.data->name);
+            ht_insert(&locationCache, hashKeyBuffer, &container);
+        }
+    }
+    memset(hashKeyBuffer, 0, sizeof(hashKeyBuffer));
+    strcpy(hashKeyBuffer, name);
+
+    location = ((Location_v*)ht_lookup(&locationCache, hashKeyBuffer))->data;
+
+    if (location != NULL) {
+        return location;
+    }
+
+    char msg[0x100];
+    sprintf(msg, "No such location %s", name);
+    PRINTF("Randomizer error! %s\n", msg);
+    Fault_AddHungupAndCrashImpl(" RANDOMIZER ERROR", msg);
+}
+
+LocationVector World_GetLocations(World* world) {
+    if (vector_is_initialized(&allLocationsCache)) {
+        return allLocationsCache;
+    }
+
+    vector_setup(&allLocationsCache, VECTOR_MINIMUM_CAPACITY, sizeof(Location_v));
+    VECTOR_FOR_EACH(&world->regions, regions) {
+        Region_v regionContainer = ITERATOR_GET_AS(Region_v, &regions);
+        VECTOR_FOR_EACH(&regionContainer.data->locations, locations) {
+            Location_v locationContainer = ITERATOR_GET_AS(Location_v, &locations);
+            vector_push_back(&allLocationsCache, &locationContainer);
+        }
+    }
+
+    return allLocationsCache;
+}
+
+LocationVector World_GetUnfilledLocations(World* world) {
+    LocationVector unfilledLocations;
+    vector_setup(&unfilledLocations, VECTOR_MINIMUM_CAPACITY, sizeof(Location_v));
+
+    LocationVector allLocations = World_GetLocations(world);
+    VECTOR_FOR_EACH(&allLocations, locations) {
+        Location_v container = ITERATOR_GET_AS(Location_v, &locations);
+        if (container.data->item.info == NULL) {
+            vector_push_back(&unfilledLocations, &container);
+        }
+    }
+
+    return unfilledLocations;
+}
+
+void GenerateItemPool(World* world) {
+    LocationVector locations = World_GetLocations(world);
+    StringVector pool;
+
+    vector_setup(&pool, VECTOR_MINIMUM_CAPACITY, sizeof(String_v));
+    VECTOR_FOR_EACH(&locations, locationI) {
+        Location_v locationContainer = ITERATOR_GET_AS(Location_v, &locationI);
+        Location location = *locationContainer.data;
+
+        TriState shuffleItem = NONE;
+
+        if (itemTable[location.vanillaItem].type == EVENT_ITEM) {
+            /* Always placed items */
+            shuffleItem = FALSE;
+        } else if (location.scene <= SCENE_GERUDO_TRAINING_GROUND || location.scene == SCENE_INSIDE_GANONS_CASTLE) {
+            /* Dungeon Items */
+            SceneID dungeon = location.scene;
+            if (location.scene == SCENE_INSIDE_GANONS_CASTLE) {
+                dungeon = SCENE_GANONS_TOWER;
+            }
+            ItemType dungeonItemType = ITEM;
+
+            if (location.vanillaItem >= ITEM_DUNGEON_BOSS_KEY_FOREST_TEMPLE && location.vanillaItem <= ITEM_DUNGEON_BOSS_KEY_GANONS_CASTLE) {
+                dungeonItemType = BOSS_KEY;
+                shuffleItem = NONE;
+            } else if (location.vanillaItem >= ITEM_SMALL_KEY_FOREST_TEMPLE && location.vanillaItem <= ITEM_SMALL_KEY_GERUDO_TRAINING_GROUND) {
+                dungeonItemType = SMALL_KEY;
+                shuffleItem = NONE;
+            } else if (location.vanillaItem == ITEM_DUNGEON_MAP) {
+                dungeonItemType = MAP;
+                shuffleItem = NONE;
+            } else if (location.vanillaItem == ITEM_DUNGEON_COMPASS) {
+                dungeonItemType = COMPASS;
+                shuffleItem = NONE;
+            } else {
+                dungeonItemType = ITEM;
+                shuffleItem = TRUE;
+            }
+
+            switch (dungeonItemType) {
+                case BOSS_KEY:
+                    world->dungeons[dungeon].bossKey = true;
+                    break;
+                case MAP:
+                    world->dungeons[dungeon].map = true;
+                    break;
+                case COMPASS:
+                    world->dungeons[dungeon].compass = true;
+                    break;
+                case SMALL_KEY:
+                    world->dungeons[dungeon].smallKeys += 1;
+                    break;
+                default:
+            }
+        } else if (location.type == CHEST_LOCATION) {
+            /* Rest of the items */
+            shuffleItem = TRUE;
+        }
+
+        if (shuffleItem == TRUE) {
+            String_v container = { itemTable[location.vanillaItem].name };
+            vector_push_back(&pool, &container);
+        } else if (shuffleItem != NONE) {
+            Item* newItem = Item_Init(itemTable[location.vanillaItem].name, false);
+            locationContainer.data->item = *newItem;
+            ZELDA_ARENA_FREE(newItem, __FILE_NAME__, __LINE__);
+        }
+    }
+
+    vector_setup(&world->itemPool, VECTOR_MINIMUM_CAPACITY, sizeof(Item_v));
+    world->itemPool = Item_Factory(pool);
+}
+
+ItemVector World_GetRestrictedDungeonItems(World* world) {
+    ItemVector dungeonItems;
+    vector_setup(&dungeonItems, VECTOR_MINIMUM_CAPACITY, sizeof(Item_v));
+    Item_v container = { };
+
+    for (SceneID dungeon = SCENE_DEKU_TREE; dungeon <= SCENE_GERUDO_TRAINING_GROUND; dungeon++) {
+        if (world->dungeons[dungeon].bossKey) {
+            container.data = Item_Init(itemTable[ITEM_DUNGEON_BOSS_KEY_DEKU_TREE + dungeon].name, false);
+            container.data->scene = dungeon;
+            vector_push_back(&dungeonItems, &container);
+        }
+        if (world->dungeons[dungeon].map) {
+            container.data = Item_Init("Dungeon Map", false);
+            container.data->scene = dungeon;
+            vector_push_back(&dungeonItems, &container);
+        }
+        if (world->dungeons[dungeon].compass) {
+            container.data = Item_Init("Compass", false);
+            container.data->scene = dungeon;
+            vector_push_back(&dungeonItems, &container);
+        }
+        for (size_t i = 0; i < world->dungeons[dungeon].smallKeys; i++) {
+            container.data = Item_Init(itemTable[ITEM_SMALL_KEY_DEKU_TREE + dungeon].name, false);
+            container.data->scene = dungeon;
+            vector_push_back(&dungeonItems, &container);
+        }
+    }
+
+    return dungeonItems;
+}
+
+void World_InitializeEntrances(World* world) {
+    VECTOR_FOR_EACH(&world->regions, regions) {
+        Region_v regionContainer = ITERATOR_GET_AS(Region_v, &regions);
+        VECTOR_FOR_EACH(&regionContainer.data->exits, exits) {
+            Entrance_v exitContainer = ITERATOR_GET_AS(Entrance_v, &exits);
+            Entrance_Connect(exitContainer.data, World_GetRegion(world, exitContainer.data->name));
+        }
+    }
+}
diff --git a/src/overlays/gamestates/ovl_randomizer/r_world.h b/src/overlays/gamestates/ovl_randomizer/r_world.h
new file mode 100644
index 000000000..5f1b2bf28
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/r_world.h
@@ -0,0 +1,35 @@
+#ifndef R_WORLD_H
+#define R_WORLD_H 1
+
+#include "r_containers.h"
+#include "r_search.h"
+#include "ultra64/ultratypes.h"
+
+typedef struct Dungeon Dungeon;
+typedef struct World World;
+
+struct Dungeon {
+    const char* name;
+    bool map;
+    bool compass;
+    bool bossKey;
+    u8 smallKeys;
+};
+
+struct World {
+    RegionVector regions;
+    ItemVector itemPool;
+    ItemHashTable eventItems;
+    Dungeon dungeons[12];
+};
+
+World World_BuildWorldGraph();
+void World_SetDungeonNames(World* world);
+void World_InitializeEntrances(World* world);
+Region* World_GetRegion(World* world, char const* name);
+LocationVector World_GetLocations(World* world);
+LocationVector World_GetUnfilledLocations(World* world);
+ItemVector World_GetRestrictedDungeonItems(World* world);
+void World_Destroy(World* world);
+
+#endif
diff --git a/src/overlays/gamestates/ovl_randomizer/randomizer.h b/src/overlays/gamestates/ovl_randomizer/randomizer.h
new file mode 100644
index 000000000..781e4125b
--- /dev/null
+++ b/src/overlays/gamestates/ovl_randomizer/randomizer.h
@@ -0,0 +1,101 @@
+#ifndef R_RANDOMIZER_H
+#define R_RANDOMIZER_H 1
+
+#define MAX_AST_EVENTS 0x10
+
+typedef enum {
+    ROOT,
+    KOKIRI_FOREST,
+    DEKU_TREE_LOBBY,
+    DEKU_TREE_BOSS,
+    LOST_WOODS,
+    LOST_WOODS_BRIDGE,
+    SACRED_FOREST_MEADOW_ENTRY,
+    GORON_CITY_WOODS_WARP,
+    ZORA_RIVER,
+    SACRED_FOREST_MEADOW,
+    HYRULE_FIELD,
+    LAKE_HYLIA,
+    GERUDO_VALLEY,
+    CASTLE_TOWN,
+    KAKARIKO_VILLAGE,
+    ZORA_RIVER_FRONT,
+    LON_LON_RANCH,
+    ZORAS_DOMAIN,
+    WATER_TEMPLE_LOBBY,
+    WATER_TEMPLE_BOSS,
+    GERUDO_VALLEY_FAR_SIDE,
+    GERUDO_FORTRESS,
+    HAUNTED_WASTELAND,
+    GERUDO_TRAINING_GROUND_LOBBY,
+    DESERT_COLOSSUS,
+    SPIRIT_TEMPLE_LOBBY,
+    SPIRIT_TEMPLE_HANDS,
+    SPIRIT_TEMPLE_BOSS,
+    TEMPLE_OF_TIME,
+    HYRULE_CASTLE_GROUNDS,
+    GANONS_CASTLE_GROUNDS,
+    BEYOND_DOOR_OF_TIME,
+    GANONS_CASTLE_LOBBY,
+    BOTTOM_OF_THE_WELL_LOBBY,
+    GRAVEYARD,
+    SHADOW_TEMPLE_LOBBY,
+    SHADOW_TEMPLE_BOSS,
+    DEATH_MOUNTAIN,
+    GORON_CITY,
+    DEATH_MOUNTAIN_CRATER_UPPER,
+    DODONGOS_CAVERN_LOBBY,
+    DODONGOS_CAVERN_BOSS,
+    DEATH_MOUNTAIN_CRATER_LOWER,
+    DEATH_MOUNTAIN_CRATER_CENTRAL,
+    FIRE_TEMPLE_LOBBY,
+    FIRE_TEMPLE_BIG_LAVA_ROOM,
+    FIRE_TEMPLE_ELEVATOR_ROOM,
+    FIRE_TEMPLE_MAZE_LOWER,
+    FIRE_TEMPLE_NARROW_PATH,
+    FIRE_TEMPLE_MAZE_UPPER,
+    FIRE_TEMPLE_FLAME_MAZE,
+    FIRE_TEMPLE_UPPER,
+    FIRE_TEMPLE_BOSS,
+    ZORAS_FOUNTAIN,
+    JABU_JABUS_BELLY_LOBBY,
+    JABU_JABUS_BELLY_BOSS,
+    ICE_CAVERN_LOBBY,
+    FOREST_TEMPLE_LOBBY,
+    FOREST_TEMPLE_BLOCK_PUSH_ROOM,
+    FOREST_TEMPLE_STRAIGHT_HALL,
+    FOREST_TEMPLE_OUTSIDE_UPPER,
+    FOREST_TEMPLE_BOW_REGION,
+    FOREST_TEMPLE_FROZEN_EYE,
+    FOREST_TEMPLE_BOSS,
+    GANONS_CASTLE_TOWER,
+    REGION_MAX
+} RegionEnum;
+
+typedef enum {
+    ITEM,
+    BOSS_KEY,
+    COMPASS,
+    MAP,
+    SMALL_KEY,
+    EVENT_ITEM,
+    SONG,
+    DUNGEON_REWARD,
+} ItemType;
+
+typedef enum {
+    CHEST_LOCATION,
+    EVENT_LOCATION,
+} LocationType;
+
+typedef enum TriState {
+    TRUE,
+    FALSE,
+    NONE
+} TriState;
+
+void Randomizer_ThreadEntry(void* arg);
+
+void Randomizer_PrintUsedMemory();
+
+#endif
\ No newline at end of file
diff --git a/src/overlays/gamestates/ovl_title/z_title.c b/src/overlays/gamestates/ovl_title/z_title.c
index 588588b24..fdd6beba4 100644
--- a/src/overlays/gamestates/ovl_title/z_title.c
+++ b/src/overlays/gamestates/ovl_title/z_title.c
@@ -31,7 +31,6 @@
 
 #include "assets/textures/nintendo_rogo_static/nintendo_rogo_static.h"
 
-#if DEBUG_FEATURES
 void ConsoleLogo_PrintBuildInfo(Gfx** gfxP) {
     Gfx* gfx;
     GfxPrint* printer;
@@ -42,18 +41,21 @@ void ConsoleLogo_PrintBuildInfo(Gfx** gfxP) {
     GfxPrint_Init(printer);
     GfxPrint_Open(printer, gfx);
     GfxPrint_SetColor(printer, 255, 155, 255, 255);
+    GfxPrint_SetPos(printer, 32, 27);
+    GfxPrint_Printf(printer, "V%s", gBuildVersion);
+#if DEBUG_FEATURES
     GfxPrint_SetPos(printer, 9, 21);
-    GfxPrint_Printf(printer, "NOT MARIO CLUB VERSION");
+    GfxPrint_Printf(printer, "RANDOMIZER (DEBUG)");
     GfxPrint_SetColor(printer, 255, 255, 255, 255);
     GfxPrint_SetPos(printer, 7, 23);
     GfxPrint_Printf(printer, "[Creator:%s]", gBuildCreator);
     GfxPrint_SetPos(printer, 7, 24);
     GfxPrint_Printf(printer, "[Date:%s]", gBuildDate);
+#endif
     gfx = GfxPrint_Close(printer);
     GfxPrint_Destroy(printer);
     *gfxP = gfx;
 }
-#endif
 
 void ConsoleLogo_Calc(ConsoleLogoState* this) {
 #if !PLATFORM_GC
@@ -173,14 +175,10 @@ void ConsoleLogo_Main(GameState* thisx) {
     ConsoleLogo_Calc(this);
     ConsoleLogo_Draw(this);
 
-#if DEBUG_FEATURES
-    if (gIsCtrlr2Valid) {
-        Gfx* gfx = POLY_OPA_DISP;
+    Gfx* gfx = POLY_OPA_DISP;
 
-        ConsoleLogo_PrintBuildInfo(&gfx);
-        POLY_OPA_DISP = gfx;
-    }
-#endif
+    ConsoleLogo_PrintBuildInfo(&gfx);
+    POLY_OPA_DISP = gfx;
 
 #if PLATFORM_IQUE
     this->exit = true;
diff --git a/src/overlays/misc/ovl_kaleido_scope/z_kaleido_equipment.c b/src/overlays/misc/ovl_kaleido_scope/z_kaleido_equipment.c
index 75c942820..b4210c0f7 100644
--- a/src/overlays/misc/ovl_kaleido_scope/z_kaleido_equipment.c
+++ b/src/overlays/misc/ovl_kaleido_scope/z_kaleido_equipment.c
@@ -184,86 +184,103 @@ void KaleidoScope_DrawEquipment(PlayState* play) {
 
             cursorMoveResult = 0;
             do {
-                if (pauseCtx->stickAdjX < -30) {
-                    if (pauseCtx->cursorX[PAUSE_EQUIP] != 0) {
-                        pauseCtx->cursorX[PAUSE_EQUIP]--;
-                        pauseCtx->cursorPoint[PAUSE_EQUIP] -= 1;
-
-                        if (pauseCtx->cursorX[PAUSE_EQUIP] == 0) {
-                            if (pauseCtx->cursorY[PAUSE_EQUIP] == 0) {
-                                if (CUR_UPG_VALUE(UPG_BULLET_BAG) != 0) {
-                                    cursorMoveResult = 1;
-                                }
-                            } else {
-                                if (CUR_UPG_VALUE(pauseCtx->cursorY[PAUSE_EQUIP]) != 0) {
-                                    cursorMoveResult = 1;
+                if (pauseCtx->stickAdjX < -30) { // left pressed
+                    cursorX--;
+                    cursorPoint -= 1; // move left
+
+                    while (cursorX >= 0) {
+                        // If now on the leftmost column, check if current row upgrade obtained
+                        if (cursorX == 0) {
+                            if (cursorY == 0) { // if in top row
+                                if (CUR_UPG_VALUE(UPG_BULLET_BAG) != 0) { // if bullet bag obtained (normally middle of array)
+                                    cursorMoveResult = 1; // allow movement to cursor point
+                                    break;
                                 }
                             }
-                        } else {
-                            if (gBitFlags[pauseCtx->cursorPoint[PAUSE_EQUIP] - 1] &
-                                gSaveContext.save.info.inventory.equipment) {
-                                cursorMoveResult = 2;
+                            else {
+                                if (CUR_UPG_VALUE(cursorY) != 0) { // check upgrade obtained for slot
+                                    cursorMoveResult = 1; // allow movement to cursor point
+                                    break;
+                                }
                             }
                         }
-                    } else {
-                        pauseCtx->cursorX[PAUSE_EQUIP] = cursorX;
-                        pauseCtx->cursorY[PAUSE_EQUIP]++;
 
-                        if (pauseCtx->cursorY[PAUSE_EQUIP] >= 4) {
-                            pauseCtx->cursorY[PAUSE_EQUIP] = 0;
+                        // In other columns check if current row equipment obtained
+                        if (cursorPoint > 0 && gBitFlags[cursorPoint - 1] &
+                        gSaveContext.save.info.inventory.equipment) {
+                            cursorMoveResult = 2;
+                            break;
                         }
 
-                        pauseCtx->cursorPoint[PAUSE_EQUIP] =
-                            pauseCtx->cursorX[PAUSE_EQUIP] + (pauseCtx->cursorY[PAUSE_EQUIP] * 4);
+                        // Move cursor towards the bottom row
+                        cursorY += 1;
+                        cursorPoint += EQUIP_GRID_COLS;
 
-                        if (pauseCtx->cursorPoint[PAUSE_EQUIP] >= 16) {
-                            pauseCtx->cursorPoint[PAUSE_EQUIP] = pauseCtx->cursorX[PAUSE_EQUIP];
+                        // If trying to go below last row, loop back to the first row
+                        if (cursorY >= EQUIP_GRID_ROWS) {
+                            cursorY = 0;
+                        }
+                        if (cursorPoint >= EQUIP_GRID_ROWS * EQUIP_GRID_COLS) {
+                            cursorPoint = cursorX;
                         }
 
+                        // Looped over all rows in the column, move on to the next column
                         if (cursorY == pauseCtx->cursorY[PAUSE_EQUIP]) {
-                            pauseCtx->cursorX[PAUSE_EQUIP] = cursorX;
-                            pauseCtx->cursorPoint[PAUSE_EQUIP] = cursorPoint;
-                            KaleidoScope_MoveCursorToSpecialPos(play, PAUSE_CURSOR_PAGE_LEFT);
-                            cursorMoveResult = 3;
+                            cursorX--;
+                            cursorPoint = cursorX + cursorY * EQUIP_GRID_COLS;
                         }
                     }
+
+                    pauseCtx->cursorPoint[PAUSE_EQUIP] = cursorPoint;
+                    pauseCtx->cursorX[PAUSE_EQUIP] = cursorX;
+                    pauseCtx->cursorY[PAUSE_EQUIP] = cursorY;
+
+                    if (cursorX < 0) {
+                        KaleidoScope_MoveCursorToSpecialPos(play, PAUSE_CURSOR_PAGE_LEFT);
+                        cursorMoveResult = 3;
+                    }
                 } else if (pauseCtx->stickAdjX > 30) {
-                    if (pauseCtx->cursorX[PAUSE_EQUIP] < 3) {
-                        pauseCtx->cursorX[PAUSE_EQUIP]++;
-                        pauseCtx->cursorPoint[PAUSE_EQUIP] += 1;
+                    pauseCtx->cursorX[PAUSE_EQUIP]++;
+                    pauseCtx->cursorPoint[PAUSE_EQUIP] += 1;
 
-                        if (pauseCtx->cursorX[PAUSE_EQUIP] == 0) {
-                            if (CUR_UPG_VALUE(pauseCtx->cursorY[PAUSE_EQUIP]) != 0) {
-                                cursorMoveResult = 1;
-                            }
-                        } else {
-                            if (gBitFlags[pauseCtx->cursorPoint[PAUSE_EQUIP] - 1] &
-                                gSaveContext.save.info.inventory.equipment) {
-                                cursorMoveResult = 2;
-                            }
-                        }
-                    } else {
-                        pauseCtx->cursorX[PAUSE_EQUIP] = cursorX;
-                        pauseCtx->cursorY[PAUSE_EQUIP]++;
+                    cursorX = pauseCtx->cursorX[PAUSE_EQUIP];
+                    cursorY = pauseCtx->cursorY[PAUSE_EQUIP];
+                    cursorPoint = pauseCtx->cursorPoint[PAUSE_EQUIP];
 
-                        if (pauseCtx->cursorY[PAUSE_EQUIP] >= 4) {
-                            pauseCtx->cursorY[PAUSE_EQUIP] = 0;
+                    while (cursorX < EQUIP_GRID_COLS) {
+                        if (gBitFlags[cursorPoint - 1] &
+                            gSaveContext.save.info.inventory.equipment) {
+                            cursorMoveResult = 2;
+                            break;
                         }
 
-                        pauseCtx->cursorPoint[PAUSE_EQUIP] =
-                            pauseCtx->cursorX[PAUSE_EQUIP] + (pauseCtx->cursorY[PAUSE_EQUIP] * 4);
+                        // Move cursor towards the bottom row
+                        cursorY += 1;
+                        cursorPoint += EQUIP_GRID_COLS;
 
-                        if (pauseCtx->cursorPoint[PAUSE_EQUIP] >= 16) {
-                            pauseCtx->cursorPoint[PAUSE_EQUIP] = pauseCtx->cursorX[PAUSE_EQUIP];
+                        // If trying to go below last row, loop back to the first row
+                        if (cursorY >= EQUIP_GRID_ROWS) {
+                            cursorY = 0;
+                        }
+                        if (cursorPoint >= EQUIP_GRID_ROWS * EQUIP_GRID_COLS) {
+                            cursorPoint = cursorX;
                         }
 
+                        // Looped over all rows in the column, move on to the next column
                         if (cursorY == pauseCtx->cursorY[PAUSE_EQUIP]) {
-                            pauseCtx->cursorX[PAUSE_EQUIP] = cursorX;
-                            pauseCtx->cursorPoint[PAUSE_EQUIP] = cursorPoint;
-                            KaleidoScope_MoveCursorToSpecialPos(play, PAUSE_CURSOR_PAGE_RIGHT);
-                            cursorMoveResult = 3;
+                            cursorX++;
+                            cursorPoint = cursorX + cursorY * EQUIP_GRID_COLS;
                         }
                     }
+
+                    pauseCtx->cursorPoint[PAUSE_EQUIP] = cursorPoint;
+                    pauseCtx->cursorX[PAUSE_EQUIP] = cursorX;
+                    pauseCtx->cursorY[PAUSE_EQUIP] = cursorY;
+
+                    if (cursorX >= EQUIP_GRID_COLS) {
+                        KaleidoScope_MoveCursorToSpecialPos(play, PAUSE_CURSOR_PAGE_RIGHT);
+                        cursorMoveResult = 3;
+                    }
                 } else {
                     cursorMoveResult = 4;
                 }
diff --git a/src/overlays/misc/ovl_kaleido_scope/z_kaleido_item.c b/src/overlays/misc/ovl_kaleido_scope/z_kaleido_item.c
index 97458d024..ed85cc17c 100644
--- a/src/overlays/misc/ovl_kaleido_scope/z_kaleido_item.c
+++ b/src/overlays/misc/ovl_kaleido_scope/z_kaleido_item.c
@@ -168,77 +168,94 @@ void KaleidoScope_DrawItemSelect(PlayState* play) {
 
                 do {
                     if (pauseCtx->stickAdjX < -30) { // left
-                        // if not on the left-most column
-                        if (pauseCtx->cursorX[PAUSE_ITEM] != 0) {
-                            // move left
-                            pauseCtx->cursorX[PAUSE_ITEM]--;
-                            pauseCtx->cursorPoint[PAUSE_ITEM] -= 1;
+                        // move left
+                        pauseCtx->cursorX[PAUSE_ITEM]--;
+                        pauseCtx->cursorPoint[PAUSE_ITEM] -= 1;
 
+                        cursorX = pauseCtx->cursorX[PAUSE_ITEM];
+                        cursorY = pauseCtx->cursorY[PAUSE_ITEM];
+                        cursorPoint = pauseCtx->cursorPoint[PAUSE_ITEM];
+
+                        while (cursorX >= 0) {
                             // if there's an item there, stop there
-                            if (gSaveContext.save.info.inventory.items[pauseCtx->cursorPoint[PAUSE_ITEM]] !=
-                                ITEM_NONE) {
+                            if (gSaveContext.save.info.inventory.items[cursorPoint] != ITEM_NONE) {
                                 cursorMoveResult = 1;
+                                break;
                             }
-                        } else {
-                            // move the cursor to its initial horizontal position and try find an item on the next line
 
-                            pauseCtx->cursorX[PAUSE_ITEM] = cursorX;
+                            // Move cursor towards the bottom row
+                            cursorY += 1;
+                            cursorPoint += ITEM_GRID_COLS;
 
-                            pauseCtx->cursorY[PAUSE_ITEM]++;
-                            if (pauseCtx->cursorY[PAUSE_ITEM] >= ITEM_GRID_ROWS) {
-                                pauseCtx->cursorY[PAUSE_ITEM] = 0;
+                            // If trying to go below last row, loop back to first row
+                            if (cursorY >= ITEM_GRID_ROWS) {
+                                cursorY = 0;
                             }
-
-                            pauseCtx->cursorPoint[PAUSE_ITEM] =
-                                pauseCtx->cursorX[PAUSE_ITEM] + (pauseCtx->cursorY[PAUSE_ITEM] * ITEM_GRID_COLS);
-
-                            if (pauseCtx->cursorPoint[PAUSE_ITEM] >= (ITEM_GRID_ROWS * ITEM_GRID_COLS)) {
-                                pauseCtx->cursorPoint[PAUSE_ITEM] = pauseCtx->cursorX[PAUSE_ITEM];
+                            if (cursorPoint >= ITEM_GRID_ROWS * ITEM_GRID_COLS) {
+                                cursorPoint = cursorX;
                             }
 
+                            // Looped over all rows in the column, move on to the next column
                             if (cursorY == pauseCtx->cursorY[PAUSE_ITEM]) {
-                                // there is no item to the left of the initial position, on any line
-
-                                pauseCtx->cursorX[PAUSE_ITEM] = cursorX;
-                                pauseCtx->cursorPoint[PAUSE_ITEM] = cursorPoint;
+                                cursorX--;
+                                cursorPoint = cursorX + cursorY * ITEM_GRID_COLS;
+                            }
+                        }
 
-                                KaleidoScope_MoveCursorToSpecialPos(play, PAUSE_CURSOR_PAGE_LEFT);
+                        pauseCtx->cursorPoint[PAUSE_ITEM] = cursorPoint;
+                        pauseCtx->cursorX[PAUSE_ITEM] = cursorX;
+                        pauseCtx->cursorY[PAUSE_ITEM] = cursorY;
 
-                                cursorMoveResult = 2;
-                            }
+                        if (cursorX < 0) {
+                            KaleidoScope_MoveCursorToSpecialPos(play, PAUSE_CURSOR_PAGE_LEFT);
+                            cursorMoveResult = 2;
                         }
                     } else if (pauseCtx->stickAdjX > 30) {
-                        if (pauseCtx->cursorX[PAUSE_ITEM] < (ITEM_GRID_COLS - 1)) {
-                            pauseCtx->cursorX[PAUSE_ITEM]++;
-                            pauseCtx->cursorPoint[PAUSE_ITEM] += 1;
+                        // if right pressed
+                        pauseCtx->cursorX[PAUSE_ITEM]++; // move cursor to the right
+                        pauseCtx->cursorPoint[PAUSE_ITEM] += 1; // move cursor to the right
 
-                            if (gSaveContext.save.info.inventory.items[pauseCtx->cursorPoint[PAUSE_ITEM]] !=
-                                ITEM_NONE) {
-                                cursorMoveResult = 1;
-                            }
-                        } else {
-                            pauseCtx->cursorX[PAUSE_ITEM] = cursorX;
-                            pauseCtx->cursorY[PAUSE_ITEM]++;
+                        cursorX = pauseCtx->cursorX[PAUSE_ITEM];
+                        cursorY = pauseCtx->cursorY[PAUSE_ITEM];
+                        cursorPoint = pauseCtx->cursorPoint[PAUSE_ITEM];
 
-                            if (pauseCtx->cursorY[PAUSE_ITEM] >= ITEM_GRID_ROWS) {
-                                pauseCtx->cursorY[PAUSE_ITEM] = 0;
+                        while (cursorX < ITEM_GRID_COLS) {
+                            // If item found, use found position
+                            if (gSaveContext.save.info.inventory.items[cursorPoint] != ITEM_NONE) {
+                                pauseCtx->cursorPoint[PAUSE_ITEM] = cursorPoint;
+                                pauseCtx->cursorX[PAUSE_ITEM] = cursorX;
+                                pauseCtx->cursorY[PAUSE_ITEM] = cursorY;
+                                cursorMoveResult = 1;
+                                break;
                             }
 
-                            pauseCtx->cursorPoint[PAUSE_ITEM] =
-                                pauseCtx->cursorX[PAUSE_ITEM] + (pauseCtx->cursorY[PAUSE_ITEM] * ITEM_GRID_COLS);
+                            // Move cursor towards the bottom row until it finds an item
+                            cursorY += 1;
+                            cursorPoint += ITEM_GRID_COLS;
 
-                            if (pauseCtx->cursorPoint[PAUSE_ITEM] >= (ITEM_GRID_ROWS * ITEM_GRID_COLS)) {
-                                pauseCtx->cursorPoint[PAUSE_ITEM] = pauseCtx->cursorX[PAUSE_ITEM];
+                            // If trying to go below last row, loop back to first row
+                            if (cursorY >= ITEM_GRID_ROWS) {
+                                cursorY = 0;
+                            }
+                            if (cursorPoint >= ITEM_GRID_ROWS * ITEM_GRID_COLS) {
+                                cursorPoint = cursorX;
                             }
 
+                            // Looped over all rows in the column, move on to the next one
                             if (cursorY == pauseCtx->cursorY[PAUSE_ITEM]) {
-                                pauseCtx->cursorX[PAUSE_ITEM] = cursorX;
-                                pauseCtx->cursorPoint[PAUSE_ITEM] = cursorPoint;
+                                cursorX++;
+                                cursorPoint = cursorX + cursorY * ITEM_GRID_COLS;
+                            }
+                        }
 
-                                KaleidoScope_MoveCursorToSpecialPos(play, PAUSE_CURSOR_PAGE_RIGHT);
+                        pauseCtx->cursorPoint[PAUSE_ITEM] = cursorPoint;
+                        pauseCtx->cursorX[PAUSE_ITEM] = cursorX;
+                        pauseCtx->cursorY[PAUSE_ITEM] = cursorY;
 
-                                cursorMoveResult = 2;
-                            }
+                        if (cursorX == ITEM_GRID_COLS) {
+                            // Looped over all possible item locations, move to right special pos
+                            KaleidoScope_MoveCursorToSpecialPos(play, PAUSE_CURSOR_PAGE_RIGHT);
+                            cursorMoveResult = 2;
                         }
                     }
                 } while (cursorMoveResult == 0);
diff --git a/src/overlays/misc/ovl_kaleido_scope/z_kaleido_scope.h b/src/overlays/misc/ovl_kaleido_scope/z_kaleido_scope.h
index 27454ee1f..c20dbb77d 100644
--- a/src/overlays/misc/ovl_kaleido_scope/z_kaleido_scope.h
+++ b/src/overlays/misc/ovl_kaleido_scope/z_kaleido_scope.h
@@ -141,6 +141,9 @@ typedef enum PromptQuad {
 #define ITEM_AMMO_ONES_QUAD_OFFSET_X 6
 #define ITEM_AMMO_ONES_QUAD_OFFSET_Y 0
 
+#define EQUIP_GRID_ROWS 4
+#define EQUIP_GRID_COLS 4
+
 typedef enum ItemQuad {
     // 0 to 23 are the ITEM_GRID_ROWS*ITEM_GRID_COLS item grid
     // The values follow the `InventorySlot` enum
diff --git a/tools/generate_dma_config.py b/tools/generate_dma_config.py
new file mode 100644
index 000000000..007ab1bd4
--- /dev/null
+++ b/tools/generate_dma_config.py
@@ -0,0 +1,101 @@
+#!/usr/bin/env python3
+
+import argparse
+import mapfile_parser
+import sys
+import struct
+
+from io import StringIO
+from pathlib import Path
+from dataclasses import dataclass
+
+# from https://stackoverflow.com/a/16571630
+class Capturing(list):
+    def __enter__(self):
+        self._stdout = sys.stdout
+        sys.stdout = self._stringio = StringIO()
+        return self
+    def __exit__(self, *args):
+        self.extend(self._stringio.getvalue().splitlines())
+        del self._stringio    # free up some memory
+        sys.stdout = self._stdout
+
+@dataclass
+class DmaInfo:
+    name: str
+    index: int
+
+@dataclass
+class DmaEntry:
+    vromStart: str
+    vromEnd: str
+    romStart: str
+    romEnd: str
+
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser(description="gamecube utility")
+    parser.add_argument("-v", "--version", help="OoT Version", default="gc-jp")
+    parser.add_argument("-c", "--codec", help="Compression Codec", default="yaz")
+    args = parser.parse_args()
+
+    VERSION = args.version
+    DMATABLE_PATH = Path(f"build/{VERSION}/dmadata_table_spec.h").resolve()
+    ROM_PATH = f"build/{VERSION}/oot-{VERSION}-compressed.z64"
+    sceneFiles: list[DmaInfo] = []
+    otherFiles: list[DmaInfo] = []
+    allFiles: list[DmaInfo] = []
+
+    dmaTable = DMATABLE_PATH.read_text().split("\n")
+    for i, dmaEntry in enumerate(dmaTable):
+        entryName = dmaEntry.removeprefix("DEFINE_DMA_ENTRY(").removesuffix(")").split(", ")[0]
+        allFiles.append(DmaInfo(entryName, i))
+        if entryName.endswith("_scene"):
+            sceneFiles.append(DmaInfo(entryName, i))
+        if entryName in { "code", "ovl_title", "vr_holy0_static", "elf_message_field", "ydan_scene"}:
+            otherFiles.append(DmaInfo(entryName, i))
+
+    i = sceneFiles[-1].index
+    entryName = dmaTable[i + 1].removeprefix("DEFINE_DMA_ENTRY(").removesuffix(")").split(", ")[0]
+    sceneFiles.append(DmaInfo(entryName, i + 1))
+    
+    mapFile = f"oot-{VERSION}.map" if VERSION != "hackeroot-mq" else "hackeroot-mq.map"
+    BUILTMAP = Path("build") / VERSION / mapFile
+    mapPath = BUILTMAP
+    with Capturing() as stdout:
+        ret = mapfile_parser.frontends.sym_info.doSymInfo(mapPath, "gDmaDataTable")
+    assert ret == 0
+    split = stdout[0].removesuffix(")").split("(")[1].split(", ")
+    table_offset = int(split[1].removeprefix('VROM: '), 16)
+    table_size = int(split[2].removeprefix('SIZE: '), 16)
+
+    dbg_output = "--- Debug Informations ---\n"
+    files = otherFiles + sceneFiles
+    data = []
+    for info in files:
+        data.append(struct.pack(">H", info.index))
+        dbg_output += f"- {info.index:04}; {repr(info.name)}\n"
+
+    data_bytes = b"".join(data)
+    while len(data_bytes) % 32:
+        data_bytes += b"".join([struct.pack(">x")])
+
+    # header
+    output = b"".join(
+        [
+            "DMAC".encode("utf-8"),
+            struct.pack(">I", table_offset),
+            struct.pack(">H", table_size),
+            struct.pack(">H", len(data_bytes)),
+            struct.pack(">H", len(data)),
+        ]
+    )
+    while len(output) % 32:
+        output += b"".join([struct.pack(">x")])
+
+    # data
+    output += data_bytes
+    while len(output) % 32:
+        output += b"".join([struct.pack(">x")])
+
+    out = Path("build/" + VERSION + "/dma_config.bin").resolve()
+    out.write_bytes(output)
diff --git a/tools/generate_lib_config.py b/tools/generate_lib_config.py
new file mode 100644
index 000000000..aa636884b
--- /dev/null
+++ b/tools/generate_lib_config.py
@@ -0,0 +1,154 @@
+#!/usr/bin/env python3
+
+import argparse
+import mapfile_parser
+import sys
+import struct
+
+from io import StringIO
+from pathlib import Path
+from dataclasses import dataclass
+
+# from https://stackoverflow.com/a/16571630
+class Capturing(list):
+    def __enter__(self):
+        self._stdout = sys.stdout
+        sys.stdout = self._stringio = StringIO()
+        return self
+    def __exit__(self, *args):
+        self.extend(self._stringio.getvalue().splitlines())
+        del self._stringio    # free up some memory
+        sys.stdout = self._stdout
+
+# - function name
+# - function address
+# - function size
+
+@dataclass
+class SymInfo:
+    name: str
+    vram: int
+    vrom: int
+    size: int
+    o_path: Path
+
+def get_sym_info(map_path: Path, symbol: str):
+    with Capturing() as stdout:
+        ret = mapfile_parser.frontends.sym_info.doSymInfo(map_path, symbol)
+    assert ret == 0, f"failed with {symbol}"
+
+    split = stdout[0].removesuffix(")").split("(")
+    split2 = split[1].split(", ")
+
+    return SymInfo(
+        split[0].split(" ")[1].removeprefix("'").removesuffix("'"),
+        int(split2[0].split(" ")[1], 16),
+        int(split2[1].split(" ")[1], 16),
+        int(split2[2].split(" ")[1], 16),
+        Path(split2[3]).resolve(),
+    )
+
+funcs_to_process = [
+    # "send_mesg",
+    # "__osEnqueueAndYield",
+    # "__osEnqueueThread",
+    # "__osPopThread",
+    # "__osDispatchThread",
+    "osGetMemSize",
+    "osInvalDCache",
+    "osInvalICache",
+    "osWritebackDCache",
+    "osWritebackDCacheAll",
+    "__osDisableInt",
+    "__osRestoreInt",
+    "__osSpSetStatus",
+    "cosf",
+    "sinf",
+    "bzero",
+    "bcopy",
+    "memcpy",
+    "osVirtualToPhysical",
+    # "osPhysicalToVirtual",
+    "guMtxF2L",
+    # "guMtxCatF",
+    "guMtxIdentF",
+    "guMtxIdent",
+    "guOrthoF",
+    "guOrtho",
+    "guPerspectiveF",
+    "guPerspective",
+    # "guScaleF",
+    "guScale",
+    "guRotateF",
+    "guRotate",
+    # "guTranslateF",
+    "guTranslate",
+    "guLookAtF",
+    "guLookAt",
+    "guLookAtHiliteF",
+    "guLookAtHilite",
+    # "guLookAtReflectF",
+    # "guLookAtReflect",
+    "osAiSetFrequency",
+    "osAiSetNextBuffer",
+    # "__osEepStatus",
+    # "osEepromRead",
+    # "osEepromWrite",
+    # "osEepromLongRead",
+    # "osEepromLongWrite",
+    "osGetCount",
+    "osViSwapBuffer",
+]
+
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser(description="gamecube utility")
+    parser.add_argument("-v", "--version", help="OoT Version", default="ntsc-1.2")
+    parser.add_argument("-c", "--codec", help="Compression Codec", default="yaz")
+    args = parser.parse_args()
+
+    VERSION = args.version
+    map_file = f"oot-{VERSION}.map"
+    ROM_PATH = Path(f"build/{VERSION}/oot-{VERSION}.z64").resolve()
+    BUILTMAP = Path("build") / VERSION / map_file
+
+    # header
+    output = b"".join(
+        [
+            "LIBC".encode("utf-8"),
+            struct.pack(">H", len(funcs_to_process)),
+        ]
+    )
+    while len(output) % 32:
+        output += b"".join([struct.pack(">x")])
+
+    for func in funcs_to_process:
+        sym_info = get_sym_info(BUILTMAP, func)
+
+        with ROM_PATH.open("rb") as file:
+            file.seek(sym_info.vrom)
+            rom_data = file.read(sym_info.size)
+
+        name = sym_info.name
+
+        match name:
+            case "cosf":
+                name = "__cosf"
+            case "sinf":
+                name = "__sinf"
+            case "osViSwapBuffer":
+                name = "osViSwapBuffer_Entry"
+
+        entry = b"".join(
+            [
+                struct.pack(">I", sym_info.vram),
+                struct.pack(">I", sym_info.size),
+                name.encode("utf-8"),
+            ]
+        )
+        while len(entry) % 0x20:
+            entry += b"".join([struct.pack(">x")])
+
+        output += entry
+
+    out = Path("build/" + VERSION + "/lib_config.bin").resolve()
+    out.write_bytes(output)
